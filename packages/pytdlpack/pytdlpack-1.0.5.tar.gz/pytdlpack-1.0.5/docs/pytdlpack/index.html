<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pytdlpack API documentation</title>
<meta name="description" content="Introduction
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pytdlpack</code></h1>
</header>
<section id="section-intro">
<h1 id="introduction">Introduction</h1>
<p>pytdlpack is a Python interface to reading/writing TDLPACK files via official
MOS-2000 (MOS2K) Fortran-based source files.
The necessary MOS2K source files are included
in this package and are available as module, tdlpack.</p>
<p>TDLPACK is a GRIB-like binary data format that is exclusive to MOS2K Fortran-based
sofftware system.
This software system was developed at the Meteorological Development
Laboratory (MDL) within NOAA/NWS and its primary purpose is to perform statistical
post-processing of meteorological data.</p>
<p>TDLPACK-formatted data are contained in two type of Fortran-based files;
sequential or random-access.
Sequential files are variable length, record-based, and unformatted.
Random-access files are fixed-length and direct-access.
pytdlpack accommodates reading
and writing of both types of TDLPACK files.</p>
<p>TDLPACK format is based on the World Meteorological Organizations (WMO) GRIdded Binary (GRIB)
code, but has been tailored to MDL needs for data &ndash; mainly the ability to store 1D (vector),
datasets such as station observations, along with 2D grids.</p>
<p>There also exists two other types of records in a TDLPACK file: station call letter record
and trailer record.
A station call letter record can exist in both types of TDLPACK files
and contains a stream of alphanumeric characters (<code>CHARACTER(LEN=8)</code>).
A trailer record exists
to signal the MOS2K system that another station call letter record is about to be read or we
have reached the end of the file (EOF).
A trailer record is not written to a random-access
file.</p>
<p>For more information on the MOS-2000 software system and TDLPACK foremat, user is
referred to the official <a href="https://www.weather.gov/media/mdl/TDL_OfficeNote00-1.pdf">MOS-2000 documentation</a>.</p>
<p>In order for pytdlpack to read/write TDLPACK files, we need to compile the necessary MOS2K
Fortran source code into a shared object library.
This is handled by the setup process as the
Fortran source is compiled with f2py (included with Numpy).
The following are some important
items to note regarding MOS2K source files included:</p>
<ul>
<li>Several Fortran 90+ source files have been created to better interface to MOS2K Fortran 77 code.</li>
<li>The only modification made to MOS2K source files is changing the filename variable, <code>CFILX</code> from
<code>CHARACTER*60</code> to <code>CHARACTER*1024</code> in the appropropriate subroutines where random-access file IO
occurs.</li>
</ul>
<h1 id="download">Download</h1>
<ul>
<li>Latest code from <a href="https://github.com/eengl/pytdlpack">github repository</a>.</li>
<li>Latest <a href="https://github.com/eengl/pytdlpack/releases">releases</a> on GitHub.</li>
<li><a href="https://pypi.org/project/pytdlpack">PyPI</a></li>
</ul>
<h1 id="requires">Requires</h1>
<ul>
<li>Python 3.6+</li>
<li><a href="http://numpy.scipy.org">numpy array module</a>, version 1.12 or later.</li>
<li><a href="https://pypi.python.org/pypi/setuptools">setuptools</a>, version 18.0 or later.</li>
<li>GNU or Intel Fortran compiler (if installing from source).</li>
</ul>
<h1 id="install">Install</h1>
<pre><code class="language-shell">pip3 install pytdlpack
</code></pre>
<p><strong>Build and Install from Source</strong></p>
<pre><code class="language-shell">python3 setup.py build_ext --fcompiler=[gnu95|intelem] build
python3 setup.py install [--user | --prefix=PREFIX]
</code></pre>
<h1 id="tutorial">Tutorial</h1>
<ol>
<li><a href="#section1">Creating/Opening/Closing a TDLPACK file.</a></li>
<li><a href="#section2">Reading a TDLPACK file.</a></li>
<li><a href="#section3">Writing a TDLPACK file.</a></li>
<li><a href="#section4">Creating a TDLPACK Station Record.</a></li>
<li><a href="#section5">Creating a TDLPACK Record.</a></li>
<li><a href="#section6">Packing/Unpacking a TDLPACK Record.</a></li>
</ol>
<h2 id="1-creatingopeningclosing-a-tdlpack-file"><div id='section1'>1) Creating/Opening/Closing a TDLPACK file.</h2>
<p>To create a TDLPACK file from Python, you call the <code><a title="pytdlpack.open" href="#pytdlpack.open">open()</a></code> function and provide the
file name and <code>mode='w' or 'a'</code>.
For <code>mode='a'</code>, this will append to an existing file.
When
creating a new file, the default file format is <code>'sequential'</code>, but the user can also specify
the format with <code>format='sequential' or 'random-access'</code>.
If the new file is random-access,
then the user can also specify <code>ra_template='small' or 'large'</code>.
The default is 'small' and
'large' is recommended for a high-resolution grids (i.e. ~ &gt; 2M total points).</p>
<p>Example: Create a new sequential file:</p>
<pre><code class="language-python">&gt;&gt;&gt; import pytdlpack
&gt;&gt;&gt; f = pytdlpack.open('test.sq',mode='w')
</code></pre>
<p>Example: Create a new random-access file:</p>
<pre><code class="language-python">&gt;&gt;&gt; import pytdlpack
&gt;&gt;&gt; f = pytdlpack.open('test.sq',mode='w',format='random-access',ra_template='small')
</code></pre>
<p>To open an existing TDLPACK file, simply provide the filename since the default mode is read.</p>
<pre><code class="language-python">import pytdlpack
&gt;&gt;&gt; f = pytdlpack.open('test.sq')
&gt;&gt;&gt; type(f)
&lt;class 'pytdlpack._pytdlpack.TdlpackFile'&gt;
&gt;&gt;&gt; f
byte_order = &gt;
data_type =
eof = False
format = sequential
fortran_lun = 65535
mode = r
name = test.sq
position = 0
ra_master_key = None
size = 998672
</code></pre>
<p>To close a TDLPACK file is straightforward.</p>
<pre><code class="language-python">&gt;&gt;&gt; f.close()
</code></pre>
<h2 id="2-reading-a-tdlpack-file"><div id='section2'>2) Reading a TDLPACK file.</h2>
<p>When a TDLPACK file is opened, an instance of class <code><a title="pytdlpack.TdlpackFile" href="#pytdlpack.TdlpackFile">TdlpackFile</a></code> is created.<br>
To read a record the file, use the class method <code><a title="pytdlpack.TdlpackFile.read" href="#pytdlpack.TdlpackFile.read">TdlpackFile.read()</a></code>.
By default
only 1 record is returned and the TDLPACK indentification sections are unpacked.</p>
<p>Example: Reading a gridded TDLPACK record.</p>
<pre><code class="language-python">&gt;&gt;&gt; x = f.read()
&gt;&gt;&gt; x
grid_length = 2539.703
id = [223254166         0         6         0]
ioctet = 998656
ipack = [1347175508  255654144 1191249890 ...          0          0          0]
is0 = [1347175508     998649          0          0          0          0
          0          0          0          0          0          0
          0          0          0          0          0          0
          0          0          0          0          0          0
          0          0          0          0          0          0
          0          0          0          0          0          0
          0          0          0          0          0          0
          0          0          0          0          0          0
          0          0          0          0          0          0]
is1 = [        71          1       2018         12          4          0
          0 2018120400  223254166          0          6          0
          6          0         66          0          1          0
          0          0          0         32          0          0
          0          0          0          0          0          0
          0          0          0          0          0          0
          0          0          0          0          0          0
          0          0          0          0          0          0
          0          0          0          0          0          0]
is2 = [     28       3    2345    1597  192290 2337234  950000 2539703  250000
       0       0       0       0       0       0       0       0       0
       0       0       0       0       0       0       0       0       0
       0       0       0       0       0       0       0       0       0
       0       0       0       0       0       0       0       0       0
       0       0       0       0       0       0       0       0       0]
is4 = [ 998538      12 3744965       0       0       0       0       0       0
       0       0       0       0       0       0       0       0       0
       0       0       0       0       0       0       0       0       0
       0       0       0       0       0       0       0       0       0
       0       0       0       0       0       0       0       0       0
       0       0       0       0       0       0       0       0       0]
lead_time = 6
lower_left_latitude = 19.229
lower_left_longitude = 233.7234
map_proj = 3
number_of_values = 3744965
nx = 2345
ny = 1597
origin_longitude = 95.0
plain =
primary_missing_value = 0.0
reference_date = 2018120400
secondary_missing_value = 0.0
standard_latitude = 25.0
type = grid
</code></pre>
<p>You can also have <code><a title="pytdlpack.TdlpackFile.read" href="#pytdlpack.TdlpackFile.read">TdlpackFile.read()</a></code> read the entire file with optional keyword
<code>all = True</code>.
Reading all records at once is not recommened if the file is large in size.</p>
<pre><code class="language-python">&gt;&gt;&gt; x = f.read(all=True)
</code></pre>
<p>Here, x will become a list of instances of either <code><a title="pytdlpack.TdlpackStationRecord" href="#pytdlpack.TdlpackStationRecord">TdlpackStationRecord</a></code>,
<code><a title="pytdlpack.TdlpackRecord" href="#pytdlpack.TdlpackRecord">TdlpackRecord</a></code>, or <code><a title="pytdlpack.TdlpackTrailerRecord" href="#pytdlpack.TdlpackTrailerRecord">TdlpackTrailerRecord</a></code>.</p>
<p>If the file being read a TDLPACK random-access (<code>format='random-access'</code>), then you can also provide the <code>id=</code>
argument to search for a specific record.</p>
<pre><code class="language-python">&gt;&gt;&gt; import pytdlpack
&gt;&gt;&gt; f = pytdlpack.open('test.ra')
&gt;&gt;&gt; x = f.read(id=[400001000,0,0,0])
&gt;&gt;&gt; type(x)
&lt;class 'pytdlpack._pytdlpack.TdlpackStationRecord'&gt;
</code></pre>
<h2 id="3-writing-a-tdlpack-file"><div id='section3'>3) Writing a TDLPACK file.</h2>
<p>Writing to a TDLPACK file is as easy as reading.
The following uses variable x, from
above, is an instance of <code><a title="pytdlpack.TdlpackStationRecord" href="#pytdlpack.TdlpackStationRecord">TdlpackStationRecord</a></code> that has been packed.</p>
<p>Example: Write to a new TDLPACK sequential file.</p>
<pre><code class="language-python">&gt;&gt;&gt; import pytdlpack
&gt;&gt;&gt; f.open(&quot;new.sq&quot;,mode=&quot;w&quot;,format=&quot;sequential&quot;)
&gt;&gt;&gt; f.write(x)
&gt;&gt;&gt; f.close()
</code></pre>
<h2 id="4-creating-a-tdlpack-station-record"><div id='section4'>4) Creating a TDLPACK Station Record.</h2>
<p>The constructor for <code><a title="pytdlpack.TdlpackStationRecord" href="#pytdlpack.TdlpackStationRecord">TdlpackStationRecord</a></code> provides two methods of
instantiation via the traditional <strong>kwargs (see <code><a title="pytdlpack.TdlpackStationRecord" href="#pytdlpack.TdlpackStationRecord">TdlpackStationRecord</a></code>)
or simply providing <code>ccall = ...</code> </strong><em>(recommended)</em>**.
The value passed to the <code>ccall=</code> argument can
be a single call letter string, list, tuple, or comma-delimited string of station call letter records.</p>
<pre><code class="language-python">&gt;&gt;&gt; import pytdlpack
&gt;&gt;&gt; stations = pytdlpack.TdlpackStationRecord(['KBWI','KDCA','KIAD'])
&gt;&gt;&gt; stations
ccall = ['KBWI', 'KDCA', 'KIAD']
id = [400001000         0         0         0]
ioctet = 0
ipack = []
number_of_stations = 3
</code></pre>
<h2 id="5-creating-a-tdlpack-record"><div id='section5'>5) Creating a TDLPACK Record.</h2>
<p>The recommended method for creating a <code><a title="pytdlpack.TdlpackRecord" href="#pytdlpack.TdlpackRecord">TdlpackRecord</a></code> is to pass the TDLPACK
indentification arrays, plain language string, and data to the approproiate keyword.
Please
see <code><a title="pytdlpack.TdlpackRecord" href="#pytdlpack.TdlpackRecord">TdlpackRecord</a></code> for more info.</p>
<pre><code class="language-python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; record = pytdlpack.TdlpackRecord(date=2019070100,id=[4210008, 0, 24, 0],lead=24,
plain=&quot;GFS WIND SPEED&quot;,grid=grid_def,data=&lt;np.float32 array&gt;)
</code></pre>
<p>The user is encouraged to read the official MOS-2000 documentation (specifically Chapter 5)
on construction of these arrays and proper encoding.</p>
<h2 id="6-packingunpacking-a-tdlpack-record"><div id='section6'>6) Packing/Unpacking a TDLPACK Record.</h2>
<p>Once any of the three classes of TDLPACK records have been instantiated, you can pack the
record using the class method <code>pack</code>.
Using the example from <a href="#section5">Section 5</a>, <code>record</code>
is now an instance of <code><a title="pytdlpack.TdlpackRecord" href="#pytdlpack.TdlpackRecord">TdlpackRecord</a></code>.
You can pack this record with the following:</p>
<pre><code class="language-python">&gt;&gt;&gt; record.pack()
</code></pre>
<p>To unpack a packed TDLPACK record, perform:</p>
<pre><code class="language-python">&gt;&gt;&gt; record.unpack()
</code></pre>
<p>The <code><a title="pytdlpack.TdlpackRecord.unpack" href="#pytdlpack.TdlpackRecord.unpack">TdlpackRecord.unpack()</a></code> class method for TDLPACK data records, contains optional
arguments <code>data=</code> (to control the unpacking of data) and <code>missing_value=</code> (to set a different
missing value other than what is contained in the record).
For TDLPACK data records,
<code><a title="pytdlpack.TdlpackRecord.unpack" href="#pytdlpack.TdlpackRecord.unpack">TdlpackRecord.unpack()</a></code> automatically unpacks the TDLPACK meta-data.</p>
<pre><code class="language-python">&gt;&gt;&gt; record.unpack(data=True,missing_value=-9999.0)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># init for pytdlpack package
from ._pytdlpack import *
from ._pytdlpack import __doc__,__pdoc__

from ._grid_definitions import grids

from .version import version as __version__

__all__ = [&#39;__version__&#39;,&#39;TdlpackFile&#39;,&#39;TdlpackRecord&#39;,&#39;TdlpackStationRecord&#39;,&#39;TdlpackTrailerRecord&#39;,
           &#39;open&#39;,&#39;create_grid_definition&#39;,&#39;grids&#39;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pytdlpack.version" href="version.html">pytdlpack.version</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pytdlpack.create_grid_definition"><code class="name flex">
<span>def <span class="ident">create_grid_definition</span></span>(<span>name=None, proj=None, nx=None, ny=None, latll=None, lonll=None, orientlon=None, stdlat=None, meshlength=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a dictionary of grid specs.
The user has the option to
populate the dictionary via the args or create an empty dict. </p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>name : str, optional</code></strong></p>
<p>String that identifies a predefined grid.</p>
<p><strong><code>proj : int, optional</code></strong></p>
<p>Map projection of the grid (3 = Lambert Conformal; 5 = Polar Stereographic;
7 = Mercator). NOTE: This parameter is optional if data are station-based.</p>
<p><strong><code>nx : int, optional</code></strong></p>
<p>Number of points in X-direction (East-West). NOTE: This parameter is optional if
data are station-based. </p>
<p><strong><code>ny : int, optional</code></strong></p>
<p>Number of points in Y-direction (North-South). NOTE: This parameter is optional if
data are station-based.</p>
<p><strong><code>latll : float, optional</code></strong></p>
<p>Latitude in decimal degrees of lower-left grid point.
NOTE: This parameter is optional if
data are station-based.</p>
<p><strong><code>lonll : float, optional</code></strong></p>
<p>Longitude in decimal degrees of lower-left grid point.
NOTE: This parameter is optional if
data are station-based. </p>
<p><strong><code>orientlon : float, optional</code></strong></p>
<p>Longitude in decimal degrees of the central meridian.
NOTE: This parameter is optional if
data are station-based.</p>
<p><strong><code>stdlat : float, optional</code></strong></p>
<p>Latitude in decimal degrees of the standard latitude.
NOTE: This parameter is optional if
data are station-based.</p>
<p><strong><code>meshlength : float, optional</code></strong></p>
<p>Distance in meters between grid points.
NOTE: This parameter is optional if
data are station-based.</p>
<h2 id="returns">Returns</h2>
<p><strong><code>griddict : dict</code></strong></p>
<p>Dictionary whose keys are the named parameters of this function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_grid_definition(name=None,proj=None,nx=None,ny=None,latll=None,lonll=None,
                           orientlon=None,stdlat=None,meshlength=None):
    &#34;&#34;&#34;
    Create a dictionary of grid specs.  The user has the option to 
    populate the dictionary via the args or create an empty dict. 

    Parameters
    ----------

    **`name : str, optional`**

    String that identifies a predefined grid.

    **`proj : int, optional`**

    Map projection of the grid (3 = Lambert Conformal; 5 = Polar Stereographic; 
    7 = Mercator). NOTE: This parameter is optional if data are station-based.

    **`nx : int, optional`**

    Number of points in X-direction (East-West). NOTE: This parameter is optional if
    data are station-based. 

    **`ny : int, optional`**

    Number of points in Y-direction (North-South). NOTE: This parameter is optional if
    data are station-based.

    **`latll : float, optional`**

    Latitude in decimal degrees of lower-left grid point.  NOTE: This parameter is optional if
    data are station-based.

    **`lonll : float, optional`**

    Longitude in decimal degrees of lower-left grid point.  NOTE: This parameter is optional if
    data are station-based. 

    **`orientlon : float, optional`**

    Longitude in decimal degrees of the central meridian.  NOTE: This parameter is optional if
    data are station-based.

    **`stdlat : float, optional`**

    Latitude in decimal degrees of the standard latitude.  NOTE: This parameter is optional if
    data are station-based.

    **`meshlength : float, optional`**

    Distance in meters between grid points.  NOTE: This parameter is optional if
    data are station-based.

    Returns
    -------

    **`griddict : dict`**

    Dictionary whose keys are the named parameters of this function.
    &#34;&#34;&#34;
    griddict = {}
    if name is not None:
        from ._grid_definitions import grids
        griddict = grids[name]
    else:
        griddict[&#39;proj&#39;] = proj
        griddict[&#39;nx&#39;] = nx
        griddict[&#39;ny&#39;] = ny
        griddict[&#39;latll&#39;] = latll
        griddict[&#39;lonll&#39;] = lonll
        griddict[&#39;orientlon&#39;] = orientlon
        griddict[&#39;stdlat&#39;] = stdlat
        griddict[&#39;meshlength&#39;] = meshlength
    return griddict</code></pre>
</details>
</dd>
<dt id="pytdlpack.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>name, mode='r', format=None, ra_template=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a TDLPACK File for reading/writing.</p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>name : str</code></strong></p>
<p>TDLPACK file name.
This string is expanded into an absolute path via os.path.abspath().</p>
<p><strong><code>mode : {'r', 'w', 'a', 'x'}, optional</code></strong></p>
<p>Access mode. <code>'r'</code> means read only; <code>'w'</code> means write (existing file is overwritten);
<code>'a'</code> means to append to the existing file; <code>'x'</code> means to write to a new file (if
the file exists, an error is raised).</p>
<p><strong><code>format : {'sequential', 'random-access'}, optional</code></strong></p>
<p>Type of TDLPACK File when creating a new file.
This parameter is ignored if the
file access mode is <code>'r'</code> or <code>'a'</code>.</p>
<p><strong><code>ra_template : {'small', 'large'}, optional</code></strong></p>
<p>Template used to create new random-access file. The default is 'small'.
This parameter
is ignored if the file access mode is <code>'r'</code> or <code>'a'</code> or if the file format is <code>'sequential'</code>.</p>
<h2 id="returns">Returns</h2>
<p><strong><code><a title="pytdlpack.TdlpackFile" href="#pytdlpack.TdlpackFile">TdlpackFile</a></code></strong></p>
<p>Instance of class TdlpackFile.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(name, mode=&#39;r&#39;, format=None, ra_template=None):
    &#34;&#34;&#34;
    Opens a TDLPACK File for reading/writing.

    Parameters
    ----------
    **`name : str`**

    TDLPACK file name.  This string is expanded into an absolute path via os.path.abspath().

    **`mode : {&#39;r&#39;, &#39;w&#39;, &#39;a&#39;, &#39;x&#39;}, optional`**

    Access mode. `&#39;r&#39;` means read only; `&#39;w&#39;` means write (existing file is overwritten);
    `&#39;a&#39;` means to append to the existing file; `&#39;x&#39;` means to write to a new file (if
    the file exists, an error is raised).

    **`format : {&#39;sequential&#39;, &#39;random-access&#39;}, optional`**

    Type of TDLPACK File when creating a new file.  This parameter is ignored if the
    file access mode is `&#39;r&#39;` or `&#39;a&#39;`.

    **`ra_template : {&#39;small&#39;, &#39;large&#39;}, optional`**

    Template used to create new random-access file. The default is &#39;small&#39;.  This parameter
    is ignored if the file access mode is `&#39;r&#39;` or `&#39;a&#39;` or if the file format is `&#39;sequential&#39;`.
    
    Returns
    -------
    **`pytdlpack.TdlpackFile`**

    Instance of class TdlpackFile.
    &#34;&#34;&#34;
    _byteorder = np.int32(0)
    _filetype = np.int32(0)
    _lun = np.int32(0)
    _ier = np.int32(0)
    name = os.path.abspath(name)

    if format is None: format = &#39;sequential&#39;
    if mode == &#39;w&#39; or mode == &#39;x&#39;:

        if format == &#39;random-access&#39;:
            if not ra_template: ra_template = &#39;small&#39;
            if ra_template == &#39;small&#39;:
                _maxent = np.int32(300)
                _nbytes = np.int32(2000)
            elif ra_template == &#39;large&#39;:
                _maxent = np.int32(840)
                _nbytes = np.int32(20000)
            _filetype = np.int32(1)
            _lun,_byteorder,_filetype,_ier = tdlpack.openfile(FORTRAN_STDOUT_LUN,name,mode,L3264B,_byteorder,_filetype,
                                             ra_maxent=_maxent,ra_nbytes=_nbytes)
        elif format == &#39;sequential&#39;:
            _filetype = np.int32(2)
            _lun,_byteorder,_filetype,_ier = tdlpack.openfile(FORTRAN_STDOUT_LUN,name,mode,L3264B,_byteorder,_filetype)

    elif mode == &#39;r&#39; or mode == &#39;a&#39;:
        if os.path.isfile(name):
            _lun,_byteorder,_filetype,_ier = tdlpack.openfile(FORTRAN_STDOUT_LUN,name,mode,L3264B,_byteorder,_filetype)
        else:
            raise IOError(&#34;File not found.&#34;)

    if _ier == 0:
        kwargs = {}
        if _byteorder == -1:
            kwargs[&#39;byte_order&#39;] = &#39;&lt;&#39;
        elif _byteorder == 1:
            kwargs[&#39;byte_order&#39;] = &#39;&gt;&#39;
        if _filetype == 1:
            kwargs[&#39;format&#39;] = &#39;random-access&#39;
            kwargs[&#39;ra_master_key&#39;] = _read_ra_master_key(name)
        elif _filetype == 2:
            kwargs[&#39;format&#39;] = &#39;sequential&#39;
        kwargs[&#39;fortran_lun&#39;] = deepcopy(_lun)
        kwargs[&#39;mode&#39;] = mode
        kwargs[&#39;name&#39;] = name
        kwargs[&#39;position&#39;] = np.int32(0)
        if mode == &#39;r&#39; or mode == &#39;a&#39;: kwargs[&#39;size&#39;] = os.path.getsize(name)
    else:
        raise IOError(&#34;Could not open TDLPACK file&#34;+name+&#34;. Error return from tdlpack.openfile = &#34;+str(_ier))

    _starecdict[_lun] = []

    return TdlpackFile(**kwargs)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pytdlpack.TdlpackFile"><code class="flex name class">
<span>class <span class="ident">TdlpackFile</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>TDLPACK File with associated information.</p>
<h2 id="attributes">Attributes</h2>
<p><strong><code>byte_order : str</code></strong></p>
<p>Byte order of TDLPACK file using definitions as defined by Python built-in struct module.</p>
<p><strong><code>data_type : {'grid', 'station'}</code></strong></p>
<p>Type of data contained in the file.</p>
<p><strong><code>eof : bool</code></strong></p>
<p>True if we have reached end of file.</p>
<p><strong><code>format : {'random-access', 'sequential'}</code></strong></p>
<p>File format of TDLPACK file.</p>
<p><strong><code>fortran_lun : np.int32</code></strong></p>
<p>Fortran unit number for file access. If the file is not open, then this value is -1. </p>
<p><strong><code>mode : str</code></strong></p>
<p>Access mode (see pytdlpack.open() docstring).</p>
<p><strong><code>name : str</code></strong></p>
<p>File name.</p>
<p><strong><code>position : int</code></strong></p>
<p>The current record being read from file. If the file type is 'random-access', then this
value is -1.</p>
<p><strong><code>size : int</code></strong></p>
<p>File size in units of bytes.</p>
<dl>
<dt><strong><code>Contructor</code></strong></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TdlpackFile(object):
    &#34;&#34;&#34;
    TDLPACK File with associated information.

    Attributes
    ----------

    **`byte_order : str`**

    Byte order of TDLPACK file using definitions as defined by Python built-in struct module.

    **`data_type : {&#39;grid&#39;, &#39;station&#39;}`**

    Type of data contained in the file.

    **`eof : bool`**

    True if we have reached end of file.

    **`format : {&#39;random-access&#39;, &#39;sequential&#39;}`**

    File format of TDLPACK file.

    **`fortran_lun : np.int32`**

    Fortran unit number for file access. If the file is not open, then this value is -1. 

    **`mode : str`**

    Access mode (see pytdlpack.open() docstring).

    **`name : str`**

    File name.

    **`position : int`**

    The current record being read from file. If the file type is &#39;random-access&#39;, then this
    value is -1.

    **`size : int`**

    File size in units of bytes.
    &#34;&#34;&#34;
    counter = 0
    def __init__(self,**kwargs):
        &#34;&#34;&#34;Contructor&#34;&#34;&#34;
        type(self).counter += 1
        self.byte_order = &#39;&#39;
        self.data_type = &#39;&#39;
        self.eof = False
        self.format = &#39;&#39;
        self.fortran_lun = np.int32(-1)
        self.mode = &#39;&#39;
        self.name = &#39;&#39;
        self.position = np.int32(0)
        self.ra_master_key = None
        for k, v in kwargs.items():
            setattr(self,k,v)

    def __repr__(self):
        strings = []
        keys = self.__dict__.keys()
        for k in keys:
            if not k.startswith(&#39;_&#39;):
                strings.append(&#39;%s = %s\n&#39;%(k,self.__dict__[k]))
        return &#39;&#39;.join(strings)

    def __enter__(self):
        &#34;&#34;&#34;no additional setup as opening with context manager is not required&#34;&#34;&#34;
        return self

    def __exit__(self,type,value,traceback):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        self.close()

    def __iter__(self):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        return self

    def __next__(self):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        if not self.eof:
            rec = self.read()
            if self.eof and isinstance(rec,type(None)):
                raise StopIteration
            else:
                return rec
        else:
            raise StopIteration

    def _determine_record_type(self,ipack,ioctet):
        kwargs = {}
        if ipack[0] == 0 and ipack[4] == 9999 and ioctet == 24:
            kwargs[&#39;ipack&#39;] = deepcopy(ipack)
            kwargs[&#39;ioctet&#39;] = deepcopy(ioctet)
            kwargs[&#39;id&#39;] = np.int32([0,0,0,0])
            return TdlpackTrailerRecord(**kwargs)
        if ipack[0] &gt; 0:
            kwargs[&#39;ipack&#39;] = deepcopy(ipack)
            kwargs[&#39;ioctet&#39;] = deepcopy(ioctet)
            header = struct.unpack(&#39;&gt;4s&#39;,ipack[0].byteswap())[0]
            if _IS_PYTHON3:
                header = header.decode()
            if header in [&#34;PLDT&#34;,&#34;TDLP&#34;] :
                if not self.data_type: self.data_type = &#39;grid&#39;
                kwargs[&#39;id&#39;] = deepcopy(ipack[5:9])
                kwargs[&#39;reference_date&#39;] = deepcopy(ipack[4])
                kwargs[&#39;lead_time&#39;] = np.int32(str(ipack[7])[-3:])
                kwargs[&#39;_filelun&#39;] = self.fortran_lun
                kwargs[&#39;_starecindex&#39;] = len(_starecdict[self.fortran_lun])-1 if len(_starecdict[self.fortran_lun]) &gt; 0 else 0
                return TdlpackRecord(**kwargs)
            else:
                if not self.data_type: self.data_type = &#39;station&#39;
                kwargs[&#39;id&#39;] = np.int32([400001000,0,0,0])
                kwargs[&#39;number_of_stations&#39;] = np.int32(deepcopy(ioctet/NCHAR))
                return TdlpackStationRecord(**kwargs)
        else:
            #raise
            pass #for now

    def backspace(self):
        &#34;&#34;&#34;
        Position file backwards by one record.
        &#34;&#34;&#34;
        if self.fortran_lun == -1:
            raise IOError(&#34;File is not opened.&#34;)

        if self.format == &#39;sequential&#39;:
            _ier = np.int32(0)
            _ier = tdlpack.backspacefile(self.fortran_lun)
            if _ier == 0:
                self.position -= 1
            else:
                raise IOError(&#34;Could not backspace file. ier = &#34;+str(_ier))

    def close(self):
        &#34;&#34;&#34;
        Close a TDLPACK file.
        &#34;&#34;&#34;
        _ier = np.int32(0)
        if self.format == &#39;random-access&#39;:
            _ier = tdlpack.clfilm(FORTRAN_STDOUT_LUN,self.fortran_lun)
        elif self.format == &#39;sequential&#39;:
            _ier = tdlpack.closefile(FORTRAN_STDOUT_LUN,self.fortran_lun,np.int32(2))
        if _ier == 0:
            try:
                del _starecdict[self.fortran_lun]
            except(KeyError):
                pass
            self.eof = False
            self.fortran_lun = -1
            self.position = 0
            type(self).counter -= 1
        else:
            raise IOError(&#34;Trouble closing file. ier = &#34;+str(_ier))

    def read(self,all=False,unpack=True,id=[9999,0,0,0]):
        &#34;&#34;&#34;
        Read a record from a TDLPACK file.

        Parameters
        ----------

        **`all : bool, optional`**

        Read all records from file. The default is False.

        **`unpack : bool, optional`**

        Unpack TDLPACK identification sections.  Note that data are not unpacked.  The default is True.
            
        **`id : array_like or list, optional`**

        Provide an ID to search for. This can be either a Numpy.int32 array with shape (4,) or list 
        with length 4.  The default is [9999,0,0,0] which will signal the random access IO reader
        to sequentially read the file.
        
        Returns
        -------

        **`record [records] : instance [list]`**

        An instance of list of instances contaning `pytdlpack.TdlpackStationRecord`, 
        `pytdlpack.TdlpackRecord`, or `pytdlpack.TdlpackTrailerRecord`
        &#34;&#34;&#34;
        if self.fortran_lun == -1:
            raise IOError(&#34;File is not opened.&#34;)

        record = None
        records = []
        while True:
            _ipack = np.array((),dtype=np.int32)
            _ioctet = np.int32(0)
            _ier = np.int32(0)
            if self.format == &#39;random-access&#39;:
                id = np.int32(id)
                _nvalue = np.int32(0)
                _ipack,_nvalue,_ier = tdlpack.rdtdlm(FORTRAN_STDOUT_LUN,self.fortran_lun,self.name,id,ND5,L3264B)
                if _ier == 0:
                    _ioctet = _nvalue*NBYPWD
                    record = self._determine_record_type(_ipack,_ioctet)
                elif _ier == 153:
                    self.eof = True
                    break
                else:
                    #raise
                    pass # for now
            elif self.format == &#39;sequential&#39;:
                _ioctet,_ipack,_ier = tdlpack.readfile(FORTRAN_STDOUT_LUN,self.name,self.fortran_lun,ND5,L3264B,np.int32(2))
                if _ier == 0:
                    record = self._determine_record_type(_ipack,_ioctet)
                    self.position += 1
                elif _ier == -1:
                    self.eof = True
                    break

            if unpack: record.unpack()

            if type(record) is TdlpackStationRecord:
                _starecdict[self.fortran_lun].append(record.stations)

            if all:
                records.append(record)
            else:
                break

        if len(records) &gt; 0:
            return records
        else:
            return record
    
    def rewind(self):
        &#34;&#34;&#34;
        Position file to the beginning.
        &#34;&#34;&#34;
        if self.fortran_lun == -1:
            raise IOError(&#34;File is not opened.&#34;)

        if self.format == &#39;sequential&#39;:
            _ier = np.int32(0)
            _ier = tdlpack.rewindfile(self.fortran_lun)
            if _ier == 0:
                self.position = 0
            else:
                raise IOError(&#34;Could not rewind file. ier = &#34;+str(_ier))

    def write(self,record):
        &#34;&#34;&#34;
        Write a packed TDLPACK record to file.

        Parameters
        ----------

        **`record : instance`**

        An instance of either `pytdlpack.TdlpackStationRecord`, `pytdlpack.TdlpackRecord`, 
        or `pytdlpack.TdlpackTrailerRecord`.  `record` should contain a packed data.
        &#34;&#34;&#34;
        #pdb.set_trace()
        if self.fortran_lun == -1:
            raise IOError(&#34;File is not opened.&#34;)
        if self.mode == &#34;r&#34;:
            raise IOError(&#34;File is read-only.&#34;)

        _ier = np.int32(0)
        _ntotby = np.int32(0)
        _ntotrc = np.int32(0)
        _nreplace = np.int32(0)
        _ncheck = np.int32(0)

        if type(record) is TdlpackStationRecord:
            if self.position == 0: self.data_type = &#39;station&#39;
            _nwords = record.number_of_stations*2
            if self.format == &#39;random-access&#39;:
                _ier = tdlpack.wrtdlm(FORTRAN_STDOUT_LUN,self.fortran_lun,self.name,
                                       record.id,record.ipack[0:_nwords],_nreplace,
                                       _ncheck,L3264B)
            elif self.format == &#39;sequential&#39;:
                _ntotby,_ntotrc,_ier = tdlpack.writep(FORTRAN_STDOUT_LUN,self.fortran_lun,
                                       record.ipack[0:_nwords],_ntotby,_ntotrc,L3264B)
        elif type(record) is TdlpackRecord:
            if self.position == 0: self.data_type = &#39;grid&#39;
            _nwords = np.int32(record.ioctet/NBYPWD)
            if self.format == &#39;random-access&#39;:
                record.ipack[0] = record.ipack[0].byteswap()
                _ier = tdlpack.wrtdlm(FORTRAN_STDOUT_LUN,self.fortran_lun,self.name,
                                       record.id,record.ipack[0:_nwords],_nreplace,
                                       _ncheck,L3264B)
            elif self.format == &#39;sequential&#39;:
                _ntotby,_ntotrc,_ier = tdlpack.writep(FORTRAN_STDOUT_LUN,self.fortran_lun,
                                       record.ipack[0:_nwords],_ntotby,_ntotrc,L3264B)
        elif type(record) is TdlpackTrailerRecord:
            _ier = tdlpack.trail(FORTRAN_STDOUT_LUN,self.fortran_lun,L3264B,L3264W,_ntotby,
                           _ntotrc)
        if _ier == 0:
            self.position += 1
            self.size = os.path.getsize(self.name)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pytdlpack.TdlpackFile.counter"><code class="name">var <span class="ident">counter</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pytdlpack.TdlpackFile.backspace"><code class="name flex">
<span>def <span class="ident">backspace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Position file backwards by one record.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backspace(self):
    &#34;&#34;&#34;
    Position file backwards by one record.
    &#34;&#34;&#34;
    if self.fortran_lun == -1:
        raise IOError(&#34;File is not opened.&#34;)

    if self.format == &#39;sequential&#39;:
        _ier = np.int32(0)
        _ier = tdlpack.backspacefile(self.fortran_lun)
        if _ier == 0:
            self.position -= 1
        else:
            raise IOError(&#34;Could not backspace file. ier = &#34;+str(_ier))</code></pre>
</details>
</dd>
<dt id="pytdlpack.TdlpackFile.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close a TDLPACK file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    Close a TDLPACK file.
    &#34;&#34;&#34;
    _ier = np.int32(0)
    if self.format == &#39;random-access&#39;:
        _ier = tdlpack.clfilm(FORTRAN_STDOUT_LUN,self.fortran_lun)
    elif self.format == &#39;sequential&#39;:
        _ier = tdlpack.closefile(FORTRAN_STDOUT_LUN,self.fortran_lun,np.int32(2))
    if _ier == 0:
        try:
            del _starecdict[self.fortran_lun]
        except(KeyError):
            pass
        self.eof = False
        self.fortran_lun = -1
        self.position = 0
        type(self).counter -= 1
    else:
        raise IOError(&#34;Trouble closing file. ier = &#34;+str(_ier))</code></pre>
</details>
</dd>
<dt id="pytdlpack.TdlpackFile.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, all=False, unpack=True, id=[9999, 0, 0, 0])</span>
</code></dt>
<dd>
<div class="desc"><p>Read a record from a TDLPACK file.</p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>all : bool, optional</code></strong></p>
<p>Read all records from file. The default is False.</p>
<p><strong><code>unpack : bool, optional</code></strong></p>
<p>Unpack TDLPACK identification sections.
Note that data are not unpacked.
The default is True.</p>
<p><strong><code>id : array_like or list, optional</code></strong></p>
<p>Provide an ID to search for. This can be either a Numpy.int32 array with shape (4,) or list
with length 4.
The default is [9999,0,0,0] which will signal the random access IO reader
to sequentially read the file.</p>
<h2 id="returns">Returns</h2>
<p><strong><code>record [records] : instance [list]</code></strong></p>
<p>An instance of list of instances contaning <code><a title="pytdlpack.TdlpackStationRecord" href="#pytdlpack.TdlpackStationRecord">TdlpackStationRecord</a></code>,
<code><a title="pytdlpack.TdlpackRecord" href="#pytdlpack.TdlpackRecord">TdlpackRecord</a></code>, or <code><a title="pytdlpack.TdlpackTrailerRecord" href="#pytdlpack.TdlpackTrailerRecord">TdlpackTrailerRecord</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self,all=False,unpack=True,id=[9999,0,0,0]):
    &#34;&#34;&#34;
    Read a record from a TDLPACK file.

    Parameters
    ----------

    **`all : bool, optional`**

    Read all records from file. The default is False.

    **`unpack : bool, optional`**

    Unpack TDLPACK identification sections.  Note that data are not unpacked.  The default is True.
        
    **`id : array_like or list, optional`**

    Provide an ID to search for. This can be either a Numpy.int32 array with shape (4,) or list 
    with length 4.  The default is [9999,0,0,0] which will signal the random access IO reader
    to sequentially read the file.
    
    Returns
    -------

    **`record [records] : instance [list]`**

    An instance of list of instances contaning `pytdlpack.TdlpackStationRecord`, 
    `pytdlpack.TdlpackRecord`, or `pytdlpack.TdlpackTrailerRecord`
    &#34;&#34;&#34;
    if self.fortran_lun == -1:
        raise IOError(&#34;File is not opened.&#34;)

    record = None
    records = []
    while True:
        _ipack = np.array((),dtype=np.int32)
        _ioctet = np.int32(0)
        _ier = np.int32(0)
        if self.format == &#39;random-access&#39;:
            id = np.int32(id)
            _nvalue = np.int32(0)
            _ipack,_nvalue,_ier = tdlpack.rdtdlm(FORTRAN_STDOUT_LUN,self.fortran_lun,self.name,id,ND5,L3264B)
            if _ier == 0:
                _ioctet = _nvalue*NBYPWD
                record = self._determine_record_type(_ipack,_ioctet)
            elif _ier == 153:
                self.eof = True
                break
            else:
                #raise
                pass # for now
        elif self.format == &#39;sequential&#39;:
            _ioctet,_ipack,_ier = tdlpack.readfile(FORTRAN_STDOUT_LUN,self.name,self.fortran_lun,ND5,L3264B,np.int32(2))
            if _ier == 0:
                record = self._determine_record_type(_ipack,_ioctet)
                self.position += 1
            elif _ier == -1:
                self.eof = True
                break

        if unpack: record.unpack()

        if type(record) is TdlpackStationRecord:
            _starecdict[self.fortran_lun].append(record.stations)

        if all:
            records.append(record)
        else:
            break

    if len(records) &gt; 0:
        return records
    else:
        return record</code></pre>
</details>
</dd>
<dt id="pytdlpack.TdlpackFile.rewind"><code class="name flex">
<span>def <span class="ident">rewind</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Position file to the beginning.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rewind(self):
    &#34;&#34;&#34;
    Position file to the beginning.
    &#34;&#34;&#34;
    if self.fortran_lun == -1:
        raise IOError(&#34;File is not opened.&#34;)

    if self.format == &#39;sequential&#39;:
        _ier = np.int32(0)
        _ier = tdlpack.rewindfile(self.fortran_lun)
        if _ier == 0:
            self.position = 0
        else:
            raise IOError(&#34;Could not rewind file. ier = &#34;+str(_ier))</code></pre>
</details>
</dd>
<dt id="pytdlpack.TdlpackFile.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a packed TDLPACK record to file.</p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>record : instance</code></strong></p>
<p>An instance of either <code><a title="pytdlpack.TdlpackStationRecord" href="#pytdlpack.TdlpackStationRecord">TdlpackStationRecord</a></code>, <code><a title="pytdlpack.TdlpackRecord" href="#pytdlpack.TdlpackRecord">TdlpackRecord</a></code>,
or <code><a title="pytdlpack.TdlpackTrailerRecord" href="#pytdlpack.TdlpackTrailerRecord">TdlpackTrailerRecord</a></code>.
<code>record</code> should contain a packed data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self,record):
    &#34;&#34;&#34;
    Write a packed TDLPACK record to file.

    Parameters
    ----------

    **`record : instance`**

    An instance of either `pytdlpack.TdlpackStationRecord`, `pytdlpack.TdlpackRecord`, 
    or `pytdlpack.TdlpackTrailerRecord`.  `record` should contain a packed data.
    &#34;&#34;&#34;
    #pdb.set_trace()
    if self.fortran_lun == -1:
        raise IOError(&#34;File is not opened.&#34;)
    if self.mode == &#34;r&#34;:
        raise IOError(&#34;File is read-only.&#34;)

    _ier = np.int32(0)
    _ntotby = np.int32(0)
    _ntotrc = np.int32(0)
    _nreplace = np.int32(0)
    _ncheck = np.int32(0)

    if type(record) is TdlpackStationRecord:
        if self.position == 0: self.data_type = &#39;station&#39;
        _nwords = record.number_of_stations*2
        if self.format == &#39;random-access&#39;:
            _ier = tdlpack.wrtdlm(FORTRAN_STDOUT_LUN,self.fortran_lun,self.name,
                                   record.id,record.ipack[0:_nwords],_nreplace,
                                   _ncheck,L3264B)
        elif self.format == &#39;sequential&#39;:
            _ntotby,_ntotrc,_ier = tdlpack.writep(FORTRAN_STDOUT_LUN,self.fortran_lun,
                                   record.ipack[0:_nwords],_ntotby,_ntotrc,L3264B)
    elif type(record) is TdlpackRecord:
        if self.position == 0: self.data_type = &#39;grid&#39;
        _nwords = np.int32(record.ioctet/NBYPWD)
        if self.format == &#39;random-access&#39;:
            record.ipack[0] = record.ipack[0].byteswap()
            _ier = tdlpack.wrtdlm(FORTRAN_STDOUT_LUN,self.fortran_lun,self.name,
                                   record.id,record.ipack[0:_nwords],_nreplace,
                                   _ncheck,L3264B)
        elif self.format == &#39;sequential&#39;:
            _ntotby,_ntotrc,_ier = tdlpack.writep(FORTRAN_STDOUT_LUN,self.fortran_lun,
                                   record.ipack[0:_nwords],_ntotby,_ntotrc,L3264B)
    elif type(record) is TdlpackTrailerRecord:
        _ier = tdlpack.trail(FORTRAN_STDOUT_LUN,self.fortran_lun,L3264B,L3264W,_ntotby,
                       _ntotrc)
    if _ier == 0:
        self.position += 1
        self.size = os.path.getsize(self.name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pytdlpack.TdlpackRecord"><code class="flex name class">
<span>class <span class="ident">TdlpackRecord</span></span>
<span>(</span><span>date=None, id=None, lead=None, plain=None, grid=None, data=None, missing_value=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a TDLPACK data record object.
Once data are unpacked (TdlpackRecord.unpack(data=True)),
values are accessible using "fancy indexing".</p>
<p>For gridded records, use grid index values and/or ranges (e.g. rec[0,0]).</p>
<p>For station records, use the station ID string: (e.g. rec['KPHL']).</p>
<h2 id="attributes">Attributes</h2>
<p><strong><code>data : array_like</code></strong></p>
<p>Data values.</p>
<p><strong><code>grid_length : float</code></strong></p>
<p>Distance between grid points in units of meters.</p>
<p><strong><code>id : array_like</code></strong></p>
<p>ID of the TDLPACK data record. This is a NumPy 1D array of dtype=np.int32.</p>
<p><strong><code>ioctet : int</code></strong></p>
<p>Size of the packed TDLPACK data record in bytes.</p>
<p><strong><code>ipack : array_like</code></strong></p>
<p>Packed TDLPACK data record. This is a NumPy 1D array of dtype=np.int32.</p>
<p><strong><code>is0 : array_like</code></strong></p>
<p>TDLPACK Section 0 (Indicator Section).</p>
<p><strong><code>is1 : array_like</code></strong></p>
<p>TDLPACK Section 1 (Product Definition Section).</p>
<p><strong><code>is2 : array_like</code></strong></p>
<p>TDLPACK Section 2 (Grid Definition Section)</p>
<p><strong><code>is4 : array_like</code></strong></p>
<p>TDLPACK Section 4 (Data Section).</p>
<p><strong><code>lead_time : int</code></strong></p>
<p>Forecast lead time in units of hours.</p>
<p><strong><code>lower_left_latitude : float</code></strong></p>
<p>Latitude of lower left grid point</p>
<p><strong><code>lower_left_longitude : float</code></strong></p>
<p>Longitude of lower left grid point</p>
<p><strong><code>number_of_values : int</code></strong></p>
<p>Number of data values.</p>
<p><strong><code>nx : int</code></strong></p>
<p>Number of points in the x-direction (West-East).</p>
<p><strong><code>ny : int</code></strong></p>
<p>Number of points in the y-direction (West-East).</p>
<p><strong><code>origin_longitude : float</code></strong></p>
<p>Originating longitude of projected grid.</p>
<p><strong><code>plain : str</code></strong></p>
<p>Plain language description of TDLPACK record.</p>
<p><strong><code>primary_missing_value : float</code></strong></p>
<p>Primary missing value.</p>
<p><strong><code>reference_date : int</code></strong></p>
<p>Reference date from the TDLPACK data record in YYYYMMDDHH format.</p>
<p><strong><code>secondary_missing_value : float</code></strong></p>
<p>Secondary missing value.</p>
<p><strong><code>standard_latitude : float</code></strong></p>
<p>Latitude at which the grid length applies.</p>
<p><strong><code>type : {'grid', 'station'}</code></strong></p>
<p>Identifies the type of data.
This implies that data are 1D for type = 'station'
and data are 2D for type = 'grid'.</p>
<dl>
<dt><strong><code>Constructor</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<p><strong><code>date : int, optional</code></strong></p>
<p>Forecast initialization or observation date in YYYYMMDDHH format.</p>
<p><strong><code>id : list or 1-D array, optional</code></strong></p>
<p>List or 1-D array of length 4 containing the 4-word (integer) MOS-2000 ID of the data
to be put into TdlpackRecord</p>
<p><strong><code>lead : int, optional</code></strong></p>
<p>Lead time (i.e. forecast projection) in hours of the data.
NOTE: This can be omitted</p>
<p><strong><code>plain : str, optional</code></strong></p>
<p>Plain language descriptor.
This is limited to 32 characters, though here
the input can be longer (will be cut off when packing).</p>
<p><strong><code>grid : dict , optional</code></strong></p>
<p>A dictionary containing grid definition attributes.
See
Dictionary of grid specs (created from create_grid_def_dict)</p>
<p><strong><code>data : array_like, optional</code></strong></p>
<p>Data values.</p>
<p><strong><code>missing_value : float or list of floats, optional</code></strong></p>
<p>Provide either a primary missing value or primary and secondary as list.</p>
<p><strong><code>**kwargs : dict, optional</code></strong></p>
<p>Dictionary of class attributes (keys) and class attributes (values).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TdlpackRecord(object):
    &#34;&#34;&#34;
    Defines a TDLPACK data record object.  Once data are unpacked (TdlpackRecord.unpack(data=True)),
    values are accessible using &#34;fancy indexing&#34;.

    For gridded records, use grid index values and/or ranges (e.g. rec[0,0]).
    
    For station records, use the station ID string: (e.g. rec[&#39;KPHL&#39;]).

    Attributes
    ----------

    **`data : array_like`**

    Data values.

    **`grid_length : float`**

    Distance between grid points in units of meters.

    **`id : array_like`**

    ID of the TDLPACK data record. This is a NumPy 1D array of dtype=np.int32.

    **`ioctet : int`**

    Size of the packed TDLPACK data record in bytes.

    **`ipack : array_like`**

    Packed TDLPACK data record. This is a NumPy 1D array of dtype=np.int32.

    **`is0 : array_like`**

    TDLPACK Section 0 (Indicator Section).

    **`is1 : array_like`**

    TDLPACK Section 1 (Product Definition Section).

    **`is2 : array_like`**

    TDLPACK Section 2 (Grid Definition Section)

    **`is4 : array_like`**

    TDLPACK Section 4 (Data Section).

    **`lead_time : int`**

    Forecast lead time in units of hours.

    **`lower_left_latitude : float`**

    Latitude of lower left grid point

    **`lower_left_longitude : float`**

    Longitude of lower left grid point

    **`number_of_values : int`**

    Number of data values.

    **`nx : int`**

    Number of points in the x-direction (West-East).

    **`ny : int`**

    Number of points in the y-direction (West-East).

    **`origin_longitude : float`**

    Originating longitude of projected grid.

    **`plain : str`**

    Plain language description of TDLPACK record.

    **`primary_missing_value : float`**

    Primary missing value.

    **`reference_date : int`**

    Reference date from the TDLPACK data record in YYYYMMDDHH format.

    **`secondary_missing_value : float`**

    Secondary missing value.

    **`standard_latitude : float`**

    Latitude at which the grid length applies.

    **`type : {&#39;grid&#39;, &#39;station&#39;}`**

    Identifies the type of data.  This implies that data are 1D for type = &#39;station&#39;
    and data are 2D for type = &#39;grid&#39;.

    &#34;&#34;&#34;
    counter = 0
    def __init__(self,date=None,id=None,lead=None,plain=None,grid=None,data=None,
                 missing_value=None,**kwargs):
        &#34;&#34;&#34;
        Constructor

        Parameters
        ----------

        **`date : int, optional`**

        Forecast initialization or observation date in YYYYMMDDHH format.

        **`id : list or 1-D array, optional`**

        List or 1-D array of length 4 containing the 4-word (integer) MOS-2000 ID of the data
        to be put into TdlpackRecord

        **`lead : int, optional`**

        Lead time (i.e. forecast projection) in hours of the data.  NOTE: This can be omitted

        **`plain : str, optional`**

        Plain language descriptor.  This is limited to 32 characters, though here 
        the input can be longer (will be cut off when packing).

        **`grid : dict , optional`**

        A dictionary containing grid definition attributes.  See
        Dictionary of grid specs (created from create_grid_def_dict)

        **`data : array_like, optional`**

        Data values.

        **`missing_value : float or list of floats, optional`**

        Provide either a primary missing value or primary and secondary as list.

        **`**kwargs : dict, optional`**

        Dictionary of class attributes (keys) and class attributes (values).
        &#34;&#34;&#34;
        type(self).counter += 1
        self._metadata_unpacked = False
        self._data_unpacked = False
        self.plain = &#39;&#39;
        if len(kwargs) == 0:
            # Means we are creating TdlpackRecord instance from the other function
            # input, NOT the kwargs Dict.
            self.id = id
            self.reference_date = date
            self.type = &#39;station&#39;
            self.is0 = np.zeros(ND7,dtype=np.int32)
            self.is1 = np.zeros(ND7,dtype=np.int32)
            self.is2 = np.zeros(ND7,dtype=np.int32)
            self.is4 = np.zeros(ND7,dtype=np.int32)

            self.is1[2] = np.int32(date/1000000)
            self.is1[3] = np.int32((date/10000)-(self.is1[2]*100))
            self.is1[4] = np.int32((date/100)-(self.is1[2]*10000)-(self.is1[3]*100))
            self.is1[5] = np.int32(date-((date/100)*100))
            self.is1[6] = np.int32(0)
            self.is1[7] = np.int32(date)
            self.is1[8] = np.int32(id[0])
            self.is1[9] = np.int32(id[1])
            self.is1[10] = np.int32(id[2])
            self.is1[11] = np.int32(id[3])
            if lead is None:
                self.is1[12] = np.int32(self.is1[10]-((self.is1[10]/1000)*1000))
            else:
                self.is1[12] = np.int32(lead)
            self.is1[13] = np.int32(0)
            self.is1[14] = np.int32(self.is1[8]-((self.is1[8]/100)*100))
            self.is1[15] = np.int32(0)
            self.is1[16] = np.int32(0)
            self.is1[17] = np.int32(0)
            self.is1[18] = np.int32(0)
            self.is1[19] = np.int32(0)
            self.is1[20] = np.int32(0)
            self.is1[21] = NCHAR_PLAIN
            if plain is None:
                self.plain = &#39; &#39;*NCHAR_PLAIN
            else:
                self.plain = plain
                for n,p in enumerate(plain):
                    self.is1[22+n] = np.int32(ord(p))

            if grid is not None and type(grid) is dict or data.shape == 2:
                # Gridded Data
                self.type = &#39;grid&#39;
                self.is1[1] = np.int32(1) # Set IS1[1] = 1
                self.is2[1] = np.int32(grid[&#39;proj&#39;])
                self.is2[2] = np.int32(grid[&#39;nx&#39;])
                self.is2[3] = np.int32(grid[&#39;ny&#39;])
                self.is2[4] = np.int32(grid[&#39;latll&#39;]*10000)
                self.is2[5] = np.int32(grid[&#39;lonll&#39;]*10000)
                self.is2[6] = np.int32(grid[&#39;orientlon&#39;]*10000)
                self.is2[7] = np.int32(grid[&#39;meshlength&#39;]*1000) # Value in dict is in units of meters.
                self.is2[8] = np.int32(grid[&#39;stdlat&#39;]*10000)
                self.nx = np.int32(grid[&#39;nx&#39;])
                self.ny = np.int32(grid[&#39;ny&#39;])
            if len(data) &gt; 0:
                self.data = np.array(data,dtype=np.float32)
                self.number_of_values = len(data)
            else:
                raise ValueError

            if missing_value is None:
                self.primary_missing_value = np.int32(0)
                self.secondary_missing_value = np.int32(0)
            else:
                if type(missing_value) is list:
                    if len(missing_value) == 1:
                        self.primary_missing_value = np.int32(missing_value[0])
                    elif len(missing_value) == 2:
                        self.primary_missing_value = np.int32(missing_value[0])
                        self.secondary_missing_value = np.int32(missing_value[1])
                else:
                    self.primary_missing_value = np.int32(missing_value)
                    self.secondary_missing_value = np.int32(0)

        else:
            # Instantiate via **kwargs
            for k,v in kwargs.items():
                setattr(self,k,v)

    def __getitem__(self,indices):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        if self.type == &#39;grid&#39;:
            if not isinstance(indices,tuple):
                indices = tuple(indices)
        elif self.type == &#39;station&#39;:
            if isinstance(indices,str):
                indices = tuple([_starecdict[self._filelun][self._starecindex].index(indices)])

        try:
            return self.data[indices]
        except(AttributeError):
            return None

    def __setitem__(self,indices,values):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        if self.type == &#39;grid&#39;:
            if not isinstance(indices,tuple):
                indices = tuple(indices)
        elif self.type == &#39;station&#39;:
            if isinstance(indices,str):
                indices = tuple([_starecdict[self._filelun][self._starecindex].index(indices)])

        self.data[indices] = values

    def __repr__(self):
        strings = []
        keys = self.__dict__.keys()
        for k in keys:
            if not k.startswith(&#39;_&#39;):
                strings.append(&#39;%s = %s\n&#39;%(k,self.__dict__[k]))
        return &#39;&#39;.join(strings)
    
    def pack(self,dec_scale=None,bin_scale=None):
        &#34;&#34;&#34;
        Pack a TDLPACK record.

        Parameters
        ----------

        **`dec_scale : int, optional, default = 1`**

        Decimal Scale Factor used to when packing TdlpackRecord data [DEFAULT is 1].

        **`bin_scale : int, optional, default = 0`**

        Binary Scale Factor used to when packing TdlpackRecord data [DEFAULT is 0]. NOTE:
        binary scale factor is currently NOT SUPPORTED in MOS-2000 software. It is added
        here for completeness.
        &#34;&#34;&#34;

        # Make sure data are unpacked
        if not self._data_unpacked:
            self.unpack(data=True)

        _ier = np.int32(0)
        self.ipack = np.zeros((ND5),dtype=np.int32)

        if dec_scale is not None:
            self.is1[16] = np.int32(dec_scale)

        if bin_scale is not None:
            self.is1[17] = np.int32(bin_scale)

        # Pack plain langauge into IS1 array.
        self.plain = self.plain.ljust(NCHAR_PLAIN)
        for n,p in enumerate(self.plain):
            self.is1[22+n] = np.int32(ord(p))

        # Handle potential NaN values
        if self.primary_missing_value == 0:
            self.primary_missing_value == DEFAULT_MISSING_VALUE
        self.data = np.where(np.isnan(self.data),np.float32(self.primary_missing_value),
                             self.data)

        if self.type == &#39;grid&#39;:
            _a = np.zeros((self.nx,self.ny),dtype=np.float32,order=&#39;F&#39;)
            _ia = np.zeros((self.nx,self.ny),dtype=np.int32,order=&#39;F&#39;)
            _ic = np.zeros((self.nx*self.ny),dtype=np.int32)
            self.ioctet,_ier = tdlpack.pack2d(FORTRAN_STDOUT_LUN,self.data,_ia,_ic,self.is0,
                               self.is1,self.is2,self.is4,self.primary_missing_value,
                               self.secondary_missing_value,self.ipack,MINPK,_lx,L3264B)
        elif self.type == &#39;station&#39;:
            _ic = np.zeros((self.number_of_values),dtype=np.int32)
            self.ioctet,_ier = tdlpack.pack1d(FORTRAN_STDOUT_LUN,self.data,_ic,self.is0,
                               self.is1,self.is2,self.is4,self.primary_missing_value,
                               self.secondary_missing_value,self.ipack,MINPK,
                               _lx,L3264B)
    
    def unpack(self,data=False,missing_value=None):
        &#34;&#34;&#34;
        Unpacks the TDLPACK identification sections and data (optional).

        Parameters
        ----------

        **`data : bool, optional`**

        If True, unpack data values. The default is False.

        **`missing_value : float, optional`**
        
        Set a missing value. If a missing value exists for the TDLPACK data record,
        it will be replaced with this value.
        &#34;&#34;&#34;
        _ier = np.int32(0)
        if not self._metadata_unpacked:
            if self.ipack.shape[0] &lt; ND5_META_MAX:
                _nd5_local = ND5_META_MIN
            else:
                _nd5_local = ND5_META_MAX
            _data_meta = np.zeros((_nd5_local),dtype=np.int32)
            _iwork_meta = np.zeros((_nd5_local),dtype=np.int32)
            _data_meta,_ier = tdlpack.unpack(FORTRAN_STDOUT_LUN,self.ipack[0:_nd5_local],
                              _iwork_meta,_is0,_is1,_is2,_is4,_misspx,
                              _misssx,np.int32(1),L3264B)
            if _ier == 0:
                self._metadata_unpacked = True
                self.is0 = deepcopy(_is0)
                self.is1 = deepcopy(_is1)
                self.is2 = deepcopy(_is2)
                self.is4 = deepcopy(_is4)
                self.id = self.is1[8:12]

        # Set attributes from is1[].
        self.lead_time = np.int32(str(self.is1[10])[-3:])
        if not self.plain:
            if self.is1[21] &gt; 0:
                for n in np.nditer(self.is1[22:(22+self.is1[21])]):
                    self.plain += chr(n)
            else:
                self.plain = &#39; &#39;*NCHAR_PLAIN

        # Set attributes from is2[].
        if self.is1[1] == 0:
            self.type = &#39;station&#39;
            self.map_proj = None
            self.nx = None
            self.ny = None
            self.lower_left_latitude = None
            self.lower_left_longitude = None
            self.origin_longitude = None
            self.grid_length = None
            self.standard_latitude = None
            if np.sum(self.is2) &gt; 0: self.is2 = np.zeros((ND7),dtype=np.int32)
        elif self.is1[1] == 1:
            self.type = &#39;grid&#39;
            self.map_proj = self.is2[1]
            self.nx = self.is2[2]
            self.ny = self.is2[3]
            self.lower_left_latitude = self.is2[4]/10000.
            self.lower_left_longitude = self.is2[5]/10000.
            self.origin_longitude = self.is2[6]/10000.
            self.grid_length = self.is2[7]/1000.
            self.standard_latitude = self.is2[8]/10000.
            self.grid_def = create_grid_definition(proj=self.map_proj,nx=self.nx,ny=self.ny,
                            latll=self.lower_left_latitude,lonll=self.lower_left_longitude,
                            orientlon=self.origin_longitude,stdlat=self.standard_latitude,
                            meshlength=self.grid_length)
            self.proj_string = _create_proj_string(self.grid_def)
       
        # Set attributes from is4[].
        self.number_of_values = self.is4[2]
        self.primary_missing_value = deepcopy(np.float32(self.is4[3]))
        self.secondary_missing_value = deepcopy(np.float32(self.is4[4]))

        if data:
            self._data_unpacked = True
            _nd5_local = max(self.is4[2],int(self.ioctet/NBYPWD))
            _iwork = np.zeros((_nd5_local),dtype=np.int32)
            _data = np.zeros((_nd5_local),dtype=np.float32)
            # Check to make sure the size of self.ipack is long enough. If not, then
            # we will &#34;append&#34; to self.ipack.
            if self.ipack.shape[0] &lt; _nd5_local:
                pad = np.zeros((_nd5_local-self.ipack.shape[0]),dtype=np.int32)
                self.ipack = np.append(self.ipack,pad)
            _data,_ier = tdlpack.unpack(FORTRAN_STDOUT_LUN,self.ipack[0:_nd5_local],
                                         _iwork,self.is0,self.is1,self.is2,self.is4,
                                         _misspx,_misssx,np.int32(2),L3264B)
            if _ier == 0:
                _data = deepcopy(_data[0:self.number_of_values+1])
            else:
                _data = np.zeros((self.number_of_values),dtype=np.float32)+DEFAULT_MISSING_VALUE
            self.data = deepcopy(_data[0:self.number_of_values])
            if missing_value is not None:
                self.data = np.where(self.data==self.primary_missing_value,np.float32(missing_value),self.data)
                self.primary_missing_value = np.float32(missing_value)
            if self.type == &#39;grid&#39;:
                self.data = np.reshape(self.data[0:self.number_of_values],(self.nx,self.ny),order=&#39;F&#39;)
    
    def latlons(self):
        &#34;&#34;&#34;
        Returns a tuple of latitudes and lontiude numpy.float32 arrays for the TDLPACK record.
        If the record is station, then return is None.

        Returns
        -------

        **`lats,lons : array_like`**
        
        Numpy.float32 arrays of grid latitudes and longitudes.  If `self.grid = &#39;station&#39;`, then None are returned.
        &#34;&#34;&#34;
        lats = None
        lons = None
        if self.type == &#39;grid&#39;:
            _ier = np.int32(0)
            lats = np.zeros((self.nx,self.ny),dtype=np.float32,order=&#39;F&#39;)
            lons = np.zeros((self.nx,self.ny),dtype=np.float32,order=&#39;F&#39;)
            lats,lons,_ier = tdlpack.gridij_to_latlon(FORTRAN_STDOUT_LUN,self.nx,self.ny,
                             self.map_proj,self.grid_length,self.origin_longitude,
                             self.standard_latitude,self.lower_left_latitude,
                             self.lower_left_longitude)
        return (lats,lons)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pytdlpack.TdlpackRecord.counter"><code class="name">var <span class="ident">counter</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pytdlpack.TdlpackRecord.latlons"><code class="name flex">
<span>def <span class="ident">latlons</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tuple of latitudes and lontiude numpy.float32 arrays for the TDLPACK record.
If the record is station, then return is None.</p>
<h2 id="returns">Returns</h2>
<p><strong><code>lats,lons : array_like</code></strong></p>
<p>Numpy.float32 arrays of grid latitudes and longitudes.
If <code>self.grid = 'station'</code>, then None are returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def latlons(self):
    &#34;&#34;&#34;
    Returns a tuple of latitudes and lontiude numpy.float32 arrays for the TDLPACK record.
    If the record is station, then return is None.

    Returns
    -------

    **`lats,lons : array_like`**
    
    Numpy.float32 arrays of grid latitudes and longitudes.  If `self.grid = &#39;station&#39;`, then None are returned.
    &#34;&#34;&#34;
    lats = None
    lons = None
    if self.type == &#39;grid&#39;:
        _ier = np.int32(0)
        lats = np.zeros((self.nx,self.ny),dtype=np.float32,order=&#39;F&#39;)
        lons = np.zeros((self.nx,self.ny),dtype=np.float32,order=&#39;F&#39;)
        lats,lons,_ier = tdlpack.gridij_to_latlon(FORTRAN_STDOUT_LUN,self.nx,self.ny,
                         self.map_proj,self.grid_length,self.origin_longitude,
                         self.standard_latitude,self.lower_left_latitude,
                         self.lower_left_longitude)
    return (lats,lons)</code></pre>
</details>
</dd>
<dt id="pytdlpack.TdlpackRecord.pack"><code class="name flex">
<span>def <span class="ident">pack</span></span>(<span>self, dec_scale=None, bin_scale=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Pack a TDLPACK record.</p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>dec_scale : int, optional, default = 1</code></strong></p>
<p>Decimal Scale Factor used to when packing TdlpackRecord data [DEFAULT is 1].</p>
<p><strong><code>bin_scale : int, optional, default = 0</code></strong></p>
<p>Binary Scale Factor used to when packing TdlpackRecord data [DEFAULT is 0]. NOTE:
binary scale factor is currently NOT SUPPORTED in MOS-2000 software. It is added
here for completeness.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pack(self,dec_scale=None,bin_scale=None):
    &#34;&#34;&#34;
    Pack a TDLPACK record.

    Parameters
    ----------

    **`dec_scale : int, optional, default = 1`**

    Decimal Scale Factor used to when packing TdlpackRecord data [DEFAULT is 1].

    **`bin_scale : int, optional, default = 0`**

    Binary Scale Factor used to when packing TdlpackRecord data [DEFAULT is 0]. NOTE:
    binary scale factor is currently NOT SUPPORTED in MOS-2000 software. It is added
    here for completeness.
    &#34;&#34;&#34;

    # Make sure data are unpacked
    if not self._data_unpacked:
        self.unpack(data=True)

    _ier = np.int32(0)
    self.ipack = np.zeros((ND5),dtype=np.int32)

    if dec_scale is not None:
        self.is1[16] = np.int32(dec_scale)

    if bin_scale is not None:
        self.is1[17] = np.int32(bin_scale)

    # Pack plain langauge into IS1 array.
    self.plain = self.plain.ljust(NCHAR_PLAIN)
    for n,p in enumerate(self.plain):
        self.is1[22+n] = np.int32(ord(p))

    # Handle potential NaN values
    if self.primary_missing_value == 0:
        self.primary_missing_value == DEFAULT_MISSING_VALUE
    self.data = np.where(np.isnan(self.data),np.float32(self.primary_missing_value),
                         self.data)

    if self.type == &#39;grid&#39;:
        _a = np.zeros((self.nx,self.ny),dtype=np.float32,order=&#39;F&#39;)
        _ia = np.zeros((self.nx,self.ny),dtype=np.int32,order=&#39;F&#39;)
        _ic = np.zeros((self.nx*self.ny),dtype=np.int32)
        self.ioctet,_ier = tdlpack.pack2d(FORTRAN_STDOUT_LUN,self.data,_ia,_ic,self.is0,
                           self.is1,self.is2,self.is4,self.primary_missing_value,
                           self.secondary_missing_value,self.ipack,MINPK,_lx,L3264B)
    elif self.type == &#39;station&#39;:
        _ic = np.zeros((self.number_of_values),dtype=np.int32)
        self.ioctet,_ier = tdlpack.pack1d(FORTRAN_STDOUT_LUN,self.data,_ic,self.is0,
                           self.is1,self.is2,self.is4,self.primary_missing_value,
                           self.secondary_missing_value,self.ipack,MINPK,
                           _lx,L3264B)</code></pre>
</details>
</dd>
<dt id="pytdlpack.TdlpackRecord.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, data=False, missing_value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Unpacks the TDLPACK identification sections and data (optional).</p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>data : bool, optional</code></strong></p>
<p>If True, unpack data values. The default is False.</p>
<p><strong><code>missing_value : float, optional</code></strong></p>
<p>Set a missing value. If a missing value exists for the TDLPACK data record,
it will be replaced with this value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpack(self,data=False,missing_value=None):
    &#34;&#34;&#34;
    Unpacks the TDLPACK identification sections and data (optional).

    Parameters
    ----------

    **`data : bool, optional`**

    If True, unpack data values. The default is False.

    **`missing_value : float, optional`**
    
    Set a missing value. If a missing value exists for the TDLPACK data record,
    it will be replaced with this value.
    &#34;&#34;&#34;
    _ier = np.int32(0)
    if not self._metadata_unpacked:
        if self.ipack.shape[0] &lt; ND5_META_MAX:
            _nd5_local = ND5_META_MIN
        else:
            _nd5_local = ND5_META_MAX
        _data_meta = np.zeros((_nd5_local),dtype=np.int32)
        _iwork_meta = np.zeros((_nd5_local),dtype=np.int32)
        _data_meta,_ier = tdlpack.unpack(FORTRAN_STDOUT_LUN,self.ipack[0:_nd5_local],
                          _iwork_meta,_is0,_is1,_is2,_is4,_misspx,
                          _misssx,np.int32(1),L3264B)
        if _ier == 0:
            self._metadata_unpacked = True
            self.is0 = deepcopy(_is0)
            self.is1 = deepcopy(_is1)
            self.is2 = deepcopy(_is2)
            self.is4 = deepcopy(_is4)
            self.id = self.is1[8:12]

    # Set attributes from is1[].
    self.lead_time = np.int32(str(self.is1[10])[-3:])
    if not self.plain:
        if self.is1[21] &gt; 0:
            for n in np.nditer(self.is1[22:(22+self.is1[21])]):
                self.plain += chr(n)
        else:
            self.plain = &#39; &#39;*NCHAR_PLAIN

    # Set attributes from is2[].
    if self.is1[1] == 0:
        self.type = &#39;station&#39;
        self.map_proj = None
        self.nx = None
        self.ny = None
        self.lower_left_latitude = None
        self.lower_left_longitude = None
        self.origin_longitude = None
        self.grid_length = None
        self.standard_latitude = None
        if np.sum(self.is2) &gt; 0: self.is2 = np.zeros((ND7),dtype=np.int32)
    elif self.is1[1] == 1:
        self.type = &#39;grid&#39;
        self.map_proj = self.is2[1]
        self.nx = self.is2[2]
        self.ny = self.is2[3]
        self.lower_left_latitude = self.is2[4]/10000.
        self.lower_left_longitude = self.is2[5]/10000.
        self.origin_longitude = self.is2[6]/10000.
        self.grid_length = self.is2[7]/1000.
        self.standard_latitude = self.is2[8]/10000.
        self.grid_def = create_grid_definition(proj=self.map_proj,nx=self.nx,ny=self.ny,
                        latll=self.lower_left_latitude,lonll=self.lower_left_longitude,
                        orientlon=self.origin_longitude,stdlat=self.standard_latitude,
                        meshlength=self.grid_length)
        self.proj_string = _create_proj_string(self.grid_def)
   
    # Set attributes from is4[].
    self.number_of_values = self.is4[2]
    self.primary_missing_value = deepcopy(np.float32(self.is4[3]))
    self.secondary_missing_value = deepcopy(np.float32(self.is4[4]))

    if data:
        self._data_unpacked = True
        _nd5_local = max(self.is4[2],int(self.ioctet/NBYPWD))
        _iwork = np.zeros((_nd5_local),dtype=np.int32)
        _data = np.zeros((_nd5_local),dtype=np.float32)
        # Check to make sure the size of self.ipack is long enough. If not, then
        # we will &#34;append&#34; to self.ipack.
        if self.ipack.shape[0] &lt; _nd5_local:
            pad = np.zeros((_nd5_local-self.ipack.shape[0]),dtype=np.int32)
            self.ipack = np.append(self.ipack,pad)
        _data,_ier = tdlpack.unpack(FORTRAN_STDOUT_LUN,self.ipack[0:_nd5_local],
                                     _iwork,self.is0,self.is1,self.is2,self.is4,
                                     _misspx,_misssx,np.int32(2),L3264B)
        if _ier == 0:
            _data = deepcopy(_data[0:self.number_of_values+1])
        else:
            _data = np.zeros((self.number_of_values),dtype=np.float32)+DEFAULT_MISSING_VALUE
        self.data = deepcopy(_data[0:self.number_of_values])
        if missing_value is not None:
            self.data = np.where(self.data==self.primary_missing_value,np.float32(missing_value),self.data)
            self.primary_missing_value = np.float32(missing_value)
        if self.type == &#39;grid&#39;:
            self.data = np.reshape(self.data[0:self.number_of_values],(self.nx,self.ny),order=&#39;F&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pytdlpack.TdlpackStationRecord"><code class="flex name class">
<span>class <span class="ident">TdlpackStationRecord</span></span>
<span>(</span><span>stations=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a TDLPACK Station Call Letter Record.</p>
<h2 id="attributes">Attributes</h2>
<p><strong><code>station : list</code></strong></p>
<p>A list of station call letters.</p>
<p><strong><code>id : array_like</code></strong></p>
<p>ID of station call letters. Note: This id is only used for random-access IO.</p>
<p><strong><code>ioctet : int</code></strong></p>
<p>Size of packed station call letter record in bytes.</p>
<p><strong><code>ipack : array_like</code></strong></p>
<p>Array containing the packed station call letter record.</p>
<p><strong><code>number_of_stations: int</code></strong></p>
<p>Size of station call letter record.</p>
<p><code><a title="pytdlpack.TdlpackStationRecord" href="#pytdlpack.TdlpackStationRecord">TdlpackStationRecord</a></code> Constructor</p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>stations : str or list or tuple</code></strong></p>
<p>String of a single station or a list or tuple of stations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TdlpackStationRecord(object):
    &#34;&#34;&#34;
    Defines a TDLPACK Station Call Letter Record.

    Attributes
    ----------

    **`station : list`**

    A list of station call letters.

    **`id : array_like`**

    ID of station call letters. Note: This id is only used for random-access IO.

    **`ioctet : int`**

    Size of packed station call letter record in bytes.

    **`ipack : array_like`**

    Array containing the packed station call letter record.

    **`number_of_stations: int`**

    Size of station call letter record.
    &#34;&#34;&#34;
    counter = 0
    def __init__(self,stations=None,**kwargs):
        &#34;&#34;&#34;
        `pytdlpack.TdlpackStationRecord` Constructor

        Parameters
        ----------

        **`stations : str or list or tuple`**

        String of a single station or a list or tuple of stations.
        &#34;&#34;&#34;
        type(self).counter += 1

        if stations is not None:
            if type(stations) is str:
                self.stations = [stations]
            elif type(stations) is list:
                self.stations = stations
            elif type(stations) is tuple:
                self.stations = list(stations)
            else:
                pass # TODO: raise error... TypeError
            self.number_of_stations = np.int32(len(stations))
            self.id = np.int32([400001000,0,0,0])
            self.ioctet = np.int32(0)
            self.ipack = np.array((),dtype=np.int32)
        else:
            for k,v in kwargs.items():
                setattr(self,k,v)

        #self.number_of_stations = np.int32(len(stations))
        #self.id = np.int32([400001000,0,0,0])
        #self.ioctet = np.int32(0)
        #self.ipack = np.array((),dtype=np.int32)

    def __repr__(self):
        strings = []
        keys = self.__dict__.keys()
        for k in keys:
            if not k.startswith(&#39;_&#39;):
                strings.append(&#39;%s = %s\n&#39;%(k,self.__dict__[k]))
        return &#39;&#39;.join(strings)
    
    def pack(self):
        &#34;&#34;&#34;
        Pack a Station Call Letter Record.
        &#34;&#34;&#34;
        #pdb.set_trace()
        self.ioctet = np.int32(self.number_of_stations*NCHAR)
        self.ipack = np.ndarray(int(self.ioctet/(L3264B/NCHAR)),dtype=np.int32)
        for n,s in enumerate(self.stations):
            sta = s.ljust(int(NCHAR),&#39; &#39;)
            self.ipack[n*2] = np.copy(np.fromstring(sta[0:int(NCHAR/2)],dtype=np.int32).byteswap())
            self.ipack[(n*2)+1] = np.copy(np.fromstring(sta[int(NCHAR/2):int(NCHAR)],dtype=np.int32).byteswap())

    def unpack(self):
        &#34;&#34;&#34;
        Unpack a Station Call Letter Record.
        &#34;&#34;&#34;
        _stations = []
        _unpack_string_fmt = &#39;&gt;&#39;+str(NCHAR)+&#39;s&#39;
        nrange = range(0,int(self.ioctet/(NCHAR/2)),2)
        if _IS_PYTHON3:
            nrange = list(range(0,int(self.ioctet/(NCHAR/2)),2))
        for n in nrange:
            tmp = struct.unpack(_unpack_string_fmt,self.ipack[n:n+2].byteswap())[0]
            if _IS_PYTHON3:
                tmp = tmp.decode()
            _stations.append(tmp.strip(&#39; &#39;))
        self.stations = list(deepcopy(_stations))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pytdlpack.TdlpackStationRecord.counter"><code class="name">var <span class="ident">counter</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pytdlpack.TdlpackStationRecord.pack"><code class="name flex">
<span>def <span class="ident">pack</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Pack a Station Call Letter Record.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pack(self):
    &#34;&#34;&#34;
    Pack a Station Call Letter Record.
    &#34;&#34;&#34;
    #pdb.set_trace()
    self.ioctet = np.int32(self.number_of_stations*NCHAR)
    self.ipack = np.ndarray(int(self.ioctet/(L3264B/NCHAR)),dtype=np.int32)
    for n,s in enumerate(self.stations):
        sta = s.ljust(int(NCHAR),&#39; &#39;)
        self.ipack[n*2] = np.copy(np.fromstring(sta[0:int(NCHAR/2)],dtype=np.int32).byteswap())
        self.ipack[(n*2)+1] = np.copy(np.fromstring(sta[int(NCHAR/2):int(NCHAR)],dtype=np.int32).byteswap())</code></pre>
</details>
</dd>
<dt id="pytdlpack.TdlpackStationRecord.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Unpack a Station Call Letter Record.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpack(self):
    &#34;&#34;&#34;
    Unpack a Station Call Letter Record.
    &#34;&#34;&#34;
    _stations = []
    _unpack_string_fmt = &#39;&gt;&#39;+str(NCHAR)+&#39;s&#39;
    nrange = range(0,int(self.ioctet/(NCHAR/2)),2)
    if _IS_PYTHON3:
        nrange = list(range(0,int(self.ioctet/(NCHAR/2)),2))
    for n in nrange:
        tmp = struct.unpack(_unpack_string_fmt,self.ipack[n:n+2].byteswap())[0]
        if _IS_PYTHON3:
            tmp = tmp.decode()
        _stations.append(tmp.strip(&#39; &#39;))
    self.stations = list(deepcopy(_stations))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pytdlpack.TdlpackTrailerRecord"><code class="flex name class">
<span>class <span class="ident">TdlpackTrailerRecord</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a TDLPACK Trailer Record.</p>
<p><code><a title="pytdlpack.TdlpackTrailerRecord" href="#pytdlpack.TdlpackTrailerRecord">TdlpackTrailerRecord</a></code> Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TdlpackTrailerRecord(object):
    &#34;&#34;&#34;
    Defines a TDLPACK Trailer Record.
    &#34;&#34;&#34;
    counter = 0
    def __init__(self, **kwargs):
        &#34;&#34;&#34;
        `pytdlpack.TdlpackTrailerRecord` Constructor
        &#34;&#34;&#34;
        type(self).counter += 0
        for k, v in kwargs.items():
            setattr(self, k, v)

    def __repr__(self):
        strings = []
        keys = self.__dict__.keys()
        for k in keys:
            if not k.startswith(&#39;_&#39;):
                strings.append(&#39;%s = %s\n&#39;%(k,self.__dict__[k]))
        return &#39;&#39;.join(strings)

    def pack(self):
        pass

    def unpack(self):
        pass</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pytdlpack.TdlpackTrailerRecord.counter"><code class="name">var <span class="ident">counter</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pytdlpack.TdlpackTrailerRecord.pack"><code class="name flex">
<span>def <span class="ident">pack</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pack(self):
    pass</code></pre>
</details>
</dd>
<dt id="pytdlpack.TdlpackTrailerRecord.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpack(self):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#download">Download</a></li>
<li><a href="#requires">Requires</a></li>
<li><a href="#install">Install</a></li>
<li><a href="#tutorial">Tutorial</a><ul>
<li><a href="#1-creatingopeningclosing-a-tdlpack-file">1) Creating/Opening/Closing a TDLPACK file.</a></li>
<li><a href="#2-reading-a-tdlpack-file">2) Reading a TDLPACK file.</a></li>
<li><a href="#3-writing-a-tdlpack-file">3) Writing a TDLPACK file.</a></li>
<li><a href="#4-creating-a-tdlpack-station-record">4) Creating a TDLPACK Station Record.</a></li>
<li><a href="#5-creating-a-tdlpack-record">5) Creating a TDLPACK Record.</a></li>
<li><a href="#6-packingunpacking-a-tdlpack-record">6) Packing/Unpacking a TDLPACK Record.</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pytdlpack.version" href="version.html">pytdlpack.version</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pytdlpack.create_grid_definition" href="#pytdlpack.create_grid_definition">create_grid_definition</a></code></li>
<li><code><a title="pytdlpack.open" href="#pytdlpack.open">open</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pytdlpack.TdlpackFile" href="#pytdlpack.TdlpackFile">TdlpackFile</a></code></h4>
<ul class="two-column">
<li><code><a title="pytdlpack.TdlpackFile.backspace" href="#pytdlpack.TdlpackFile.backspace">backspace</a></code></li>
<li><code><a title="pytdlpack.TdlpackFile.close" href="#pytdlpack.TdlpackFile.close">close</a></code></li>
<li><code><a title="pytdlpack.TdlpackFile.counter" href="#pytdlpack.TdlpackFile.counter">counter</a></code></li>
<li><code><a title="pytdlpack.TdlpackFile.read" href="#pytdlpack.TdlpackFile.read">read</a></code></li>
<li><code><a title="pytdlpack.TdlpackFile.rewind" href="#pytdlpack.TdlpackFile.rewind">rewind</a></code></li>
<li><code><a title="pytdlpack.TdlpackFile.write" href="#pytdlpack.TdlpackFile.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pytdlpack.TdlpackRecord" href="#pytdlpack.TdlpackRecord">TdlpackRecord</a></code></h4>
<ul class="">
<li><code><a title="pytdlpack.TdlpackRecord.counter" href="#pytdlpack.TdlpackRecord.counter">counter</a></code></li>
<li><code><a title="pytdlpack.TdlpackRecord.latlons" href="#pytdlpack.TdlpackRecord.latlons">latlons</a></code></li>
<li><code><a title="pytdlpack.TdlpackRecord.pack" href="#pytdlpack.TdlpackRecord.pack">pack</a></code></li>
<li><code><a title="pytdlpack.TdlpackRecord.unpack" href="#pytdlpack.TdlpackRecord.unpack">unpack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pytdlpack.TdlpackStationRecord" href="#pytdlpack.TdlpackStationRecord">TdlpackStationRecord</a></code></h4>
<ul class="">
<li><code><a title="pytdlpack.TdlpackStationRecord.counter" href="#pytdlpack.TdlpackStationRecord.counter">counter</a></code></li>
<li><code><a title="pytdlpack.TdlpackStationRecord.pack" href="#pytdlpack.TdlpackStationRecord.pack">pack</a></code></li>
<li><code><a title="pytdlpack.TdlpackStationRecord.unpack" href="#pytdlpack.TdlpackStationRecord.unpack">unpack</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pytdlpack.TdlpackTrailerRecord" href="#pytdlpack.TdlpackTrailerRecord">TdlpackTrailerRecord</a></code></h4>
<ul class="">
<li><code><a title="pytdlpack.TdlpackTrailerRecord.counter" href="#pytdlpack.TdlpackTrailerRecord.counter">counter</a></code></li>
<li><code><a title="pytdlpack.TdlpackTrailerRecord.pack" href="#pytdlpack.TdlpackTrailerRecord.pack">pack</a></code></li>
<li><code><a title="pytdlpack.TdlpackTrailerRecord.unpack" href="#pytdlpack.TdlpackTrailerRecord.unpack">unpack</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>