# coding: utf-8

"""
    Adobe Experience Manager (AEM) API

    Swagger AEM is an OpenAPI specification for Adobe Experience Manager (AEM) API

    OpenAPI spec version: 2.2.0
    Contact: opensource@shinesolutions.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..api_client import ApiClient


class ConsoleApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def post_bundle(self, name, action, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_bundle(name, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param str action: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_bundle_with_http_info(name, action, **kwargs)
        else:
            (data) = self.post_bundle_with_http_info(name, action, **kwargs)
            return data

    def post_bundle_with_http_info(self, name, action, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_bundle_with_http_info(name, action, async=True)
        >>> result = thread.get()

        :param async bool
        :param str name: (required)
        :param str action: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'action']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_bundle" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params) or (params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `post_bundle`")
        # verify the required parameter 'action' is set
        if ('action' not in params) or (params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `post_bundle`")


        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/system/console/bundles/{name}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async_req=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_jmx_repository(self, action, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_jmx_repository(action, async=True)
        >>> result = thread.get()

        :param async bool
        :param str action: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_jmx_repository_with_http_info(action, **kwargs)
        else:
            (data) = self.post_jmx_repository_with_http_info(action, **kwargs)
            return data

    def post_jmx_repository_with_http_info(self, action, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_jmx_repository_with_http_info(action, async=True)
        >>> result = thread.get()

        :param async bool
        :param str action: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_jmx_repository" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params) or (params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `post_jmx_repository`")


        collection_formats = {}

        path_params = {}
        if 'action' in params:
            path_params['action'] = params['action']

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/system/console/jmx/com.adobe.granite:type=Repository/op/{action}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type=None,
                                        auth_settings=auth_settings,
                                        async_req=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_saml_configuration(self, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_saml_configuration(async=True)
        >>> result = thread.get()

        :param async bool
        :param bool post:
        :param bool apply:
        :param bool delete:
        :param str action:
        :param str location:
        :param list[str] path:
        :param str service_ranking:
        :param str idp_url:
        :param str idp_cert_alias:
        :param bool idp_http_redirect:
        :param str service_provider_entity_id:
        :param str assertion_consumer_service_url:
        :param str sp_private_key_alias:
        :param str key_store_password:
        :param str default_redirect_url:
        :param str user_id_attribute:
        :param bool use_encryption:
        :param bool create_user:
        :param bool add_group_memberships:
        :param str group_membership_attribute:
        :param list[str] default_groups:
        :param str name_id_format:
        :param list[str] synchronize_attributes:
        :param bool handle_logout:
        :param str logout_url:
        :param str clock_tolerance:
        :param str digest_method:
        :param str signature_method:
        :param str user_intermediate_path:
        :param list[str] propertylist:
        :return: SamlConfigurationInformations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.post_saml_configuration_with_http_info(**kwargs)
        else:
            (data) = self.post_saml_configuration_with_http_info(**kwargs)
            return data

    def post_saml_configuration_with_http_info(self, **kwargs):
        """
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.post_saml_configuration_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param bool post:
        :param bool apply:
        :param bool delete:
        :param str action:
        :param str location:
        :param list[str] path:
        :param str service_ranking:
        :param str idp_url:
        :param str idp_cert_alias:
        :param bool idp_http_redirect:
        :param str service_provider_entity_id:
        :param str assertion_consumer_service_url:
        :param str sp_private_key_alias:
        :param str key_store_password:
        :param str default_redirect_url:
        :param str user_id_attribute:
        :param bool use_encryption:
        :param bool create_user:
        :param bool add_group_memberships:
        :param str group_membership_attribute:
        :param list[str] default_groups:
        :param str name_id_format:
        :param list[str] synchronize_attributes:
        :param bool handle_logout:
        :param str logout_url:
        :param str clock_tolerance:
        :param str digest_method:
        :param str signature_method:
        :param str user_intermediate_path:
        :param list[str] propertylist:
        :return: SamlConfigurationInformations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['post', 'apply', 'delete', 'action', 'location', 'path', 'service_ranking', 'idp_url', 'idp_cert_alias', 'idp_http_redirect', 'service_provider_entity_id', 'assertion_consumer_service_url', 'sp_private_key_alias', 'key_store_password', 'default_redirect_url', 'user_id_attribute', 'use_encryption', 'create_user', 'add_group_memberships', 'group_membership_attribute', 'default_groups', 'name_id_format', 'synchronize_attributes', 'handle_logout', 'logout_url', 'clock_tolerance', 'digest_method', 'signature_method', 'user_intermediate_path', 'propertylist']
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_saml_configuration" % key
                )
            params[key] = val
        del params['kwargs']


        collection_formats = {}

        path_params = {}

        query_params = []
        if 'post' in params:
            query_params.append(('post', params['post']))
        if 'apply' in params:
            query_params.append(('apply', params['apply']))
        if 'delete' in params:
            query_params.append(('delete', params['delete']))
        if 'action' in params:
            query_params.append(('action', params['action']))
        if 'location' in params:
            query_params.append(('$location', params['location']))
        if 'path' in params:
            query_params.append(('path', params['path']))
            collection_formats['path'] = 'multi'
        if 'service_ranking' in params:
            query_params.append(('service.ranking', params['service_ranking']))
        if 'idp_url' in params:
            query_params.append(('idpUrl', params['idp_url']))
        if 'idp_cert_alias' in params:
            query_params.append(('idpCertAlias', params['idp_cert_alias']))
        if 'idp_http_redirect' in params:
            query_params.append(('idpHttpRedirect', params['idp_http_redirect']))
        if 'service_provider_entity_id' in params:
            query_params.append(('serviceProviderEntityId', params['service_provider_entity_id']))
        if 'assertion_consumer_service_url' in params:
            query_params.append(('assertionConsumerServiceURL', params['assertion_consumer_service_url']))
        if 'sp_private_key_alias' in params:
            query_params.append(('spPrivateKeyAlias', params['sp_private_key_alias']))
        if 'key_store_password' in params:
            query_params.append(('keyStorePassword', params['key_store_password']))
        if 'default_redirect_url' in params:
            query_params.append(('defaultRedirectUrl', params['default_redirect_url']))
        if 'user_id_attribute' in params:
            query_params.append(('userIDAttribute', params['user_id_attribute']))
        if 'use_encryption' in params:
            query_params.append(('useEncryption', params['use_encryption']))
        if 'create_user' in params:
            query_params.append(('createUser', params['create_user']))
        if 'add_group_memberships' in params:
            query_params.append(('addGroupMemberships', params['add_group_memberships']))
        if 'group_membership_attribute' in params:
            query_params.append(('groupMembershipAttribute', params['group_membership_attribute']))
        if 'default_groups' in params:
            query_params.append(('defaultGroups', params['default_groups']))
            collection_formats['defaultGroups'] = 'multi'
        if 'name_id_format' in params:
            query_params.append(('nameIdFormat', params['name_id_format']))
        if 'synchronize_attributes' in params:
            query_params.append(('synchronizeAttributes', params['synchronize_attributes']))
            collection_formats['synchronizeAttributes'] = 'multi'
        if 'handle_logout' in params:
            query_params.append(('handleLogout', params['handle_logout']))
        if 'logout_url' in params:
            query_params.append(('logoutUrl', params['logout_url']))
        if 'clock_tolerance' in params:
            query_params.append(('clockTolerance', params['clock_tolerance']))
        if 'digest_method' in params:
            query_params.append(('digestMethod', params['digest_method']))
        if 'signature_method' in params:
            query_params.append(('signatureMethod', params['signature_method']))
        if 'user_intermediate_path' in params:
            query_params.append(('userIntermediatePath', params['user_intermediate_path']))
        if 'propertylist' in params:
            query_params.append(('propertylist', params['propertylist']))
            collection_formats['propertylist'] = 'csv'

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text/plain'])

        # Authentication setting
        auth_settings = ['aemAuth']

        return self.api_client.call_api('/system/console/configMgr/com.adobe.granite.auth.saml.SamlAuthenticationHandler', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='SamlConfigurationInformations',
                                        auth_settings=auth_settings,
                                        async_req=params.get('async'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
