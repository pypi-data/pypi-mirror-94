# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")


print('Loading pyFAST ...')
import _fast
print('Done')


try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _fast.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fast.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _fast.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _fast.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _fast.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _fast.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _fast.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _fast.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _fast.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _fast.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _fast.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _fast.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _fast.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _fast.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _fast.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _fast.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _fast.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _fast.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _fast:
_fast.SwigPyIterator_swigregister(SwigPyIterator)

class vectori(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectori_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectori___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectori___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _fast.vectori___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _fast.vectori___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectori___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _fast.vectori___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectori___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _fast.vectori___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectori___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _fast.vectori_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _fast.vectori_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectori_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _fast.vectori_size(self)

    def swap(self, v: "vectori") -> "void":
        return _fast.vectori_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _fast.vectori_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _fast.vectori_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _fast.vectori_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _fast.vectori_rend(self)

    def clear(self) -> "void":
        return _fast.vectori_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _fast.vectori_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectori_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _fast.vectori_erase(self, *args)

    def __init__(self, *args):
        _fast.vectori_swiginit(self, _fast.new_vectori(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _fast.vectori_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _fast.vectori_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _fast.vectori_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _fast.vectori_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectori_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectori_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _fast.vectori_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _fast.vectori_capacity(self)
    __swig_destroy__ = _fast.delete_vectori

# Register vectori in _fast:
_fast.vectori_swigregister(vectori)

class vectorf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectorf_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectorf___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectorf___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _fast.vectorf___len__(self)

    def __getslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "std::vector< float,std::allocator< float > > *":
        return _fast.vectorf___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectorf___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "void":
        return _fast.vectorf___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectorf___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _fast.vectorf___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectorf___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _fast.vectorf_pop(self)

    def append(self, x: "std::vector< float >::value_type const &") -> "void":
        return _fast.vectorf_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectorf_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _fast.vectorf_size(self)

    def swap(self, v: "vectorf") -> "void":
        return _fast.vectorf_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _fast.vectorf_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _fast.vectorf_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _fast.vectorf_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _fast.vectorf_rend(self)

    def clear(self) -> "void":
        return _fast.vectorf_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _fast.vectorf_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectorf_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _fast.vectorf_erase(self, *args)

    def __init__(self, *args):
        _fast.vectorf_swiginit(self, _fast.new_vectorf(*args))

    def push_back(self, x: "std::vector< float >::value_type const &") -> "void":
        return _fast.vectorf_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _fast.vectorf_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _fast.vectorf_back(self)

    def assign(self, n: "std::vector< float >::size_type", x: "std::vector< float >::value_type const &") -> "void":
        return _fast.vectorf_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectorf_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectorf_insert(self, *args)

    def reserve(self, n: "std::vector< float >::size_type") -> "void":
        return _fast.vectorf_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _fast.vectorf_capacity(self)
    __swig_destroy__ = _fast.delete_vectorf

# Register vectorf in _fast:
_fast.vectorf_swigregister(vectorf)

class vectorui(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectorui_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectorui___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectorui___bool__(self)

    def __len__(self) -> "std::vector< uint >::size_type":
        return _fast.vectorui___len__(self)

    def __getslice__(self, i: "std::vector< uint >::difference_type", j: "std::vector< uint >::difference_type") -> "std::vector< uint,std::allocator< uint > > *":
        return _fast.vectorui___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectorui___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< uint >::difference_type", j: "std::vector< uint >::difference_type") -> "void":
        return _fast.vectorui___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectorui___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< uint >::value_type const &":
        return _fast.vectorui___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectorui___setitem__(self, *args)

    def pop(self) -> "std::vector< uint >::value_type":
        return _fast.vectorui_pop(self)

    def append(self, x: "std::vector< uint >::value_type const &") -> "void":
        return _fast.vectorui_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectorui_empty(self)

    def size(self) -> "std::vector< uint >::size_type":
        return _fast.vectorui_size(self)

    def swap(self, v: "vectorui") -> "void":
        return _fast.vectorui_swap(self, v)

    def begin(self) -> "std::vector< uint >::iterator":
        return _fast.vectorui_begin(self)

    def end(self) -> "std::vector< uint >::iterator":
        return _fast.vectorui_end(self)

    def rbegin(self) -> "std::vector< uint >::reverse_iterator":
        return _fast.vectorui_rbegin(self)

    def rend(self) -> "std::vector< uint >::reverse_iterator":
        return _fast.vectorui_rend(self)

    def clear(self) -> "void":
        return _fast.vectorui_clear(self)

    def get_allocator(self) -> "std::vector< uint >::allocator_type":
        return _fast.vectorui_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectorui_pop_back(self)

    def erase(self, *args) -> "std::vector< uint >::iterator":
        return _fast.vectorui_erase(self, *args)

    def __init__(self, *args):
        _fast.vectorui_swiginit(self, _fast.new_vectorui(*args))

    def push_back(self, x: "std::vector< uint >::value_type const &") -> "void":
        return _fast.vectorui_push_back(self, x)

    def front(self) -> "std::vector< uint >::value_type const &":
        return _fast.vectorui_front(self)

    def back(self) -> "std::vector< uint >::value_type const &":
        return _fast.vectorui_back(self)

    def assign(self, n: "std::vector< uint >::size_type", x: "std::vector< uint >::value_type const &") -> "void":
        return _fast.vectorui_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectorui_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectorui_insert(self, *args)

    def reserve(self, n: "std::vector< uint >::size_type") -> "void":
        return _fast.vectorui_reserve(self, n)

    def capacity(self) -> "std::vector< uint >::size_type":
        return _fast.vectorui_capacity(self)
    __swig_destroy__ = _fast.delete_vectorui

# Register vectorui in _fast:
_fast.vectorui_swigregister(vectorui)

class vectorc(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectorc_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectorc___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectorc___bool__(self)

    def __len__(self) -> "std::vector< char >::size_type":
        return _fast.vectorc___len__(self)

    def __getslice__(self, i: "std::vector< char >::difference_type", j: "std::vector< char >::difference_type") -> "std::vector< char,std::allocator< char > > *":
        return _fast.vectorc___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectorc___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< char >::difference_type", j: "std::vector< char >::difference_type") -> "void":
        return _fast.vectorc___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectorc___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< char >::value_type const &":
        return _fast.vectorc___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectorc___setitem__(self, *args)

    def pop(self) -> "std::vector< char >::value_type":
        return _fast.vectorc_pop(self)

    def append(self, x: "std::vector< char >::value_type const &") -> "void":
        return _fast.vectorc_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectorc_empty(self)

    def size(self) -> "std::vector< char >::size_type":
        return _fast.vectorc_size(self)

    def swap(self, v: "vectorc") -> "void":
        return _fast.vectorc_swap(self, v)

    def begin(self) -> "std::vector< char >::iterator":
        return _fast.vectorc_begin(self)

    def end(self) -> "std::vector< char >::iterator":
        return _fast.vectorc_end(self)

    def rbegin(self) -> "std::vector< char >::reverse_iterator":
        return _fast.vectorc_rbegin(self)

    def rend(self) -> "std::vector< char >::reverse_iterator":
        return _fast.vectorc_rend(self)

    def clear(self) -> "void":
        return _fast.vectorc_clear(self)

    def get_allocator(self) -> "std::vector< char >::allocator_type":
        return _fast.vectorc_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectorc_pop_back(self)

    def erase(self, *args) -> "std::vector< char >::iterator":
        return _fast.vectorc_erase(self, *args)

    def __init__(self, *args):
        _fast.vectorc_swiginit(self, _fast.new_vectorc(*args))

    def push_back(self, x: "std::vector< char >::value_type const &") -> "void":
        return _fast.vectorc_push_back(self, x)

    def front(self) -> "std::vector< char >::value_type const &":
        return _fast.vectorc_front(self)

    def back(self) -> "std::vector< char >::value_type const &":
        return _fast.vectorc_back(self)

    def assign(self, n: "std::vector< char >::size_type", x: "std::vector< char >::value_type const &") -> "void":
        return _fast.vectorc_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectorc_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectorc_insert(self, *args)

    def reserve(self, n: "std::vector< char >::size_type") -> "void":
        return _fast.vectorc_reserve(self, n)

    def capacity(self) -> "std::vector< char >::size_type":
        return _fast.vectorc_capacity(self)
    __swig_destroy__ = _fast.delete_vectorc

# Register vectorc in _fast:
_fast.vectorc_swigregister(vectorc)

class ReporterEnd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _fast.ReporterEnd_swiginit(self, _fast.new_ReporterEnd())
    __swig_destroy__ = _fast.delete_ReporterEnd

# Register ReporterEnd in _fast:
_fast.ReporterEnd_swigregister(ReporterEnd)

class Reporter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def end() -> "fast::ReporterEnd":
        return _fast.Reporter_end()

    @staticmethod
    def info() -> "fast::Reporter":
        return _fast.Reporter_info()

    @staticmethod
    def warning() -> "fast::Reporter":
        return _fast.Reporter_warning()

    @staticmethod
    def error() -> "fast::Reporter":
        return _fast.Reporter_error()
    INFO = _fast.Reporter_INFO
    WARNING = _fast.Reporter_WARNING
    ERROR = _fast.Reporter_ERROR
    NONE = _fast.Reporter_NONE
    COUT = _fast.Reporter_COUT
    LOG = _fast.Reporter_LOG

    def setType(self, arg2: "fast::Reporter::Type") -> "void":
        return _fast.Reporter_setType(self, arg2)

    def __init__(self, *args):
        _fast.Reporter_swiginit(self, _fast.new_Reporter(*args))

    def processEnd(self) -> "void":
        return _fast.Reporter_processEnd(self)

    def setReportMethod(self, *args) -> "void":
        return _fast.Reporter_setReportMethod(self, *args)

    @staticmethod
    def setGlobalReportMethod(*args) -> "void":
        return _fast.Reporter_setGlobalReportMethod(*args)
    __swig_destroy__ = _fast.delete_Reporter

# Register Reporter in _fast:
_fast.Reporter_swigregister(Reporter)

def Reporter_end() -> "fast::ReporterEnd":
    return _fast.Reporter_end()

def Reporter_info() -> "fast::Reporter":
    return _fast.Reporter_info()

def Reporter_warning() -> "fast::Reporter":
    return _fast.Reporter_warning()

def Reporter_error() -> "fast::Reporter":
    return _fast.Reporter_error()

def Reporter_setGlobalReportMethod(*args) -> "void":
    return _fast.Reporter_setGlobalReportMethod(*args)

STREAMING_MODE_NEWEST_FRAME_ONLY = _fast.STREAMING_MODE_NEWEST_FRAME_ONLY
STREAMING_MODE_STORE_ALL_FRAMES = _fast.STREAMING_MODE_STORE_ALL_FRAMES
STREAMING_MODE_PROCESS_ALL_FRAMES = _fast.STREAMING_MODE_PROCESS_ALL_FRAMES
class Object(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _fast.Object_swiginit(self, _fast.new_Object())
    __swig_destroy__ = _fast.delete_Object

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Object_getStaticNameOfClass()

    def getReporter(self) -> "fast::Reporter &":
        return _fast.Object_getReporter(self)

# Register Object in _fast:
_fast.Object_swigregister(Object)

def Object_getStaticNameOfClass() -> "std::string":
    return _fast.Object_getStaticNameOfClass()

class DataObject(Object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setMetadata(self, *args) -> "void":
        return _fast.DataObject_setMetadata(self, *args)

    def getMetadata(self, *args) -> "std::unordered_map< std::string,std::string >":
        return _fast.DataObject_getMetadata(self, *args)

    def deleteMetadata(self, name: "std::string") -> "void":
        return _fast.DataObject_deleteMetadata(self, name)

    def getTimestamp(self) -> "uint64_t":
        return _fast.DataObject_getTimestamp(self)

    def updateModifiedTimestamp(self) -> "void":
        return _fast.DataObject_updateModifiedTimestamp(self)
    __swig_destroy__ = _fast.delete_DataObject

    def getNameOfClass(self) -> "std::string":
        return _fast.DataObject_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.DataObject_getStaticNameOfClass()

    def getCreationTimestamp(self) -> "uint64_t":
        return _fast.DataObject_getCreationTimestamp(self)

    def setCreationTimestamp(self, timestamp: "uint64_t") -> "void":
        return _fast.DataObject_setCreationTimestamp(self, timestamp)

    def setLastFrame(self, streamer: "std::string") -> "void":
        return _fast.DataObject_setLastFrame(self, streamer)

    def isLastFrame(self, *args) -> "bool":
        return _fast.DataObject_isLastFrame(self, *args)

    def getLastFrame(self) -> "std::unordered_set< std::string >":
        return _fast.DataObject_getLastFrame(self)

    def setFrameData(self, name: "std::string", value: "std::string") -> "void":
        return _fast.DataObject_setFrameData(self, name, value)

    def getFrameData(self, *args) -> "std::unordered_map< std::string,std::string >":
        return _fast.DataObject_getFrameData(self, *args)

    def accessFinished(self) -> "void":
        return _fast.DataObject_accessFinished(self)

# Register DataObject in _fast:
_fast.DataObject_swigregister(DataObject)

def DataObject_getStaticNameOfClass() -> "std::string":
    return _fast.DataObject_getStaticNameOfClass()

class DataChannel(Object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def addFrame(self, data: "fast::DataObject::pointer") -> "void":
        r"""
        Add frame to the data channel. This call may block
        if the buffer is full.
        """
        return _fast.DataChannel_addFrame(self, data)

    def getSize(self) -> "int":
        r"""
        :rtype: int
        :return: the number of frames stored in this DataChannel
        """
        return _fast.DataChannel_getSize(self)

    def setMaximumNumberOfFrames(self, frames: "uint") -> "void":
        r"""Set the maximum nr of frames that can be stored in this data channel"""
        return _fast.DataChannel_setMaximumNumberOfFrames(self, frames)

    def stop(self) -> "void":
        r"""This will unblock if this DataChannel is currently blocking. Used to stop a pipeline."""
        return _fast.DataChannel_stop(self)

    def hasCurrentData(self) -> "bool":
        return _fast.DataChannel_hasCurrentData(self)

    def getFrame(self) -> "fast::DataObject::pointer":
        r"""Get current frame, throws if current frame is not available."""
        return _fast.DataChannel_getFrame(self)

    def getProcessObject(self) -> "std::shared_ptr< fast::ProcessObject >":
        return _fast.DataChannel_getProcessObject(self)

    def setProcessObject(self, po: "std::shared_ptr< fast::ProcessObject >") -> "void":
        return _fast.DataChannel_setProcessObject(self, po)

    def getNextImage(self) -> "std::shared_ptr< fast::Image >":
        r"""
        Get next frame in the data channel.
        It will block until the frame is available.
        """
        return _fast.DataChannel_getNextImage(self)

    def getNextImagePyramid(self) -> "std::shared_ptr< fast::ImagePyramid >":
        r"""
        Get next frame in the data channel.
        It will block until the frame is available.
        """
        return _fast.DataChannel_getNextImagePyramid(self)

    def getNextSegmentation(self) -> "std::shared_ptr< fast::Segmentation >":
        r"""
        Get next frame in the data channel.
        It will block until the frame is available.
        """
        return _fast.DataChannel_getNextSegmentation(self)

    def getNextTensor(self) -> "std::shared_ptr< fast::Tensor >":
        r"""
        Get next frame in the data channel.
        It will block until the frame is available.
        """
        return _fast.DataChannel_getNextTensor(self)

    def getNextMesh(self) -> "std::shared_ptr< fast::Mesh >":
        r"""
        Get next frame in the data channel.
        It will block until the frame is available.
        """
        return _fast.DataChannel_getNextMesh(self)

    def getNextBoundingBox(self) -> "std::shared_ptr< fast::BoundingBox >":
        r"""
        Get next frame in the data channel.
        It will block until the frame is available.
        """
        return _fast.DataChannel_getNextBoundingBox(self)

    def getNextBoundingBoxSet(self) -> "std::shared_ptr< fast::BoundingBoxSet >":
        r"""
        Get next frame in the data channel.
        It will block until the frame is available.
        """
        return _fast.DataChannel_getNextBoundingBoxSet(self)

    def getNextText(self) -> "std::shared_ptr< fast::Text >":
        r"""
        Get next frame in the data channel.
        It will block until the frame is available.
        """
        return _fast.DataChannel_getNextText(self)
    __swig_destroy__ = _fast.delete_DataChannel

# Register DataChannel in _fast:
_fast.DataChannel_swigregister(DataChannel)

DEVICE_TYPE_ANY = _fast.DEVICE_TYPE_ANY
DEVICE_TYPE_GPU = _fast.DEVICE_TYPE_GPU
DEVICE_TYPE_CPU = _fast.DEVICE_TYPE_CPU
DEVICE_PLATFORM_ANY = _fast.DEVICE_PLATFORM_ANY
DEVICE_PLATFORM_AMD = _fast.DEVICE_PLATFORM_AMD
DEVICE_PLATFORM_NVIDIA = _fast.DEVICE_PLATFORM_NVIDIA
DEVICE_PLATFORM_INTEL = _fast.DEVICE_PLATFORM_INTEL
DEVICE_PLATFORM_APPLE = _fast.DEVICE_PLATFORM_APPLE
DEVICE_CAPABILITY_OPENGL_INTEROP = _fast.DEVICE_CAPABILITY_OPENGL_INTEROP
DEVICE_PREFERENCE_NONE = _fast.DEVICE_PREFERENCE_NONE
DEVICE_PREFERENCE_NOT_CONNECTED_TO_SCREEN = _fast.DEVICE_PREFERENCE_NOT_CONNECTED_TO_SCREEN
DEVICE_PREFERENCE_COMPUTE_UNITS = _fast.DEVICE_PREFERENCE_COMPUTE_UNITS
DEVICE_PREFERENCE_GLOBAL_MEMORY = _fast.DEVICE_PREFERENCE_GLOBAL_MEMORY
class DeviceCriteria(object):
    r"""Class used to set up a set of criteria for choosing devices"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _fast.DeviceCriteria_swiginit(self, _fast.new_DeviceCriteria())

    def setPlatformCriteria(self, platform: "fast::DevicePlatform") -> "void":
        return _fast.DeviceCriteria_setPlatformCriteria(self, platform)

    def setCapabilityCriteria(self, capability: "fast::DeviceCapability") -> "void":
        return _fast.DeviceCriteria_setCapabilityCriteria(self, capability)

    def setTypeCriteria(self, typeCriteria: "fast::DeviceType") -> "void":
        return _fast.DeviceCriteria_setTypeCriteria(self, typeCriteria)

    def setDevicePreference(self, preference: "fast::DevicePreference") -> "void":
        return _fast.DeviceCriteria_setDevicePreference(self, preference)

    def setDeviceCountCriteria(self, *args) -> "void":
        return _fast.DeviceCriteria_setDeviceCountCriteria(self, *args)

    def getCapabilityCriteria(self) -> "std::vector< fast::DeviceCapability,std::allocator< fast::DeviceCapability > > const &":
        return _fast.DeviceCriteria_getCapabilityCriteria(self)

    def getPlatformCriteria(self) -> "fast::DevicePlatform":
        return _fast.DeviceCriteria_getPlatformCriteria(self)

    def getTypeCriteria(self) -> "fast::DeviceType":
        return _fast.DeviceCriteria_getTypeCriteria(self)

    def getDevicePreference(self) -> "fast::DevicePreference":
        return _fast.DeviceCriteria_getDevicePreference(self)

    def getDeviceCountMinCriteria(self) -> "unsigned int":
        return _fast.DeviceCriteria_getDeviceCountMinCriteria(self)

    def getDeviceCountMaxCriteria(self) -> "unsigned int":
        return _fast.DeviceCriteria_getDeviceCountMaxCriteria(self)

    def hasCapabilityCriteria(self, capability: "fast::DeviceCapability") -> "bool":
        return _fast.DeviceCriteria_hasCapabilityCriteria(self, capability)
    __swig_destroy__ = _fast.delete_DeviceCriteria

# Register DeviceCriteria in _fast:
_fast.DeviceCriteria_swigregister(DeviceCriteria)

class RuntimeMeasurement(Object):
    r"""A class for a runtime measurement"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "std::string"):
        _fast.RuntimeMeasurement_swiginit(self, _fast.new_RuntimeMeasurement(name))

    def addSample(self, runtime: "double") -> "void":
        return _fast.RuntimeMeasurement_addSample(self, runtime)

    def getSum(self) -> "double":
        return _fast.RuntimeMeasurement_getSum(self)

    def getAverage(self) -> "double":
        return _fast.RuntimeMeasurement_getAverage(self)

    def getSamples(self) -> "unsigned int":
        return _fast.RuntimeMeasurement_getSamples(self)

    def getMax(self) -> "double":
        return _fast.RuntimeMeasurement_getMax(self)

    def getMin(self) -> "double":
        return _fast.RuntimeMeasurement_getMin(self)

    def getStdDeviation(self) -> "double":
        return _fast.RuntimeMeasurement_getStdDeviation(self)

    def _print(self) -> "std::string":
        return _fast.RuntimeMeasurement__print(self)
    __swig_destroy__ = _fast.delete_RuntimeMeasurement

# Register RuntimeMeasurement in _fast:
_fast.RuntimeMeasurement_swigregister(RuntimeMeasurement)

class RuntimeMeasurementsManager(Object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::RuntimeMeasurementsManager >":
        return _fast.RuntimeMeasurementsManager_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.RuntimeMeasurementsManager_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.RuntimeMeasurementsManager_getStaticNameOfClass()

    def enable(self) -> "void":
        return _fast.RuntimeMeasurementsManager_enable(self)

    def disable(self) -> "void":
        return _fast.RuntimeMeasurementsManager_disable(self)

    def isEnabled(self) -> "bool":
        return _fast.RuntimeMeasurementsManager_isEnabled(self)

    def startCLTimer(self, name: "std::string", queue: "cl::CommandQueue") -> "void":
        return _fast.RuntimeMeasurementsManager_startCLTimer(self, name, queue)

    def stopCLTimer(self, name: "std::string", queue: "cl::CommandQueue") -> "void":
        return _fast.RuntimeMeasurementsManager_stopCLTimer(self, name, queue)

    def startRegularTimer(self, name: "std::string") -> "void":
        return _fast.RuntimeMeasurementsManager_startRegularTimer(self, name)

    def stopRegularTimer(self, name: "std::string") -> "void":
        return _fast.RuntimeMeasurementsManager_stopRegularTimer(self, name)

    def startNumberedCLTimer(self, name: "std::string", queue: "cl::CommandQueue") -> "void":
        return _fast.RuntimeMeasurementsManager_startNumberedCLTimer(self, name, queue)

    def stopNumberedCLTimer(self, name: "std::string", queue: "cl::CommandQueue") -> "void":
        return _fast.RuntimeMeasurementsManager_stopNumberedCLTimer(self, name, queue)

    def startNumberedRegularTimer(self, name: "std::string") -> "void":
        return _fast.RuntimeMeasurementsManager_startNumberedRegularTimer(self, name)

    def stopNumberedRegularTimer(self, name: "std::string") -> "void":
        return _fast.RuntimeMeasurementsManager_stopNumberedRegularTimer(self, name)

    def getTiming(self, name: "std::string") -> "fast::RuntimeMeasurement::pointer":
        return _fast.RuntimeMeasurementsManager_getTiming(self, name)

    def _print(self, name: "std::string") -> "void":
        return _fast.RuntimeMeasurementsManager__print(self, name)

    def printAll(self) -> "void":
        return _fast.RuntimeMeasurementsManager_printAll(self)
    __swig_destroy__ = _fast.delete_RuntimeMeasurementsManager

# Register RuntimeMeasurementsManager in _fast:
_fast.RuntimeMeasurementsManager_swigregister(RuntimeMeasurementsManager)

def RuntimeMeasurementsManager_New() -> "std::shared_ptr< fast::RuntimeMeasurementsManager >":
    return _fast.RuntimeMeasurementsManager_New()

def RuntimeMeasurementsManager_getStaticNameOfClass() -> "std::string":
    return _fast.RuntimeMeasurementsManager_getStaticNameOfClass()

class ExecutionDevice(Object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def isHost(self) -> "bool":
        return _fast.ExecutionDevice_isHost(self)
    __swig_destroy__ = _fast.delete_ExecutionDevice

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ExecutionDevice_getStaticNameOfClass()

    def __init__(self):
        _fast.ExecutionDevice_swiginit(self, _fast.new_ExecutionDevice())

# Register ExecutionDevice in _fast:
_fast.ExecutionDevice_swigregister(ExecutionDevice)

def ExecutionDevice_getStaticNameOfClass() -> "std::string":
    return _fast.ExecutionDevice_getStaticNameOfClass()

class Host(ExecutionDevice):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def getInstance() -> "fast::Host::pointer":
        return _fast.Host_getInstance()

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Host_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_Host

# Register Host in _fast:
_fast.Host_swigregister(Host)

def Host_getInstance() -> "fast::Host::pointer":
    return _fast.Host_getInstance()

def Host_getStaticNameOfClass() -> "std::string":
    return _fast.Host_getStaticNameOfClass()

PLATFORM_VENDOR_APPLE = _fast.PLATFORM_VENDOR_APPLE
PLATFORM_VENDOR_AMD = _fast.PLATFORM_VENDOR_AMD
PLATFORM_VENDOR_INTEL = _fast.PLATFORM_VENDOR_INTEL
PLATFORM_VENDOR_NVIDIA = _fast.PLATFORM_VENDOR_NVIDIA
PLATFORM_VENDOR_UKNOWN = _fast.PLATFORM_VENDOR_UKNOWN
DEVICE_VENDOR_AMD = _fast.DEVICE_VENDOR_AMD
DEVICE_VENDOR_INTEL = _fast.DEVICE_VENDOR_INTEL
DEVICE_VENDOR_NVIDIA = _fast.DEVICE_VENDOR_NVIDIA
DEVICE_VENDOR_UKNOWN = _fast.DEVICE_VENDOR_UKNOWN
class OpenCLDevice(ExecutionDevice):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::OpenCLDevice >":
        return _fast.OpenCLDevice_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.OpenCLDevice_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.OpenCLDevice_getStaticNameOfClass()

    def getCommandQueue(self) -> "cl::CommandQueue":
        return _fast.OpenCLDevice_getCommandQueue(self)

    def createProgramFromSource(self, *args) -> "int":
        return _fast.OpenCLDevice_createProgramFromSource(self, *args)

    def createProgramFromString(self, *args) -> "int":
        return _fast.OpenCLDevice_createProgramFromString(self, *args)

    def createProgramFromSourceWithName(self, *args) -> "int":
        return _fast.OpenCLDevice_createProgramFromSourceWithName(self, *args)

    def createProgramFromStringWithName(self, *args) -> "int":
        return _fast.OpenCLDevice_createProgramFromStringWithName(self, *args)

    def getProgram(self, *args) -> "cl::Program":
        return _fast.OpenCLDevice_getProgram(self, *args)

    def hasProgram(self, name: "std::string") -> "bool":
        return _fast.OpenCLDevice_hasProgram(self, name)

    def isImageFormatSupported(self, order: "cl_channel_order", type: "cl_channel_type", imageType: "cl_mem_object_type") -> "bool":
        return _fast.OpenCLDevice_isImageFormatSupported(self, order, type, imageType)

    def isOpenGLInteropSupported(self) -> "bool":
        return _fast.OpenCLDevice_isOpenGLInteropSupported(self)

    def getQueue(self, i: "unsigned int") -> "cl::CommandQueue":
        return _fast.OpenCLDevice_getQueue(self, i)

    def getContext(self) -> "cl::Context":
        return _fast.OpenCLDevice_getContext(self)

    def getPlatform(self) -> "cl::Platform":
        return _fast.OpenCLDevice_getPlatform(self)

    def __init__(self, devices: "std::vector< cl::Device,std::allocator< cl::Device > >", glContext: "unsigned long *"=None):
        _fast.OpenCLDevice_swiginit(self, _fast.new_OpenCLDevice(devices, glContext))

    def getGLContext(self) -> "unsigned long *":
        return _fast.OpenCLDevice_getGLContext(self)

    def getName(self) -> "std::string":
        return _fast.OpenCLDevice_getName(self)

    def isWritingTo3DTexturesSupported(self) -> "bool":
        return _fast.OpenCLDevice_isWritingTo3DTexturesSupported(self)

    def getRunTimeMeasurementManager(self) -> "fast::RuntimeMeasurementsManager::pointer":
        return _fast.OpenCLDevice_getRunTimeMeasurementManager(self)
    __swig_destroy__ = _fast.delete_OpenCLDevice

# Register OpenCLDevice in _fast:
_fast.OpenCLDevice_swigregister(OpenCLDevice)

def OpenCLDevice_New() -> "std::shared_ptr< fast::OpenCLDevice >":
    return _fast.OpenCLDevice_New()

def OpenCLDevice_getStaticNameOfClass() -> "std::string":
    return _fast.OpenCLDevice_getStaticNameOfClass()

ATTRIBUTE_TYPE_STRING = _fast.ATTRIBUTE_TYPE_STRING
ATTRIBUTE_TYPE_FLOAT = _fast.ATTRIBUTE_TYPE_FLOAT
ATTRIBUTE_TYPE_INTEGER = _fast.ATTRIBUTE_TYPE_INTEGER
ATTRIBUTE_TYPE_BOOLEAN = _fast.ATTRIBUTE_TYPE_BOOLEAN
class AttributeValue(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _fast.delete_AttributeValue

    def __init__(self):
        _fast.AttributeValue_swiginit(self, _fast.new_AttributeValue())

# Register AttributeValue in _fast:
_fast.AttributeValue_swigregister(AttributeValue)

class AttributeValueString(AttributeValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, value: "std::string"):
        _fast.AttributeValueString_swiginit(self, _fast.new_AttributeValueString(value))

    def get(self) -> "std::string":
        return _fast.AttributeValueString_get(self)
    __swig_destroy__ = _fast.delete_AttributeValueString

# Register AttributeValueString in _fast:
_fast.AttributeValueString_swigregister(AttributeValueString)

class AttributeValueFloat(AttributeValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, value: "float"):
        _fast.AttributeValueFloat_swiginit(self, _fast.new_AttributeValueFloat(value))

    def get(self) -> "float":
        return _fast.AttributeValueFloat_get(self)
    __swig_destroy__ = _fast.delete_AttributeValueFloat

# Register AttributeValueFloat in _fast:
_fast.AttributeValueFloat_swigregister(AttributeValueFloat)

class AttributeValueInteger(AttributeValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, value: "int"):
        _fast.AttributeValueInteger_swiginit(self, _fast.new_AttributeValueInteger(value))

    def get(self) -> "int":
        return _fast.AttributeValueInteger_get(self)
    __swig_destroy__ = _fast.delete_AttributeValueInteger

# Register AttributeValueInteger in _fast:
_fast.AttributeValueInteger_swigregister(AttributeValueInteger)

class AttributeValueBoolean(AttributeValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, value: "bool"):
        _fast.AttributeValueBoolean_swiginit(self, _fast.new_AttributeValueBoolean(value))

    def get(self) -> "bool":
        return _fast.AttributeValueBoolean_get(self)
    __swig_destroy__ = _fast.delete_AttributeValueBoolean

# Register AttributeValueBoolean in _fast:
_fast.AttributeValueBoolean_swigregister(AttributeValueBoolean)

class Attribute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, id: "std::string", name: "std::string", description: "std::string", type: "fast::AttributeType"):
        _fast.Attribute_swiginit(self, _fast.new_Attribute(id, name, description, type))

    def setValue(self, value: "std::shared_ptr< fast::AttributeValue >") -> "void":
        return _fast.Attribute_setValue(self, value)

    def getValue(self) -> "std::shared_ptr< fast::AttributeValue >":
        return _fast.Attribute_getValue(self)

    def setValues(self, values: "std::vector< std::shared_ptr< fast::AttributeValue >,std::allocator< std::shared_ptr< fast::AttributeValue > > >") -> "void":
        return _fast.Attribute_setValues(self, values)

    def getValues(self) -> "std::vector< std::shared_ptr< fast::AttributeValue >,std::allocator< std::shared_ptr< fast::AttributeValue > > >":
        return _fast.Attribute_getValues(self)

    def getName(self) -> "std::string":
        return _fast.Attribute_getName(self)

    def getID(self) -> "std::string":
        return _fast.Attribute_getID(self)

    def getType(self) -> "fast::AttributeType":
        return _fast.Attribute_getType(self)

    def parseInput(self, input: "std::string") -> "void":
        return _fast.Attribute_parseInput(self, input)
    __swig_destroy__ = _fast.delete_Attribute

# Register Attribute in _fast:
_fast.Attribute_swigregister(Attribute)

class ProcessObject(Object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fast.delete_ProcessObject

    def update(self, executeToken: "int"=-1) -> "void":
        r"""
        Do update on this PO, which will trigger update on all connected POs.
        An optional executeToken can be used to synchronize updating to avoid
        duplicate execution for the same frames when using streaming.
        Increment the token for every timestep with a positive value.

        :type executeToken: int
        :param executeToken: Negative value means that the execute token is disabled.
        """
        return _fast.ProcessObject_update(self, executeToken)

    def getRuntime(self, *args) -> "fast::RuntimeMeasurement::pointer":
        return _fast.ProcessObject_getRuntime(self, *args)

    def getAllRuntimes(self) -> "fast::RuntimeMeasurementsManager::pointer":
        return _fast.ProcessObject_getAllRuntimes(self)

    def enableRuntimeMeasurements(self) -> "void":
        return _fast.ProcessObject_enableRuntimeMeasurements(self)

    def disableRuntimeMeasurements(self) -> "void":
        return _fast.ProcessObject_disableRuntimeMeasurements(self)

    def setMainDevice(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.ProcessObject_setMainDevice(self, device)

    def setMainDeviceCriteria(self, citeria: "DeviceCriteria") -> "void":
        return _fast.ProcessObject_setMainDeviceCriteria(self, citeria)

    def getMainDevice(self) -> "fast::ExecutionDevice::pointer":
        return _fast.ProcessObject_getMainDevice(self)

    def setDevice(self, deviceNumber: "uint", device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.ProcessObject_setDevice(self, deviceNumber, device)

    def setDeviceCriteria(self, deviceNumber: "uint", criteria: "DeviceCriteria") -> "void":
        return _fast.ProcessObject_setDeviceCriteria(self, deviceNumber, criteria)

    def getOutputPort(self, portID: "uint"=0) -> "fast::DataChannel::pointer":
        return _fast.ProcessObject_getOutputPort(self, portID)

    def getInputPort(self, portID: "uint"=0) -> "fast::DataChannel::pointer":
        return _fast.ProcessObject_getInputPort(self, portID)

    def setInputConnection(self, *args) -> "void":
        return _fast.ProcessObject_setInputConnection(self, *args)

    def setInputData(self, *args) -> "void":
        return _fast.ProcessObject_setInputData(self, *args)

    def getNrOfInputConnections(self) -> "int":
        return _fast.ProcessObject_getNrOfInputConnections(self)

    def getNrOfOutputPorts(self) -> "int":
        return _fast.ProcessObject_getNrOfOutputPorts(self)

    def getNameOfClass(self) -> "std::string":
        return _fast.ProcessObject_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ProcessObject_getStaticNameOfClass()

    def loadAttributes(self) -> "void":
        return _fast.ProcessObject_loadAttributes(self)

    def getAttribute(self, id: "std::string") -> "std::shared_ptr< fast::Attribute >":
        return _fast.ProcessObject_getAttribute(self, id)

    def getAttributes(self) -> "std::unordered_map< std::string,std::shared_ptr< fast::Attribute > >":
        return _fast.ProcessObject_getAttributes(self)

    def setAttributes(self, attributes: "std::vector< std::shared_ptr< fast::Attribute >,std::allocator< std::shared_ptr< fast::Attribute > > >") -> "void":
        return _fast.ProcessObject_setAttributes(self, attributes)

    def stopPipeline(self) -> "void":
        r"""Used to stop a pipeline."""
        return _fast.ProcessObject_stopPipeline(self)

    def setModified(self, modified: "bool") -> "void":
        return _fast.ProcessObject_setModified(self, modified)

    def updateAndGetOutputImage(self, portID: "uint"=0) -> "std::shared_ptr< fast::Image >":
        return _fast.ProcessObject_updateAndGetOutputImage(self, portID)

    def updateAndGetOutputImagePyramid(self, portID: "uint"=0) -> "std::shared_ptr< fast::ImagePyramid >":
        return _fast.ProcessObject_updateAndGetOutputImagePyramid(self, portID)

    def updateAndGetOutputSegmentation(self, portID: "uint"=0) -> "std::shared_ptr< fast::Segmentation >":
        return _fast.ProcessObject_updateAndGetOutputSegmentation(self, portID)

    def updateAndGetOutputTensor(self, portID: "uint"=0) -> "std::shared_ptr< fast::Tensor >":
        return _fast.ProcessObject_updateAndGetOutputTensor(self, portID)

    def updateAndGetOutputMesh(self, portID: "uint"=0) -> "std::shared_ptr< fast::Mesh >":
        return _fast.ProcessObject_updateAndGetOutputMesh(self, portID)

    def updateAndGetOutputBoundingBox(self, portID: "uint"=0) -> "std::shared_ptr< fast::BoundingBox >":
        return _fast.ProcessObject_updateAndGetOutputBoundingBox(self, portID)

    def updateAndGetOutputBoundingBoxSet(self, portID: "uint"=0) -> "std::shared_ptr< fast::BoundingBoxSet >":
        return _fast.ProcessObject_updateAndGetOutputBoundingBoxSet(self, portID)

    def updateAndGetOutputText(self, portID: "uint"=0) -> "std::shared_ptr< fast::Text >":
        return _fast.ProcessObject_updateAndGetOutputText(self, portID)

# Register ProcessObject in _fast:
_fast.ProcessObject_swigregister(ProcessObject)

def ProcessObject_getStaticNameOfClass() -> "std::string":
    return _fast.ProcessObject_getStaticNameOfClass()


def downloadTestDataIfNotExists(*args) -> "void":
    return _fast.downloadTestDataIfNotExists(*args)
class Config(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def getTestDataPath() -> "std::string":
        return _fast.Config_getTestDataPath()

    @staticmethod
    def getKernelSourcePath() -> "std::string":
        return _fast.Config_getKernelSourcePath()

    @staticmethod
    def getKernelBinaryPath() -> "std::string":
        return _fast.Config_getKernelBinaryPath()

    @staticmethod
    def getDocumentationPath() -> "std::string":
        return _fast.Config_getDocumentationPath()

    @staticmethod
    def getPipelinePath() -> "std::string":
        return _fast.Config_getPipelinePath()

    @staticmethod
    def getLibraryPath() -> "std::string":
        return _fast.Config_getLibraryPath()

    @staticmethod
    def getQtPluginsPath() -> "std::string":
        return _fast.Config_getQtPluginsPath()

    @staticmethod
    def getStreamingMode() -> "fast::StreamingMode":
        return _fast.Config_getStreamingMode()

    @staticmethod
    def setStreamingMode(mode: "fast::StreamingMode") -> "void":
        return _fast.Config_setStreamingMode(mode)

    @staticmethod
    def setTestDataPath(path: "std::string") -> "void":
        return _fast.Config_setTestDataPath(path)

    @staticmethod
    def setKernelSourcePath(path: "std::string") -> "void":
        return _fast.Config_setKernelSourcePath(path)

    @staticmethod
    def setKernelBinaryPath(path: "std::string") -> "void":
        return _fast.Config_setKernelBinaryPath(path)

    @staticmethod
    def setDocumentationPath(path: "std::string") -> "void":
        return _fast.Config_setDocumentationPath(path)

    @staticmethod
    def setPipelinePath(path: "std::string") -> "void":
        return _fast.Config_setPipelinePath(path)

    @staticmethod
    def setConfigFilename(filename: "std::string") -> "void":
        return _fast.Config_setConfigFilename(filename)

    @staticmethod
    def setBasePath(path: "std::string") -> "void":
        return _fast.Config_setBasePath(path)

    def __init__(self):
        _fast.Config_swiginit(self, _fast.new_Config())

# Register Config in _fast:
_fast.Config_swigregister(Config)

def Config_getTestDataPath() -> "std::string":
    return _fast.Config_getTestDataPath()

def Config_getKernelSourcePath() -> "std::string":
    return _fast.Config_getKernelSourcePath()

def Config_getKernelBinaryPath() -> "std::string":
    return _fast.Config_getKernelBinaryPath()

def Config_getDocumentationPath() -> "std::string":
    return _fast.Config_getDocumentationPath()

def Config_getPipelinePath() -> "std::string":
    return _fast.Config_getPipelinePath()

def Config_getLibraryPath() -> "std::string":
    return _fast.Config_getLibraryPath()

def Config_getQtPluginsPath() -> "std::string":
    return _fast.Config_getQtPluginsPath()

def Config_getStreamingMode() -> "fast::StreamingMode":
    return _fast.Config_getStreamingMode()

def Config_setStreamingMode(mode: "fast::StreamingMode") -> "void":
    return _fast.Config_setStreamingMode(mode)

def Config_setTestDataPath(path: "std::string") -> "void":
    return _fast.Config_setTestDataPath(path)

def Config_setKernelSourcePath(path: "std::string") -> "void":
    return _fast.Config_setKernelSourcePath(path)

def Config_setKernelBinaryPath(path: "std::string") -> "void":
    return _fast.Config_setKernelBinaryPath(path)

def Config_setDocumentationPath(path: "std::string") -> "void":
    return _fast.Config_setDocumentationPath(path)

def Config_setPipelinePath(path: "std::string") -> "void":
    return _fast.Config_setPipelinePath(path)

def Config_setConfigFilename(filename: "std::string") -> "void":
    return _fast.Config_setConfigFilename(filename)

def Config_setBasePath(path: "std::string") -> "void":
    return _fast.Config_setBasePath(path)

TYPE_FLOAT = _fast.TYPE_FLOAT
TYPE_UINT8 = _fast.TYPE_UINT8
TYPE_INT8 = _fast.TYPE_INT8
TYPE_UINT16 = _fast.TYPE_UINT16
TYPE_INT16 = _fast.TYPE_INT16
TYPE_UNORM_INT16 = _fast.TYPE_UNORM_INT16
TYPE_SNORM_INT16 = _fast.TYPE_SNORM_INT16
PLANE_X = _fast.PLANE_X
PLANE_Y = _fast.PLANE_Y
PLANE_Z = _fast.PLANE_Z

def getCTypeAsString(type: "fast::DataType") -> "std::string":
    return _fast.getCTypeAsString(type)

def getOpenCLImageFormat(arg1: "fast::OpenCLDevice::pointer", imageType: "cl_mem_object_type", type: "fast::DataType", channels: "unsigned int") -> "cl::ImageFormat":
    return _fast.getOpenCLImageFormat(arg1, imageType, type, channels)

def getSizeOfDataType(type: "fast::DataType", nrOfChannels: "unsigned int") -> "size_t":
    return _fast.getSizeOfDataType(type, nrOfChannels)

def getDefaultIntensityLevel(type: "fast::DataType") -> "float":
    return _fast.getDefaultIntensityLevel(type)

def getDefaultIntensityWindow(type: "fast::DataType") -> "float":
    return _fast.getDefaultIntensityWindow(type)

def deleteArray(data: "void *", type: "fast::DataType") -> "void":
    return _fast.deleteArray(data, type)
class Color(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _fast.Color_swiginit(self, _fast.new_Color(*args))

    @staticmethod
    def fromString(str: "std::string") -> "fast::Color":
        return _fast.Color_fromString(str)

    def asVector(self) -> "Vector3f":
        return _fast.Color_asVector(self)

    def getRedValue(self) -> "float":
        return _fast.Color_getRedValue(self)

    def getGreenValue(self) -> "float":
        return _fast.Color_getGreenValue(self)

    def getBlueValue(self) -> "float":
        return _fast.Color_getBlueValue(self)

    @staticmethod
    def Red() -> "fast::Color":
        return _fast.Color_Red()

    @staticmethod
    def Green() -> "fast::Color":
        return _fast.Color_Green()

    @staticmethod
    def Blue() -> "fast::Color":
        return _fast.Color_Blue()

    @staticmethod
    def White() -> "fast::Color":
        return _fast.Color_White()

    @staticmethod
    def Black() -> "fast::Color":
        return _fast.Color_Black()

    @staticmethod
    def Yellow() -> "fast::Color":
        return _fast.Color_Yellow()

    @staticmethod
    def Magenta() -> "fast::Color":
        return _fast.Color_Magenta()

    @staticmethod
    def Cyan() -> "fast::Color":
        return _fast.Color_Cyan()

    @staticmethod
    def Brown() -> "fast::Color":
        return _fast.Color_Brown()
    __swig_destroy__ = _fast.delete_Color

# Register Color in _fast:
_fast.Color_swigregister(Color)

def Color_fromString(str: "std::string") -> "fast::Color":
    return _fast.Color_fromString(str)

def Color_Red() -> "fast::Color":
    return _fast.Color_Red()

def Color_Green() -> "fast::Color":
    return _fast.Color_Green()

def Color_Blue() -> "fast::Color":
    return _fast.Color_Blue()

def Color_White() -> "fast::Color":
    return _fast.Color_White()

def Color_Black() -> "fast::Color":
    return _fast.Color_Black()

def Color_Yellow() -> "fast::Color":
    return _fast.Color_Yellow()

def Color_Magenta() -> "fast::Color":
    return _fast.Color_Magenta()

def Color_Cyan() -> "fast::Color":
    return _fast.Color_Cyan()

def Color_Brown() -> "fast::Color":
    return _fast.Color_Brown()

class SpatialDataObject(DataObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getBoundingBox(self) -> "DataBoundingBox":
        return _fast.SpatialDataObject_getBoundingBox(self)

    def getTransformedBoundingBox(self) -> "DataBoundingBox":
        return _fast.SpatialDataObject_getTransformedBoundingBox(self)

    def getSceneGraphNode(self) -> "SceneGraphNode::pointer":
        return _fast.SpatialDataObject_getSceneGraphNode(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SpatialDataObject_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_SpatialDataObject

# Register SpatialDataObject in _fast:
_fast.SpatialDataObject_swigregister(SpatialDataObject)

def SpatialDataObject_getStaticNameOfClass() -> "std::string":
    return _fast.SpatialDataObject_getStaticNameOfClass()

class OpenCLImageAccess(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def get(self) -> "cl::Image *":
        return _fast.OpenCLImageAccess_get(self)

    def get2DImage(self) -> "cl::Image2D *":
        return _fast.OpenCLImageAccess_get2DImage(self)

    def get3DImage(self) -> "cl::Image3D *":
        return _fast.OpenCLImageAccess_get3DImage(self)

    def __init__(self, *args):
        _fast.OpenCLImageAccess_swiginit(self, _fast.new_OpenCLImageAccess(*args))

    def release(self) -> "void":
        return _fast.OpenCLImageAccess_release(self)
    __swig_destroy__ = _fast.delete_OpenCLImageAccess

# Register OpenCLImageAccess in _fast:
_fast.OpenCLImageAccess_swigregister(OpenCLImageAccess)

class OpenCLBufferAccess(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def get(self) -> "cl::Buffer *":
        return _fast.OpenCLBufferAccess_get(self)

    def __init__(self, buffer: "cl::Buffer *", dataObject: "std::shared_ptr< fast::DataObject >"):
        _fast.OpenCLBufferAccess_swiginit(self, _fast.new_OpenCLBufferAccess(buffer, dataObject))

    def release(self) -> "void":
        return _fast.OpenCLBufferAccess_release(self)
    __swig_destroy__ = _fast.delete_OpenCLBufferAccess

# Register OpenCLBufferAccess in _fast:
_fast.OpenCLBufferAccess_swigregister(OpenCLBufferAccess)

class ImageAccess(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, data: "void *", image: "std::shared_ptr< fast::Image >"):
        _fast.ImageAccess_swiginit(self, _fast.new_ImageAccess(data, image))

    def get(self) -> "void *":
        return _fast.ImageAccess_get(self)

    def getScalar(self, *args) -> "float":
        return _fast.ImageAccess_getScalar(self, *args)

    def getVector(self, position: "VectorXi") -> "Vector4f":
        return _fast.ImageAccess_getVector(self, position)

    def setScalar(self, *args) -> "void":
        return _fast.ImageAccess_setScalar(self, *args)

    def setVector(self, *args) -> "void":
        return _fast.ImageAccess_setVector(self, *args)

    def release(self) -> "void":
        return _fast.ImageAccess_release(self)
    __swig_destroy__ = _fast.delete_ImageAccess

# Register ImageAccess in _fast:
_fast.ImageAccess_swigregister(ImageAccess)

class BoundingBoxSetAccess(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, coordinates: "vectorf", lines: "std::vector< uint,std::allocator< uint > > *", labels: "std::vector< uchar,std::allocator< uchar > > *", scores: "vectorf", bbset: "std::shared_ptr< fast::BoundingBoxSet >"):
        _fast.BoundingBoxSetAccess_swiginit(self, _fast.new_BoundingBoxSetAccess(coordinates, lines, labels, scores, bbset))

    def addBoundingBox(self, *args) -> "void":
        return _fast.BoundingBoxSetAccess_addBoundingBox(self, *args)

    def getCoordinates(self) -> "std::vector< float,std::allocator< float > >":
        return _fast.BoundingBoxSetAccess_getCoordinates(self)

    def getLines(self) -> "std::vector< uint,std::allocator< uint > >":
        return _fast.BoundingBoxSetAccess_getLines(self)

    def getLabels(self) -> "std::vector< uchar,std::allocator< uchar > >":
        return _fast.BoundingBoxSetAccess_getLabels(self)

    def getScores(self) -> "std::vector< float,std::allocator< float > >":
        return _fast.BoundingBoxSetAccess_getScores(self)

    def addBoundingBoxes(self, coordinates: "vectorf", lines: "std::vector< uint,std::allocator< uint > >", labels: "std::vector< uchar,std::allocator< uchar > >", scores: "vectorf") -> "void":
        return _fast.BoundingBoxSetAccess_addBoundingBoxes(self, coordinates, lines, labels, scores)

    def release(self) -> "void":
        return _fast.BoundingBoxSetAccess_release(self)
    __swig_destroy__ = _fast.delete_BoundingBoxSetAccess

# Register BoundingBoxSetAccess in _fast:
_fast.BoundingBoxSetAccess_swigregister(BoundingBoxSetAccess)

class BoundingBoxSetOpenGLAccess(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, m_coordinatesVBO: "GLuint", m_linesEBO: "GLuint", m_labels: "GLuint", bbset: "std::shared_ptr< fast::BoundingBoxSet >"):
        _fast.BoundingBoxSetOpenGLAccess_swiginit(self, _fast.new_BoundingBoxSetOpenGLAccess(m_coordinatesVBO, m_linesEBO, m_labels, bbset))

    def getCoordinateVBO(self) -> "GLuint":
        return _fast.BoundingBoxSetOpenGLAccess_getCoordinateVBO(self)

    def getLinesEBO(self) -> "GLuint":
        return _fast.BoundingBoxSetOpenGLAccess_getLinesEBO(self)

    def getLabelVBO(self) -> "GLuint":
        return _fast.BoundingBoxSetOpenGLAccess_getLabelVBO(self)

    def release(self) -> "void":
        return _fast.BoundingBoxSetOpenGLAccess_release(self)
    __swig_destroy__ = _fast.delete_BoundingBoxSetOpenGLAccess

# Register BoundingBoxSetOpenGLAccess in _fast:
_fast.BoundingBoxSetOpenGLAccess_swigregister(BoundingBoxSetOpenGLAccess)

class Plane(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _fast.Plane_swiginit(self, _fast.new_Plane(*args))

    def setPosition(self, position: "Vector3f") -> "void":
        return _fast.Plane_setPosition(self, position)

    def setNormal(self, normal: "Vector3f") -> "void":
        return _fast.Plane_setNormal(self, normal)

    def getPosition(self) -> "Vector3f":
        return _fast.Plane_getPosition(self)

    def getNormal(self) -> "Vector3f":
        return _fast.Plane_getNormal(self)

    def getIntersectionPoint(self, pointA: "Vector3f", pointB: "Vector3f") -> "Vector3f":
        return _fast.Plane_getIntersectionPoint(self, pointA, pointB)

    def hasPosition(self) -> "bool":
        return _fast.Plane_hasPosition(self)

    @staticmethod
    def Sagittal() -> "fast::Plane":
        return _fast.Plane_Sagittal()

    @staticmethod
    def Coronal() -> "fast::Plane":
        return _fast.Plane_Coronal()

    @staticmethod
    def Axial() -> "fast::Plane":
        return _fast.Plane_Axial()
    __swig_destroy__ = _fast.delete_Plane

# Register Plane in _fast:
_fast.Plane_swigregister(Plane)

def Plane_Sagittal() -> "fast::Plane":
    return _fast.Plane_Sagittal()

def Plane_Coronal() -> "fast::Plane":
    return _fast.Plane_Coronal()

def Plane_Axial() -> "fast::Plane":
    return _fast.Plane_Axial()

class NoMoreFramesException(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message: "std::string"):
        _fast.NoMoreFramesException_swiginit(self, _fast.new_NoMoreFramesException(message))
    __swig_destroy__ = _fast.delete_NoMoreFramesException

# Register NoMoreFramesException in _fast:
_fast.NoMoreFramesException_swigregister(NoMoreFramesException)

class Streamer(ProcessObject):
    r"""A streamer is a PO that runs a separate thread of execution which produces data"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fast.delete_Streamer

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Streamer_getStaticNameOfClass()

    def getNameOfClass(self) -> "std::string":
        return _fast.Streamer_getNameOfClass(self)

    def stop(self) -> "void":
        r"""Stop the stream"""
        return _fast.Streamer_stop(self)

    def setMaximumNrOfFrames(self, maximumNrOfFrames: "int") -> "void":
        return _fast.Streamer_setMaximumNrOfFrames(self, maximumNrOfFrames)

# Register Streamer in _fast:
_fast.Streamer_swigregister(Streamer)

def Streamer_getStaticNameOfClass() -> "std::string":
    return _fast.Streamer_getStaticNameOfClass()

class FileStreamer(Streamer):
    r"""Abstract FileStreamer class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setFilenameFormat(self, str: "std::string") -> "void":
        return _fast.FileStreamer_setFilenameFormat(self, str)

    def setFilenameFormats(self, strings: "std::vector< std::string,std::allocator< std::string > >") -> "void":
        return _fast.FileStreamer_setFilenameFormats(self, strings)

    def setStartNumber(self, startNumber: "uint") -> "void":
        return _fast.FileStreamer_setStartNumber(self, startNumber)

    def setStepSize(self, step: "uint") -> "void":
        return _fast.FileStreamer_setStepSize(self, step)

    def setZeroFilling(self, digits: "uint") -> "void":
        return _fast.FileStreamer_setZeroFilling(self, digits)

    def setNumberOfReplays(self, replays: "uint") -> "void":
        return _fast.FileStreamer_setNumberOfReplays(self, replays)

    def setMaximumNumberOfFrames(self, nrOfFrames: "uint") -> "void":
        return _fast.FileStreamer_setMaximumNumberOfFrames(self, nrOfFrames)

    def setTimestampFilename(self, filepath: "std::string") -> "void":
        return _fast.FileStreamer_setTimestampFilename(self, filepath)

    def enableLooping(self) -> "void":
        return _fast.FileStreamer_enableLooping(self)

    def disableLooping(self) -> "void":
        return _fast.FileStreamer_disableLooping(self)

    def setSleepTime(self, milliseconds: "uint") -> "void":
        r"""Set a sleep time after each frame is read"""
        return _fast.FileStreamer_setSleepTime(self, milliseconds)

    def getNrOfFrames(self) -> "int":
        return _fast.FileStreamer_getNrOfFrames(self)

    def setUseTimestamp(self, use: "bool") -> "void":
        r"""
        Enable or disable the use of timestamps when streaming files.

        :type use: boolean
        :param use:
        """
        return _fast.FileStreamer_setUseTimestamp(self, use)
    __swig_destroy__ = _fast.delete_FileStreamer

    def getNameOfClass(self) -> "std::string":
        return _fast.FileStreamer_getNameOfClass(self)

    def loadAttributes(self) -> "void":
        return _fast.FileStreamer_loadAttributes(self)

# Register FileStreamer in _fast:
_fast.FileStreamer_swigregister(FileStreamer)

class MeshFileStreamer(FileStreamer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MeshFileStreamer >":
        return _fast.MeshFileStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MeshFileStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MeshFileStreamer_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_MeshFileStreamer

# Register MeshFileStreamer in _fast:
_fast.MeshFileStreamer_swigregister(MeshFileStreamer)

def MeshFileStreamer_New() -> "std::shared_ptr< fast::MeshFileStreamer >":
    return _fast.MeshFileStreamer_New()

def MeshFileStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.MeshFileStreamer_getStaticNameOfClass()

class RandomAccessStreamer(Streamer):
    r"""A streamer in which any frame can be accessed at any time through an integer index and playbacked can be paused."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setPause(self, pause: "bool") -> "void":
        return _fast.RandomAccessStreamer_setPause(self, pause)

    def getPause(self) -> "bool":
        return _fast.RandomAccessStreamer_getPause(self)

    def getCurrentFrameIndex(self) -> "int":
        return _fast.RandomAccessStreamer_getCurrentFrameIndex(self)

    def setCurrentFrameIndex(self, index: "int") -> "void":
        return _fast.RandomAccessStreamer_setCurrentFrameIndex(self, index)

    def getCurrentFrameIndexAndUpdate(self) -> "int":
        return _fast.RandomAccessStreamer_getCurrentFrameIndexAndUpdate(self)

    def getFramerate(self) -> "int":
        return _fast.RandomAccessStreamer_getFramerate(self)

    def setFramerate(self, framerate: "int") -> "void":
        return _fast.RandomAccessStreamer_setFramerate(self, framerate)

    def getNrOfFrames(self) -> "int":
        return _fast.RandomAccessStreamer_getNrOfFrames(self)

    def stop(self) -> "void":
        return _fast.RandomAccessStreamer_stop(self)

    def setLooping(self, loop: "bool") -> "void":
        return _fast.RandomAccessStreamer_setLooping(self, loop)

    def frameAdded(self) -> "void":
        return _fast.RandomAccessStreamer_frameAdded(self)
    __swig_destroy__ = _fast.delete_RandomAccessStreamer

# Register RandomAccessStreamer in _fast:
_fast.RandomAccessStreamer_swigregister(RandomAccessStreamer)

class ImageFileStreamer(FileStreamer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageFileStreamer >":
        return _fast.ImageFileStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageFileStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageFileStreamer_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_ImageFileStreamer

# Register ImageFileStreamer in _fast:
_fast.ImageFileStreamer_swigregister(ImageFileStreamer)

def ImageFileStreamer_New() -> "std::shared_ptr< fast::ImageFileStreamer >":
    return _fast.ImageFileStreamer_New()

def ImageFileStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.ImageFileStreamer_getStaticNameOfClass()

class OpenIGTLinkStreamer(Streamer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::OpenIGTLinkStreamer >":
        return _fast.OpenIGTLinkStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.OpenIGTLinkStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.OpenIGTLinkStreamer_getStaticNameOfClass()

    def getImageStreamNames(self) -> "std::set< std::string >":
        return _fast.OpenIGTLinkStreamer_getImageStreamNames(self)

    def getTransformStreamNames(self) -> "std::set< std::string >":
        return _fast.OpenIGTLinkStreamer_getTransformStreamNames(self)

    def getActiveImageStreamNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _fast.OpenIGTLinkStreamer_getActiveImageStreamNames(self)

    def getActiveTransformStreamNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _fast.OpenIGTLinkStreamer_getActiveTransformStreamNames(self)

    def getStreamDescription(self, streamName: "std::string") -> "std::string":
        return _fast.OpenIGTLinkStreamer_getStreamDescription(self, streamName)

    def setConnectionAddress(self, address: "std::string") -> "void":
        return _fast.OpenIGTLinkStreamer_setConnectionAddress(self, address)

    def setConnectionPort(self, port: "uint") -> "void":
        return _fast.OpenIGTLinkStreamer_setConnectionPort(self, port)

    def getNrOfFrames(self) -> "uint":
        return _fast.OpenIGTLinkStreamer_getNrOfFrames(self)

    def getOutputPort(self, portID: "uint"=0) -> "fast::DataChannel::pointer":
        r"""
        Will select first image stream
        :rtype: :py:class:`DataChannel`
        :return: 
        """
        return _fast.OpenIGTLinkStreamer_getOutputPort(self, portID)

    def generateStream(self) -> "void":
        r"""
        This method runs in a separate thread and adds frames to the
        output object
        """
        return _fast.OpenIGTLinkStreamer_generateStream(self)
    __swig_destroy__ = _fast.delete_OpenIGTLinkStreamer

    def loadAttributes(self) -> "void":
        return _fast.OpenIGTLinkStreamer_loadAttributes(self)

# Register OpenIGTLinkStreamer in _fast:
_fast.OpenIGTLinkStreamer_swigregister(OpenIGTLinkStreamer)

def OpenIGTLinkStreamer_New() -> "std::shared_ptr< fast::OpenIGTLinkStreamer >":
    return _fast.OpenIGTLinkStreamer_New()

def OpenIGTLinkStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.OpenIGTLinkStreamer_getStaticNameOfClass()

class MovieStreamer(Streamer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MovieStreamer >":
        return _fast.MovieStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MovieStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MovieStreamer_getStaticNameOfClass()

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.MovieStreamer_setFilename(self, filename)

    def getFilename(self) -> "std::string":
        return _fast.MovieStreamer_getFilename(self)

    def hasReachedEnd(self) -> "bool":
        return _fast.MovieStreamer_hasReachedEnd(self)

    def addNewImageFrame(self, data: "uchar const *", width: "int", height: "int") -> "void":
        return _fast.MovieStreamer_addNewImageFrame(self, data, width, height)

    def setGrayscale(self, grayscale: "bool") -> "void":
        return _fast.MovieStreamer_setGrayscale(self, grayscale)

    def getGrayscale(self) -> "bool":
        return _fast.MovieStreamer_getGrayscale(self)

    def setFinished(self, finished: "bool") -> "void":
        return _fast.MovieStreamer_setFinished(self, finished)

    def getFramesAdded(self) -> "int":
        return _fast.MovieStreamer_getFramesAdded(self)
    __swig_destroy__ = _fast.delete_MovieStreamer

    def loadAttributes(self) -> "void":
        return _fast.MovieStreamer_loadAttributes(self)

    def addLastFrame(self) -> "void":
        return _fast.MovieStreamer_addLastFrame(self)

# Register MovieStreamer in _fast:
_fast.MovieStreamer_swigregister(MovieStreamer)

def MovieStreamer_New() -> "std::shared_ptr< fast::MovieStreamer >":
    return _fast.MovieStreamer_New()

def MovieStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.MovieStreamer_getStaticNameOfClass()

class CameraStreamer(Streamer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::CameraStreamer >":
        return _fast.CameraStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.CameraStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.CameraStreamer_getStaticNameOfClass()

    def setFinished(self, finished: "bool") -> "void":
        return _fast.CameraStreamer_setFinished(self, finished)

    def addNewImageFrame(self, data: "uchar const *", width: "int", height: "int") -> "void":
        return _fast.CameraStreamer_addNewImageFrame(self, data, width, height)

    def getGrayscale(self) -> "bool":
        return _fast.CameraStreamer_getGrayscale(self)

    def setGrayscale(self, grayscale: "bool") -> "void":
        return _fast.CameraStreamer_setGrayscale(self, grayscale)

    def loadAttributes(self) -> "void":
        return _fast.CameraStreamer_loadAttributes(self)

    def setCamera(self, index: "uchar") -> "void":
        return _fast.CameraStreamer_setCamera(self, index)
    __swig_destroy__ = _fast.delete_CameraStreamer

# Register CameraStreamer in _fast:
_fast.CameraStreamer_swigregister(CameraStreamer)

def CameraStreamer_New() -> "std::shared_ptr< fast::CameraStreamer >":
    return _fast.CameraStreamer_New()

def CameraStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.CameraStreamer_getStaticNameOfClass()

class RealSenseStreamer(Streamer):
    r"""
    Streams data RGB and depth data from a kinect device.

    The RGB camera and depth stream are registered so that a color value for each point in the
    point cloud is established.

    Output port 0: Registered RGB image
    Output port 1: Registered depth image
    Output port 2: Registered point cloud
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::RealSenseStreamer >":
        return _fast.RealSenseStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.RealSenseStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.RealSenseStreamer_getStaticNameOfClass()

    def setMaxRange(self, range: "float") -> "void":
        r"""
        Set maximum range in millimeters. All points above this range will be dropped.
        :type range: float
        :param range:
        """
        return _fast.RealSenseStreamer_setMaxRange(self, range)

    def setMinRange(self, range: "float") -> "void":
        r"""
        Set minimum range in millimeters. All points below this range will be dropped.
        :type range: float
        :param range:
        """
        return _fast.RealSenseStreamer_setMinRange(self, range)

    def setMaxWidth(self, range: "float") -> "void":
        return _fast.RealSenseStreamer_setMaxWidth(self, range)

    def setMinWidth(self, range: "float") -> "void":
        return _fast.RealSenseStreamer_setMinWidth(self, range)

    def setMaxHeight(self, range: "float") -> "void":
        return _fast.RealSenseStreamer_setMaxHeight(self, range)

    def setMinHeight(self, range: "float") -> "void":
        return _fast.RealSenseStreamer_setMinHeight(self, range)

    def getNrOfFrames(self) -> "uint":
        return _fast.RealSenseStreamer_getNrOfFrames(self)

    def getPoint(self, x: "int", y: "int") -> "fast::MeshVertex":
        r"""
        Gets corresponding 3D point from rgb image coordinate
        :type x: int
        :param x:
        :type y: int
        :param y:
        :rtype: :py:class:`MeshVertex`
        :return: 
        """
        return _fast.RealSenseStreamer_getPoint(self, x, y)
    __swig_destroy__ = _fast.delete_RealSenseStreamer

# Register RealSenseStreamer in _fast:
_fast.RealSenseStreamer_swigregister(RealSenseStreamer)

def RealSenseStreamer_New() -> "std::shared_ptr< fast::RealSenseStreamer >":
    return _fast.RealSenseStreamer_New()

def RealSenseStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.RealSenseStreamer_getStaticNameOfClass()

class ClariusStreamer(Streamer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ClariusStreamer >":
        return _fast.ClariusStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ClariusStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ClariusStreamer_getStaticNameOfClass()

    def setConnectionAddress(self, ipAddress: "std::string") -> "void":
        return _fast.ClariusStreamer_setConnectionAddress(self, ipAddress)

    def setConnectionPort(self, port: "int") -> "void":
        return _fast.ClariusStreamer_setConnectionPort(self, port)

    def stop(self) -> "void":
        return _fast.ClariusStreamer_stop(self)
    __swig_destroy__ = _fast.delete_ClariusStreamer

    def getNrOfFrames(self) -> "uint":
        return _fast.ClariusStreamer_getNrOfFrames(self)

    def newImageFn(self, newImage: "void const *", nfo: "_ClariusProcessedImageInfo const *", npos: "int", pos: "_ClariusPosInfo const *") -> "void":
        return _fast.ClariusStreamer_newImageFn(self, newImage, nfo, npos, pos)

    def toggleFreeze(self) -> "void":
        return _fast.ClariusStreamer_toggleFreeze(self)

    def increaseDepth(self) -> "void":
        return _fast.ClariusStreamer_increaseDepth(self)

    def decreaseDepth(self) -> "void":
        return _fast.ClariusStreamer_decreaseDepth(self)

    def setDepth(self, depth: "float") -> "void":
        r"""Set depth in centimeters"""
        return _fast.ClariusStreamer_setDepth(self, depth)

    def setGain(self, gain: "float") -> "void":
        r"""Set gain in percentage"""
        return _fast.ClariusStreamer_setGain(self, gain)

    def loadAttributes(self) -> "void":
        return _fast.ClariusStreamer_loadAttributes(self)

# Register ClariusStreamer in _fast:
_fast.ClariusStreamer_swigregister(ClariusStreamer)

def ClariusStreamer_New() -> "std::shared_ptr< fast::ClariusStreamer >":
    return _fast.ClariusStreamer_New()

def ClariusStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.ClariusStreamer_getStaticNameOfClass()

class UFFStreamer(RandomAccessStreamer):
    r"""
    A streamer for reading data stored in the ultrasound file format (UFF)
    which is essentially and HDF5 file with ultrasound image/beam data.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::UFFStreamer >":
        return _fast.UFFStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.UFFStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.UFFStreamer_getStaticNameOfClass()

    def __init__(self):
        _fast.UFFStreamer_swiginit(self, _fast.new_UFFStreamer())

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.UFFStreamer_setFilename(self, filename)

    def execute(self) -> "void":
        return _fast.UFFStreamer_execute(self)

    def getNrOfFrames(self) -> "int":
        return _fast.UFFStreamer_getNrOfFrames(self)

    def setName(self, name: "std::string") -> "void":
        return _fast.UFFStreamer_setName(self, name)

    def loadAttributes(self) -> "void":
        return _fast.UFFStreamer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_UFFStreamer

# Register UFFStreamer in _fast:
_fast.UFFStreamer_swigregister(UFFStreamer)

def UFFStreamer_New() -> "std::shared_ptr< fast::UFFStreamer >":
    return _fast.UFFStreamer_New()

def UFFStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.UFFStreamer_getStaticNameOfClass()

class SegmentationAlgorithm(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setLabel(self, label: "Segmentation::LabelType") -> "void":
        return _fast.SegmentationAlgorithm_setLabel(self, label)

    def getLabel(self) -> "Segmentation::LabelType":
        return _fast.SegmentationAlgorithm_getLabel(self)
    __swig_destroy__ = _fast.delete_SegmentationAlgorithm

# Register SegmentationAlgorithm in _fast:
_fast.SegmentationAlgorithm_swigregister(SegmentationAlgorithm)

class AddTransformation(ProcessObject):
    r"""
    This class will add new scene graph node before the root node of the input data object.
    This node will get the transformation supplied to the transformation input connection
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::AddTransformation >":
        return _fast.AddTransformation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.AddTransformation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.AddTransformation_getStaticNameOfClass()

    def setTransformationInputConnection(self, port: "fast::DataChannel::pointer") -> "void":
        return _fast.AddTransformation_setTransformationInputConnection(self, port)
    __swig_destroy__ = _fast.delete_AddTransformation

# Register AddTransformation in _fast:
_fast.AddTransformation_swigregister(AddTransformation)

def AddTransformation_New() -> "std::shared_ptr< fast::AddTransformation >":
    return _fast.AddTransformation_New()

def AddTransformation_getStaticNameOfClass() -> "std::string":
    return _fast.AddTransformation_getStaticNameOfClass()

class SetTransformation(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SetTransformation >":
        return _fast.SetTransformation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SetTransformation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SetTransformation_getStaticNameOfClass()

    def setTransformationInputConnection(self, port: "fast::DataChannel::pointer") -> "void":
        return _fast.SetTransformation_setTransformationInputConnection(self, port)
    __swig_destroy__ = _fast.delete_SetTransformation

# Register SetTransformation in _fast:
_fast.SetTransformation_swigregister(SetTransformation)

def SetTransformation_New() -> "std::shared_ptr< fast::SetTransformation >":
    return _fast.SetTransformation_New()

def SetTransformation_getStaticNameOfClass() -> "std::string":
    return _fast.SetTransformation_getStaticNameOfClass()

class AirwaySegmentation(SegmentationAlgorithm):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::AirwaySegmentation >":
        return _fast.AirwaySegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.AirwaySegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.AirwaySegmentation_getStaticNameOfClass()

    def setSeedPoint(self, *args) -> "void":
        return _fast.AirwaySegmentation_setSeedPoint(self, *args)

    def setSmoothing(self, sigma: "float") -> "void":
        r"""
        Set the sigma value of the gaussian smoothing performed before segmentation.
        Default is 0.5. A higher value can be used for low dose CT.
        :type sigma: float
        :param sigma:
        """
        return _fast.AirwaySegmentation_setSmoothing(self, sigma)

    def loadAttributes(self) -> "void":
        return _fast.AirwaySegmentation_loadAttributes(self)
    __swig_destroy__ = _fast.delete_AirwaySegmentation

# Register AirwaySegmentation in _fast:
_fast.AirwaySegmentation_swigregister(AirwaySegmentation)

def AirwaySegmentation_New() -> "std::shared_ptr< fast::AirwaySegmentation >":
    return _fast.AirwaySegmentation_New()

def AirwaySegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.AirwaySegmentation_getStaticNameOfClass()

class BinaryThresholding(SegmentationAlgorithm):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::BinaryThresholding >":
        return _fast.BinaryThresholding_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.BinaryThresholding_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BinaryThresholding_getStaticNameOfClass()

    def setLowerThreshold(self, threshold: "float") -> "void":
        return _fast.BinaryThresholding_setLowerThreshold(self, threshold)

    def setUpperThreshold(self, threshold: "float") -> "void":
        return _fast.BinaryThresholding_setUpperThreshold(self, threshold)

    def loadAttributes(self) -> "void":
        return _fast.BinaryThresholding_loadAttributes(self)
    __swig_destroy__ = _fast.delete_BinaryThresholding

# Register BinaryThresholding in _fast:
_fast.BinaryThresholding_swigregister(BinaryThresholding)

def BinaryThresholding_New() -> "std::shared_ptr< fast::BinaryThresholding >":
    return _fast.BinaryThresholding_New()

def BinaryThresholding_getStaticNameOfClass() -> "std::string":
    return _fast.BinaryThresholding_getStaticNameOfClass()

class BlockMatching(ProcessObject):
    r"""
    2D block matching on the GPU. Input is a stream of input images, output is a stream of images
    with 2 channels giving the x,y motion of each pixel.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::BlockMatching >":
        return _fast.BlockMatching_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.BlockMatching_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BlockMatching_getStaticNameOfClass()
    MatchingMetric_NORMALIZED_CROSS_CORRELATION = _fast.BlockMatching_MatchingMetric_NORMALIZED_CROSS_CORRELATION
    MatchingMetric_SUM_OF_SQUARED_DIFFERENCES = _fast.BlockMatching_MatchingMetric_SUM_OF_SQUARED_DIFFERENCES
    MatchingMetric_SUM_OF_ABSOLUTE_DIFFERENCES = _fast.BlockMatching_MatchingMetric_SUM_OF_ABSOLUTE_DIFFERENCES

    @staticmethod
    def stringToMetric(name: "std::string") -> "fast::BlockMatching::MatchingMetric":
        r"""
        Convert string of metric to type
        :type name: string
        :param name:
        :rtype: int
        :return: MatchingMetric
        """
        return _fast.BlockMatching_stringToMetric(name)

    def setMatchingMetric(self, type: "fast::BlockMatching::MatchingMetric") -> "void":
        r"""
        Select which matching metric to use
        :type type: int
        :param type:
        """
        return _fast.BlockMatching_setMatchingMetric(self, type)

    def setBlockSize(self, size: "int") -> "void":
        r"""
        Set size of the blocks to match. Has to be odd
        :type size: int
        :param size:
        """
        return _fast.BlockMatching_setBlockSize(self, size)

    def setSearchSize(self, size: "int") -> "void":
        r"""
        Set size of search grid around x,y. Has to be odd
        :type size: int
        :param size:
        """
        return _fast.BlockMatching_setSearchSize(self, size)

    def setIntensityThreshold(self, value: "float") -> "void":
        r"""
        Set an intensity threshold, do not do block matching on pixels where the mean of the block is below this threhsold.
        :type value: float
        :param value:
        """
        return _fast.BlockMatching_setIntensityThreshold(self, value)

    def setTimeLag(self, timeLag: "int") -> "void":
        r"""
        Set time lag of block matching. A time lag of 2 will use frame t, and t-2 for block matching. Default is 1
        :type timeLag: int
        :param timeLag:
        """
        return _fast.BlockMatching_setTimeLag(self, timeLag)

    def setForwardBackwardTracking(self, forwardBackward: "bool") -> "void":
        r"""
        Set whether to use forward-backward tracking or not. Disabled by default.
        :type forwardBackward: boolean
        :param forwardBackward:
        """
        return _fast.BlockMatching_setForwardBackwardTracking(self, forwardBackward)

    def setRegionOfInterest(self, offset: "Vector2i", size: "Vector2i") -> "void":
        r"""
        Set a region of interest (ROI) to run the block matching in.
        :type offset: Vector2i
        :param offset: from origin to start the ROI in pixels
        :type size: Vector2i
        :param size: of the ROI in pixels
        """
        return _fast.BlockMatching_setRegionOfInterest(self, offset, size)

    def loadAttributes(self) -> "void":
        return _fast.BlockMatching_loadAttributes(self)
    __swig_destroy__ = _fast.delete_BlockMatching

# Register BlockMatching in _fast:
_fast.BlockMatching_swigregister(BlockMatching)

def BlockMatching_New() -> "std::shared_ptr< fast::BlockMatching >":
    return _fast.BlockMatching_New()

def BlockMatching_getStaticNameOfClass() -> "std::string":
    return _fast.BlockMatching_getStaticNameOfClass()

def BlockMatching_stringToMetric(name: "std::string") -> "fast::BlockMatching::MatchingMetric":
    r"""
    Convert string of metric to type
    :type name: string
    :param name:
    :rtype: int
    :return: MatchingMetric
    """
    return _fast.BlockMatching_stringToMetric(name)

class CenterlineExtraction(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::CenterlineExtraction >":
        return _fast.CenterlineExtraction_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.CenterlineExtraction_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.CenterlineExtraction_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_CenterlineExtraction

# Register CenterlineExtraction in _fast:
_fast.CenterlineExtraction_swigregister(CenterlineExtraction)

def CenterlineExtraction_New() -> "std::shared_ptr< fast::CenterlineExtraction >":
    return _fast.CenterlineExtraction_New()

def CenterlineExtraction_getStaticNameOfClass() -> "std::string":
    return _fast.CenterlineExtraction_getStaticNameOfClass()

class GaussianSmoothingFilter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::GaussianSmoothingFilter >":
        return _fast.GaussianSmoothingFilter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.GaussianSmoothingFilter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.GaussianSmoothingFilter_getStaticNameOfClass()

    def setMaskSize(self, maskSize: "unsigned char") -> "void":
        return _fast.GaussianSmoothingFilter_setMaskSize(self, maskSize)

    def setStandardDeviation(self, stdDev: "float") -> "void":
        return _fast.GaussianSmoothingFilter_setStandardDeviation(self, stdDev)

    def setOutputType(self, type: "fast::DataType") -> "void":
        return _fast.GaussianSmoothingFilter_setOutputType(self, type)
    __swig_destroy__ = _fast.delete_GaussianSmoothingFilter

# Register GaussianSmoothingFilter in _fast:
_fast.GaussianSmoothingFilter_swigregister(GaussianSmoothingFilter)

def GaussianSmoothingFilter_New() -> "std::shared_ptr< fast::GaussianSmoothingFilter >":
    return _fast.GaussianSmoothingFilter_New()

def GaussianSmoothingFilter_getStaticNameOfClass() -> "std::string":
    return _fast.GaussianSmoothingFilter_getStaticNameOfClass()

class EulerGradientVectorFlow(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::EulerGradientVectorFlow >":
        return _fast.EulerGradientVectorFlow_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.EulerGradientVectorFlow_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.EulerGradientVectorFlow_getStaticNameOfClass()

    def setIterations(self, iterations: "uint") -> "void":
        return _fast.EulerGradientVectorFlow_setIterations(self, iterations)

    def setMuConstant(self, mu: "float") -> "void":
        return _fast.EulerGradientVectorFlow_setMuConstant(self, mu)

    def getMuConstant(self) -> "float":
        return _fast.EulerGradientVectorFlow_getMuConstant(self)

    def set16bitStorageFormat(self) -> "void":
        r"""
        Use 16 bit format internally to reduce memory usage and
        increase performance.
        This will slightly reduce accuracy/convergence.
        """
        return _fast.EulerGradientVectorFlow_set16bitStorageFormat(self)

    def set32bitStorageFormat(self) -> "void":
        r"""Use 32 bit format internally instead of 16 bit."""
        return _fast.EulerGradientVectorFlow_set32bitStorageFormat(self)
    __swig_destroy__ = _fast.delete_EulerGradientVectorFlow

# Register EulerGradientVectorFlow in _fast:
_fast.EulerGradientVectorFlow_swigregister(EulerGradientVectorFlow)

def EulerGradientVectorFlow_New() -> "std::shared_ptr< fast::EulerGradientVectorFlow >":
    return _fast.EulerGradientVectorFlow_New()

def EulerGradientVectorFlow_getStaticNameOfClass() -> "std::string":
    return _fast.EulerGradientVectorFlow_getStaticNameOfClass()

class MultigridGradientVectorFlow(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MultigridGradientVectorFlow >":
        return _fast.MultigridGradientVectorFlow_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MultigridGradientVectorFlow_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MultigridGradientVectorFlow_getStaticNameOfClass()

    def setIterations(self, iterations: "uint") -> "void":
        return _fast.MultigridGradientVectorFlow_setIterations(self, iterations)

    def setMuConstant(self, mu: "float") -> "void":
        return _fast.MultigridGradientVectorFlow_setMuConstant(self, mu)

    def getMuConstant(self) -> "float":
        return _fast.MultigridGradientVectorFlow_getMuConstant(self)

    def set16bitStorageFormat(self) -> "void":
        r"""
        Use 16 bit format internally to reduce memory usage and
        increase performance.
        This will slightly reduce accuracy/convergence.
        """
        return _fast.MultigridGradientVectorFlow_set16bitStorageFormat(self)

    def set32bitStorageFormat(self) -> "void":
        r"""Use 32 bit format internally instead of 16 bit."""
        return _fast.MultigridGradientVectorFlow_set32bitStorageFormat(self)
    __swig_destroy__ = _fast.delete_MultigridGradientVectorFlow

# Register MultigridGradientVectorFlow in _fast:
_fast.MultigridGradientVectorFlow_swigregister(MultigridGradientVectorFlow)

def MultigridGradientVectorFlow_New() -> "std::shared_ptr< fast::MultigridGradientVectorFlow >":
    return _fast.MultigridGradientVectorFlow_New()

def MultigridGradientVectorFlow_getStaticNameOfClass() -> "std::string":
    return _fast.MultigridGradientVectorFlow_getStaticNameOfClass()

class HounsefieldConverter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::HounsefieldConverter >":
        return _fast.HounsefieldConverter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.HounsefieldConverter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.HounsefieldConverter_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_HounsefieldConverter

# Register HounsefieldConverter in _fast:
_fast.HounsefieldConverter_swigregister(HounsefieldConverter)

def HounsefieldConverter_New() -> "std::shared_ptr< fast::HounsefieldConverter >":
    return _fast.HounsefieldConverter_New()

def HounsefieldConverter_getStaticNameOfClass() -> "std::string":
    return _fast.HounsefieldConverter_getStaticNameOfClass()

class ImageChannelConverter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageChannelConverter >":
        return _fast.ImageChannelConverter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageChannelConverter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageChannelConverter_getStaticNameOfClass()

    def setChannelsToRemove(self, channel1: "bool", channel2: "bool", channel3: "bool", channel4: "bool") -> "void":
        return _fast.ImageChannelConverter_setChannelsToRemove(self, channel1, channel2, channel3, channel4)

    def setReverseChannels(self, reverse: "bool") -> "void":
        return _fast.ImageChannelConverter_setReverseChannels(self, reverse)

    def execute(self) -> "void":
        return _fast.ImageChannelConverter_execute(self)
    __swig_destroy__ = _fast.delete_ImageChannelConverter

# Register ImageChannelConverter in _fast:
_fast.ImageChannelConverter_swigregister(ImageChannelConverter)

def ImageChannelConverter_New() -> "std::shared_ptr< fast::ImageChannelConverter >":
    return _fast.ImageChannelConverter_New()

def ImageChannelConverter_getStaticNameOfClass() -> "std::string":
    return _fast.ImageChannelConverter_getStaticNameOfClass()

class ImageCropper(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageCropper >":
        return _fast.ImageCropper_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageCropper_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageCropper_getStaticNameOfClass()

    def setOffset(self, offset: "VectorXi") -> "void":
        return _fast.ImageCropper_setOffset(self, offset)

    def setSize(self, size: "VectorXi") -> "void":
        return _fast.ImageCropper_setSize(self, size)

    def allowOutOfBoundsCropping(self, allow: "bool") -> "void":
        r"""
        If out of bounds cropping is allowed, offset can be negative and size can be larger than image.
        Any pixels outside of image will be replaced with 0.
        """
        return _fast.ImageCropper_allowOutOfBoundsCropping(self, allow)

    def setCropBottom(self, fraction: "float") -> "void":
        return _fast.ImageCropper_setCropBottom(self, fraction)

    def setCropTop(self, fraction: "float") -> "void":
        return _fast.ImageCropper_setCropTop(self, fraction)
    __swig_destroy__ = _fast.delete_ImageCropper

# Register ImageCropper in _fast:
_fast.ImageCropper_swigregister(ImageCropper)

def ImageCropper_New() -> "std::shared_ptr< fast::ImageCropper >":
    return _fast.ImageCropper_New()

def ImageCropper_getStaticNameOfClass() -> "std::string":
    return _fast.ImageCropper_getStaticNameOfClass()

class ImageGradient(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageGradient >":
        return _fast.ImageGradient_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageGradient_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageGradient_getStaticNameOfClass()

    def set16bitStorageFormat(self) -> "void":
        r"""Use 16 bit format to reduce memory usage"""
        return _fast.ImageGradient_set16bitStorageFormat(self)

    def set32bitStorageFormat(self) -> "void":
        r"""Use regular 32 bit float format (default)"""
        return _fast.ImageGradient_set32bitStorageFormat(self)
    __swig_destroy__ = _fast.delete_ImageGradient

# Register ImageGradient in _fast:
_fast.ImageGradient_swigregister(ImageGradient)

def ImageGradient_New() -> "std::shared_ptr< fast::ImageGradient >":
    return _fast.ImageGradient_New()

def ImageGradient_getStaticNameOfClass() -> "std::string":
    return _fast.ImageGradient_getStaticNameOfClass()

class ImageInverter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageInverter >":
        return _fast.ImageInverter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageInverter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageInverter_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_ImageInverter

# Register ImageInverter in _fast:
_fast.ImageInverter_swigregister(ImageInverter)

def ImageInverter_New() -> "std::shared_ptr< fast::ImageInverter >":
    return _fast.ImageInverter_New()

def ImageInverter_getStaticNameOfClass() -> "std::string":
    return _fast.ImageInverter_getStaticNameOfClass()

class ImageMultiply(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageMultiply >":
        return _fast.ImageMultiply_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageMultiply_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageMultiply_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_ImageMultiply

# Register ImageMultiply in _fast:
_fast.ImageMultiply_swigregister(ImageMultiply)

def ImageMultiply_New() -> "std::shared_ptr< fast::ImageMultiply >":
    return _fast.ImageMultiply_New()

def ImageMultiply_getStaticNameOfClass() -> "std::string":
    return _fast.ImageMultiply_getStaticNameOfClass()

class PatchGenerator(Streamer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::PatchGenerator >":
        return _fast.PatchGenerator_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.PatchGenerator_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.PatchGenerator_getStaticNameOfClass()

    def setPatchSize(self, width: "int", height: "int", depth: "int"=1) -> "void":
        return _fast.PatchGenerator_setPatchSize(self, width, height, depth)

    def setPatchLevel(self, level: "int") -> "void":
        return _fast.PatchGenerator_setPatchLevel(self, level)
    __swig_destroy__ = _fast.delete_PatchGenerator

    def loadAttributes(self) -> "void":
        return _fast.PatchGenerator_loadAttributes(self)

# Register PatchGenerator in _fast:
_fast.PatchGenerator_swigregister(PatchGenerator)

def PatchGenerator_New() -> "std::shared_ptr< fast::PatchGenerator >":
    return _fast.PatchGenerator_New()

def PatchGenerator_getStaticNameOfClass() -> "std::string":
    return _fast.PatchGenerator_getStaticNameOfClass()

class PatchStitcher(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::PatchStitcher >":
        return _fast.PatchStitcher_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.PatchStitcher_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.PatchStitcher_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_PatchStitcher

# Register PatchStitcher in _fast:
_fast.PatchStitcher_swigregister(PatchStitcher)

def PatchStitcher_New() -> "std::shared_ptr< fast::PatchStitcher >":
    return _fast.PatchStitcher_New()

def PatchStitcher_getStaticNameOfClass() -> "std::string":
    return _fast.PatchStitcher_getStaticNameOfClass()

class ImageToBatchGenerator(Streamer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageToBatchGenerator >":
        return _fast.ImageToBatchGenerator_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageToBatchGenerator_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageToBatchGenerator_getStaticNameOfClass()

    def setMaxBatchSize(self, size: "int") -> "void":
        return _fast.ImageToBatchGenerator_setMaxBatchSize(self, size)
    __swig_destroy__ = _fast.delete_ImageToBatchGenerator

# Register ImageToBatchGenerator in _fast:
_fast.ImageToBatchGenerator_swigregister(ImageToBatchGenerator)

def ImageToBatchGenerator_New() -> "std::shared_ptr< fast::ImageToBatchGenerator >":
    return _fast.ImageToBatchGenerator_New()

def ImageToBatchGenerator_getStaticNameOfClass() -> "std::string":
    return _fast.ImageToBatchGenerator_getStaticNameOfClass()

class ImageResampler(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageResampler >":
        return _fast.ImageResampler_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageResampler_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageResampler_getStaticNameOfClass()

    def setOutputSpacing(self, *args) -> "void":
        return _fast.ImageResampler_setOutputSpacing(self, *args)

    def setInterpolation(self, useInterpolation: "bool") -> "void":
        return _fast.ImageResampler_setInterpolation(self, useInterpolation)

    def loadAttributes(self) -> "void":
        return _fast.ImageResampler_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageResampler

# Register ImageResampler in _fast:
_fast.ImageResampler_swigregister(ImageResampler)

def ImageResampler_New() -> "std::shared_ptr< fast::ImageResampler >":
    return _fast.ImageResampler_New()

def ImageResampler_getStaticNameOfClass() -> "std::string":
    return _fast.ImageResampler_getStaticNameOfClass()

class ImageResizer(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageResizer >":
        return _fast.ImageResizer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageResizer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageResizer_getStaticNameOfClass()

    def setWidth(self, width: "int") -> "void":
        return _fast.ImageResizer_setWidth(self, width)

    def setHeight(self, height: "int") -> "void":
        return _fast.ImageResizer_setHeight(self, height)

    def setDepth(self, depth: "int") -> "void":
        return _fast.ImageResizer_setDepth(self, depth)

    def setSize(self, size: "VectorXi") -> "void":
        return _fast.ImageResizer_setSize(self, size)

    def setPreserveAspectRatio(self, preserve: "bool") -> "void":
        return _fast.ImageResizer_setPreserveAspectRatio(self, preserve)

    def setInterpolation(self, useInterpolation: "bool") -> "void":
        return _fast.ImageResizer_setInterpolation(self, useInterpolation)

    def loadAttributes(self) -> "void":
        return _fast.ImageResizer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageResizer

# Register ImageResizer in _fast:
_fast.ImageResizer_swigregister(ImageResizer)

def ImageResizer_New() -> "std::shared_ptr< fast::ImageResizer >":
    return _fast.ImageResizer_New()

def ImageResizer_getStaticNameOfClass() -> "std::string":
    return _fast.ImageResizer_getStaticNameOfClass()

class ImageSlicer(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageSlicer >":
        return _fast.ImageSlicer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageSlicer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageSlicer_getStaticNameOfClass()

    def setOrthogonalSlicePlane(self, orthogonalSlicePlane: "fast::PlaneType", sliceNr: "int"=-1) -> "void":
        return _fast.ImageSlicer_setOrthogonalSlicePlane(self, orthogonalSlicePlane, sliceNr)

    def setArbitrarySlicePlane(self, slicePlane: "Plane") -> "void":
        return _fast.ImageSlicer_setArbitrarySlicePlane(self, slicePlane)
    __swig_destroy__ = _fast.delete_ImageSlicer

# Register ImageSlicer in _fast:
_fast.ImageSlicer_swigregister(ImageSlicer)

def ImageSlicer_New() -> "std::shared_ptr< fast::ImageSlicer >":
    return _fast.ImageSlicer_New()

def ImageSlicer_getStaticNameOfClass() -> "std::string":
    return _fast.ImageSlicer_getStaticNameOfClass()

class IterativeClosestPoint(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::IterativeClosestPoint >":
        return _fast.IterativeClosestPoint_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.IterativeClosestPoint_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.IterativeClosestPoint_getStaticNameOfClass()
    RIGID = _fast.IterativeClosestPoint_RIGID
    TRANSLATION = _fast.IterativeClosestPoint_TRANSLATION

    def setFixedMeshPort(self, port: "fast::DataChannel::pointer") -> "void":
        return _fast.IterativeClosestPoint_setFixedMeshPort(self, port)

    def setFixedMesh(self, data: "Mesh::pointer") -> "void":
        return _fast.IterativeClosestPoint_setFixedMesh(self, data)

    def setMovingMeshPort(self, port: "fast::DataChannel::pointer") -> "void":
        return _fast.IterativeClosestPoint_setMovingMeshPort(self, port)

    def setMovingMesh(self, data: "Mesh::pointer") -> "void":
        return _fast.IterativeClosestPoint_setMovingMesh(self, data)

    def setTransformationType(self, type: "fast::IterativeClosestPoint::TransformationType const") -> "void":
        return _fast.IterativeClosestPoint_setTransformationType(self, type)

    def getOutputTransformation(self) -> "AffineTransformation::pointer":
        return _fast.IterativeClosestPoint_getOutputTransformation(self)

    def getError(self) -> "float":
        return _fast.IterativeClosestPoint_getError(self)

    def setMinimumErrorChange(self, errorChange: "float") -> "void":
        return _fast.IterativeClosestPoint_setMinimumErrorChange(self, errorChange)

    def setMaximumNrOfIterations(self, iterations: "uint") -> "void":
        return _fast.IterativeClosestPoint_setMaximumNrOfIterations(self, iterations)

    def setRandomPointSampling(self, nrOfPointsToSample: "uint") -> "void":
        return _fast.IterativeClosestPoint_setRandomPointSampling(self, nrOfPointsToSample)

    def setDistanceThreshold(self, distance: "float") -> "void":
        return _fast.IterativeClosestPoint_setDistanceThreshold(self, distance)
    __swig_destroy__ = _fast.delete_IterativeClosestPoint

# Register IterativeClosestPoint in _fast:
_fast.IterativeClosestPoint_swigregister(IterativeClosestPoint)

def IterativeClosestPoint_New() -> "std::shared_ptr< fast::IterativeClosestPoint >":
    return _fast.IterativeClosestPoint_New()

def IterativeClosestPoint_getStaticNameOfClass() -> "std::string":
    return _fast.IterativeClosestPoint_getStaticNameOfClass()

class LabelModifier(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::LabelModifier >":
        return _fast.LabelModifier_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.LabelModifier_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.LabelModifier_getStaticNameOfClass()

    def setLabelChange(self, oldLabel: "uchar", newLabel: "uchar") -> "void":
        return _fast.LabelModifier_setLabelChange(self, oldLabel, newLabel)

    def loadAttributes(self) -> "void":
        return _fast.LabelModifier_loadAttributes(self)
    __swig_destroy__ = _fast.delete_LabelModifier

# Register LabelModifier in _fast:
_fast.LabelModifier_swigregister(LabelModifier)

def LabelModifier_New() -> "std::shared_ptr< fast::LabelModifier >":
    return _fast.LabelModifier_New()

def LabelModifier_getStaticNameOfClass() -> "std::string":
    return _fast.LabelModifier_getStaticNameOfClass()

class LaplacianOfGaussian(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::LaplacianOfGaussian >":
        return _fast.LaplacianOfGaussian_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.LaplacianOfGaussian_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.LaplacianOfGaussian_getStaticNameOfClass()

    def setMaskSize(self, maskSize: "unsigned char") -> "void":
        return _fast.LaplacianOfGaussian_setMaskSize(self, maskSize)

    def setStandardDeviation(self, stdDev: "float") -> "void":
        return _fast.LaplacianOfGaussian_setStandardDeviation(self, stdDev)
    __swig_destroy__ = _fast.delete_LaplacianOfGaussian

# Register LaplacianOfGaussian in _fast:
_fast.LaplacianOfGaussian_swigregister(LaplacianOfGaussian)

def LaplacianOfGaussian_New() -> "std::shared_ptr< fast::LaplacianOfGaussian >":
    return _fast.LaplacianOfGaussian_New()

def LaplacianOfGaussian_getStaticNameOfClass() -> "std::string":
    return _fast.LaplacianOfGaussian_getStaticNameOfClass()

class LevelSetSegmentation(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::LevelSetSegmentation >":
        return _fast.LevelSetSegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.LevelSetSegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.LevelSetSegmentation_getStaticNameOfClass()

    def addSeedPoint(self, position: "Vector3i", size: "float") -> "void":
        return _fast.LevelSetSegmentation_addSeedPoint(self, position, size)

    def setCurvatureWeight(self, weight: "float") -> "void":
        return _fast.LevelSetSegmentation_setCurvatureWeight(self, weight)

    def setIntensityMean(self, intensity: "float") -> "void":
        return _fast.LevelSetSegmentation_setIntensityMean(self, intensity)

    def setIntensityVariance(self, variation: "float") -> "void":
        return _fast.LevelSetSegmentation_setIntensityVariance(self, variation)

    def setMaxIterations(self, iterations: "uint") -> "void":
        return _fast.LevelSetSegmentation_setMaxIterations(self, iterations)
    __swig_destroy__ = _fast.delete_LevelSetSegmentation

# Register LevelSetSegmentation in _fast:
_fast.LevelSetSegmentation_swigregister(LevelSetSegmentation)

def LevelSetSegmentation_New() -> "std::shared_ptr< fast::LevelSetSegmentation >":
    return _fast.LevelSetSegmentation_New()

def LevelSetSegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.LevelSetSegmentation_getStaticNameOfClass()

class LungSegmentation(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::LungSegmentation >":
        return _fast.LungSegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.LungSegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.LungSegmentation_getStaticNameOfClass()

    def setAirwaySeedPoint(self, *args) -> "void":
        return _fast.LungSegmentation_setAirwaySeedPoint(self, *args)

    def getBloodVesselOutputPort(self) -> "fast::DataChannel::pointer":
        return _fast.LungSegmentation_getBloodVesselOutputPort(self)
    __swig_destroy__ = _fast.delete_LungSegmentation

# Register LungSegmentation in _fast:
_fast.LungSegmentation_swigregister(LungSegmentation)

def LungSegmentation_New() -> "std::shared_ptr< fast::LungSegmentation >":
    return _fast.LungSegmentation_New()

def LungSegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.LungSegmentation_getStaticNameOfClass()

class MeshToSegmentation(SegmentationAlgorithm):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MeshToSegmentation >":
        return _fast.MeshToSegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MeshToSegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MeshToSegmentation_getStaticNameOfClass()

    def setOutputImageResolution(self, x: "uint", y: "uint", z: "uint"=1) -> "void":
        r"""
        Set output image resolution in voxels
        :type x: int
        :param x:
        :type y: int
        :param y:
        :type z: int
        :param z:
        """
        return _fast.MeshToSegmentation_setOutputImageResolution(self, x, y, z)
    __swig_destroy__ = _fast.delete_MeshToSegmentation

# Register MeshToSegmentation in _fast:
_fast.MeshToSegmentation_swigregister(MeshToSegmentation)

def MeshToSegmentation_New() -> "std::shared_ptr< fast::MeshToSegmentation >":
    return _fast.MeshToSegmentation_New()

def MeshToSegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.MeshToSegmentation_getStaticNameOfClass()

class KalmanFilter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::KalmanFilter >":
        return _fast.KalmanFilter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.KalmanFilter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.KalmanFilter_getStaticNameOfClass()

    def setShapeModel(self, shapeModel: "ShapeModel::pointer") -> "void":
        return _fast.KalmanFilter_setShapeModel(self, shapeModel)

    def setAppearanceModel(self, appearanceModel: "AppearanceModel::pointer") -> "void":
        return _fast.KalmanFilter_setAppearanceModel(self, appearanceModel)

    def setIterations(self, iterations: "int") -> "void":
        return _fast.KalmanFilter_setIterations(self, iterations)

    def setStartIterations(self, iterations: "int") -> "void":
        return _fast.KalmanFilter_setStartIterations(self, iterations)

    def getCurrentState(self) -> "VectorXf":
        return _fast.KalmanFilter_getCurrentState(self)

    def getSegmentationOutputPort(self) -> "fast::DataChannel::pointer":
        return _fast.KalmanFilter_getSegmentationOutputPort(self)

    def getDisplacementsOutputPort(self) -> "fast::DataChannel::pointer":
        return _fast.KalmanFilter_getDisplacementsOutputPort(self)
    __swig_destroy__ = _fast.delete_KalmanFilter

# Register KalmanFilter in _fast:
_fast.KalmanFilter_swigregister(KalmanFilter)

def KalmanFilter_New() -> "std::shared_ptr< fast::KalmanFilter >":
    return _fast.KalmanFilter_New()

def KalmanFilter_getStaticNameOfClass() -> "std::string":
    return _fast.KalmanFilter_getStaticNameOfClass()

class Measurement(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    displacement = property(_fast.Measurement_displacement_get, _fast.Measurement_displacement_set)
    uncertainty = property(_fast.Measurement_uncertainty_get, _fast.Measurement_uncertainty_set)

    def __init__(self):
        _fast.Measurement_swiginit(self, _fast.new_Measurement())
    __swig_destroy__ = _fast.delete_Measurement

# Register Measurement in _fast:
_fast.Measurement_swigregister(Measurement)

class AppearanceModel(Object):
    r"""
    This is a base class for appearance models.
    These classes model of an object appears in an image.
    They are used by the Kalman filter to collect measurements.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getMeasurements(self, image: "std::shared_ptr< fast::Image >", shape: "std::shared_ptr< Shape >", device: "fast::ExecutionDevice::pointer") -> "std::vector< fast::Measurement,std::allocator< fast::Measurement > >":
        return _fast.AppearanceModel_getMeasurements(self, image, shape, device)
    __swig_destroy__ = _fast.delete_AppearanceModel

# Register AppearanceModel in _fast:
_fast.AppearanceModel_swigregister(AppearanceModel)

class ShapeModel(Object):
    r"""
    This is an abstract base class for all shape models.
    These objects describe a deformable shape, its parameters
    and how it is allowed to change in space and time.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getShape(self, state: "VectorXf") -> "Shape::pointer":
        return _fast.ShapeModel_getShape(self, state)

    def getStateTransitionMatrix1(self) -> "MatrixXf":
        return _fast.ShapeModel_getStateTransitionMatrix1(self)

    def getStateTransitionMatrix2(self) -> "MatrixXf":
        return _fast.ShapeModel_getStateTransitionMatrix2(self)

    def getStateTransitionMatrix3(self) -> "MatrixXf":
        return _fast.ShapeModel_getStateTransitionMatrix3(self)

    def getProcessErrorMatrix(self) -> "MatrixXf":
        return _fast.ShapeModel_getProcessErrorMatrix(self)

    def getInitialState(self, image: "std::shared_ptr< fast::Image >") -> "VectorXf":
        return _fast.ShapeModel_getInitialState(self, image)

    def getMeasurementVectors(self, state: "VectorXf", shape: "Shape::pointer") -> "std::vector< MatrixXf,std::allocator< MatrixXf > >":
        return _fast.ShapeModel_getMeasurementVectors(self, state, shape)

    def restrictState(self, state: "VectorXf") -> "VectorXf":
        return _fast.ShapeModel_restrictState(self, state)
    __swig_destroy__ = _fast.delete_ShapeModel

# Register ShapeModel in _fast:
_fast.ShapeModel_swigregister(ShapeModel)

class Shape(Object):
    r"""Class used to represent a mesh shape."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Shape >":
        return _fast.Shape_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Shape_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Shape_getStaticNameOfClass()

    def getMesh(self) -> "fast::Mesh::pointer":
        return _fast.Shape_getMesh(self)

    def setMesh(self, mesh: "fast::Mesh::pointer") -> "void":
        return _fast.Shape_setMesh(self, mesh)

    def getCentroid(self) -> "Vector3f":
        return _fast.Shape_getCentroid(self)
    __swig_destroy__ = _fast.delete_Shape

# Register Shape in _fast:
_fast.Shape_swigregister(Shape)

def Shape_New() -> "std::shared_ptr< fast::Shape >":
    return _fast.Shape_New()

def Shape_getStaticNameOfClass() -> "std::string":
    return _fast.Shape_getStaticNameOfClass()

class RidgeEdgeModel(AppearanceModel):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::RidgeEdgeModel >":
        return _fast.RidgeEdgeModel_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.RidgeEdgeModel_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.RidgeEdgeModel_getStaticNameOfClass()

    def setLineLength(self, lengthInMM: "float") -> "void":
        return _fast.RidgeEdgeModel_setLineLength(self, lengthInMM)

    def setLineSampleSpacing(self, spacingInMM: "float") -> "void":
        return _fast.RidgeEdgeModel_setLineSampleSpacing(self, spacingInMM)

    def setIntensityDifferenceThreshold(self, threshold: "float") -> "void":
        return _fast.RidgeEdgeModel_setIntensityDifferenceThreshold(self, threshold)

    def setMinimumDepth(self, depth: "float") -> "void":
        return _fast.RidgeEdgeModel_setMinimumDepth(self, depth)

    def setMinimumRidgeSize(self, sizeInMM: "float") -> "void":
        return _fast.RidgeEdgeModel_setMinimumRidgeSize(self, sizeInMM)

    def getMeasurements(self, image: "std::shared_ptr< fast::Image >", shape: "std::shared_ptr< fast::Shape >", device: "fast::ExecutionDevice::pointer") -> "std::vector< fast::Measurement,std::allocator< fast::Measurement > >":
        return _fast.RidgeEdgeModel_getMeasurements(self, image, shape, device)
    EDGE_TYPE_ANY = _fast.RidgeEdgeModel_EDGE_TYPE_ANY
    EDGE_TYPE_BLACK_INSIDE_WHITE_OUTSIDE = _fast.RidgeEdgeModel_EDGE_TYPE_BLACK_INSIDE_WHITE_OUTSIDE
    EDGE_TYPE_WHITE_INSIDE_BLACK_OUTSIDE = _fast.RidgeEdgeModel_EDGE_TYPE_WHITE_INSIDE_BLACK_OUTSIDE

    def setEdgeType(self, type: "fast::RidgeEdgeModel::EdgeType") -> "void":
        return _fast.RidgeEdgeModel_setEdgeType(self, type)
    __swig_destroy__ = _fast.delete_RidgeEdgeModel

# Register RidgeEdgeModel in _fast:
_fast.RidgeEdgeModel_swigregister(RidgeEdgeModel)

def RidgeEdgeModel_New() -> "std::shared_ptr< fast::RidgeEdgeModel >":
    return _fast.RidgeEdgeModel_New()

def RidgeEdgeModel_getStaticNameOfClass() -> "std::string":
    return _fast.RidgeEdgeModel_getStaticNameOfClass()

class StepEdgeModel(AppearanceModel):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::StepEdgeModel >":
        return _fast.StepEdgeModel_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.StepEdgeModel_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.StepEdgeModel_getStaticNameOfClass()

    def setLineLength(self, lengthInMM: "float") -> "void":
        return _fast.StepEdgeModel_setLineLength(self, lengthInMM)

    def setLineSampleSpacing(self, spacingInMM: "float") -> "void":
        return _fast.StepEdgeModel_setLineSampleSpacing(self, spacingInMM)

    def setIntensityDifferenceThreshold(self, threshold: "float") -> "void":
        return _fast.StepEdgeModel_setIntensityDifferenceThreshold(self, threshold)

    def setMinimumDepth(self, depth: "float") -> "void":
        return _fast.StepEdgeModel_setMinimumDepth(self, depth)

    def getMeasurements(self, image: "std::shared_ptr< fast::Image >", shape: "std::shared_ptr< fast::Shape >", device: "fast::ExecutionDevice::pointer") -> "std::vector< fast::Measurement,std::allocator< fast::Measurement > >":
        return _fast.StepEdgeModel_getMeasurements(self, image, shape, device)
    EDGE_TYPE_ANY = _fast.StepEdgeModel_EDGE_TYPE_ANY
    EDGE_TYPE_BLACK_INSIDE_WHITE_OUTSIDE = _fast.StepEdgeModel_EDGE_TYPE_BLACK_INSIDE_WHITE_OUTSIDE
    EDGE_TYPE_WHITE_INSIDE_BLACK_OUTSIDE = _fast.StepEdgeModel_EDGE_TYPE_WHITE_INSIDE_BLACK_OUTSIDE

    def setEdgeType(self, type: "fast::StepEdgeModel::EdgeType") -> "void":
        return _fast.StepEdgeModel_setEdgeType(self, type)
    __swig_destroy__ = _fast.delete_StepEdgeModel

# Register StepEdgeModel in _fast:
_fast.StepEdgeModel_swigregister(StepEdgeModel)

def StepEdgeModel_New() -> "std::shared_ptr< fast::StepEdgeModel >":
    return _fast.StepEdgeModel_New()

def StepEdgeModel_getStaticNameOfClass() -> "std::string":
    return _fast.StepEdgeModel_getStaticNameOfClass()

class CardinalSplineModel(ShapeModel):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::CardinalSplineModel >":
        return _fast.CardinalSplineModel_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.CardinalSplineModel_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.CardinalSplineModel_getStaticNameOfClass()

    def getShape(self, state: "VectorXf") -> "fast::Shape::pointer":
        return _fast.CardinalSplineModel_getShape(self, state)

    def getStateTransitionMatrix1(self) -> "MatrixXf":
        return _fast.CardinalSplineModel_getStateTransitionMatrix1(self)

    def getStateTransitionMatrix2(self) -> "MatrixXf":
        return _fast.CardinalSplineModel_getStateTransitionMatrix2(self)

    def getStateTransitionMatrix3(self) -> "MatrixXf":
        return _fast.CardinalSplineModel_getStateTransitionMatrix3(self)

    def getProcessErrorMatrix(self) -> "MatrixXf":
        return _fast.CardinalSplineModel_getProcessErrorMatrix(self)

    def getInitialState(self, image: "std::shared_ptr< fast::Image >") -> "VectorXf":
        return _fast.CardinalSplineModel_getInitialState(self, image)

    def getMeasurementVectors(self, state: "VectorXf", shape: "fast::Shape::pointer") -> "std::vector< MatrixXf,std::allocator< MatrixXf > >":
        return _fast.CardinalSplineModel_getMeasurementVectors(self, state, shape)

    def initializeShapeToImageCenter(self) -> "void":
        return _fast.CardinalSplineModel_initializeShapeToImageCenter(self)

    def setControlPoints(self, controlPoints: "std::vector< Vector2f,std::allocator< Vector2f > >") -> "void":
        r"""
        Give a set of control points.
        The control points are assumed to be connected so that vector k,
        is connected to vector k-1 and k+1, and the last is connected to
        to the first to form a closed loop.
        """
        return _fast.CardinalSplineModel_setControlPoints(self, controlPoints)

    def setInitialScaling(self, x: "float", y: "float") -> "void":
        return _fast.CardinalSplineModel_setInitialScaling(self, x, y)

    def setInitialRotation(self, angleInRadians: "float") -> "void":
        return _fast.CardinalSplineModel_setInitialRotation(self, angleInRadians)

    def setInitialTranslation(self, x: "float", y: "float") -> "void":
        return _fast.CardinalSplineModel_setInitialTranslation(self, x, y)

    def setLocalProcessError(self, error: "float") -> "void":
        return _fast.CardinalSplineModel_setLocalProcessError(self, error)

    def setGlobalProcessError(self, error: "float") -> "void":
        return _fast.CardinalSplineModel_setGlobalProcessError(self, error)

    def setTension(self, *args) -> "void":
        return _fast.CardinalSplineModel_setTension(self, *args)

    def setResolution(self, resolution: "int") -> "void":
        return _fast.CardinalSplineModel_setResolution(self, resolution)

    def restrictState(self, state: "VectorXf") -> "VectorXf":
        return _fast.CardinalSplineModel_restrictState(self, state)

    def setScalingLimit(self, min: "float"=-1, max: "float"=-1) -> "void":
        return _fast.CardinalSplineModel_setScalingLimit(self, min, max)
    __swig_destroy__ = _fast.delete_CardinalSplineModel

# Register CardinalSplineModel in _fast:
_fast.CardinalSplineModel_swigregister(CardinalSplineModel)

def CardinalSplineModel_New() -> "std::shared_ptr< fast::CardinalSplineModel >":
    return _fast.CardinalSplineModel_New()

def CardinalSplineModel_getStaticNameOfClass() -> "std::string":
    return _fast.CardinalSplineModel_getStaticNameOfClass()

class EllipseModel(ShapeModel):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::EllipseModel >":
        return _fast.EllipseModel_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.EllipseModel_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.EllipseModel_getStaticNameOfClass()

    def getShape(self, state: "VectorXf") -> "fast::Shape::pointer":
        return _fast.EllipseModel_getShape(self, state)

    def getStateTransitionMatrix1(self) -> "MatrixXf":
        return _fast.EllipseModel_getStateTransitionMatrix1(self)

    def getStateTransitionMatrix2(self) -> "MatrixXf":
        return _fast.EllipseModel_getStateTransitionMatrix2(self)

    def getStateTransitionMatrix3(self) -> "MatrixXf":
        return _fast.EllipseModel_getStateTransitionMatrix3(self)

    def getProcessErrorMatrix(self) -> "MatrixXf":
        return _fast.EllipseModel_getProcessErrorMatrix(self)

    def getMeasurementVectors(self, state: "VectorXf", shape: "fast::Shape::pointer") -> "std::vector< MatrixXf,std::allocator< MatrixXf > >":
        return _fast.EllipseModel_getMeasurementVectors(self, state, shape)

    def setInitialState(self, position: "Vector2f", majorRadius: "float", minorRadius: "float") -> "void":
        r"""Set initial state in mm"""
        return _fast.EllipseModel_setInitialState(self, position, majorRadius, minorRadius)

    def getInitialState(self, image: "std::shared_ptr< fast::Image >") -> "VectorXf":
        return _fast.EllipseModel_getInitialState(self, image)

    def restrictState(self, state: "VectorXf") -> "VectorXf":
        return _fast.EllipseModel_restrictState(self, state)
    __swig_destroy__ = _fast.delete_EllipseModel

# Register EllipseModel in _fast:
_fast.EllipseModel_swigregister(EllipseModel)

def EllipseModel_New() -> "std::shared_ptr< fast::EllipseModel >":
    return _fast.EllipseModel_New()

def EllipseModel_getStaticNameOfClass() -> "std::string":
    return _fast.EllipseModel_getStaticNameOfClass()

class MeanValueCoordinatesModel(ShapeModel):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MeanValueCoordinatesModel >":
        return _fast.MeanValueCoordinatesModel_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MeanValueCoordinatesModel_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MeanValueCoordinatesModel_getStaticNameOfClass()

    def loadMeshes(self, *args) -> "void":
        return _fast.MeanValueCoordinatesModel_loadMeshes(self, *args)

    def getShape(self, state: "VectorXf") -> "fast::Shape::pointer":
        return _fast.MeanValueCoordinatesModel_getShape(self, state)

    def getStateTransitionMatrix1(self) -> "MatrixXf":
        return _fast.MeanValueCoordinatesModel_getStateTransitionMatrix1(self)

    def getStateTransitionMatrix2(self) -> "MatrixXf":
        return _fast.MeanValueCoordinatesModel_getStateTransitionMatrix2(self)

    def getStateTransitionMatrix3(self) -> "MatrixXf":
        return _fast.MeanValueCoordinatesModel_getStateTransitionMatrix3(self)

    def getProcessErrorMatrix(self) -> "MatrixXf":
        return _fast.MeanValueCoordinatesModel_getProcessErrorMatrix(self)

    def getInitialState(self, image: "std::shared_ptr< fast::Image >") -> "VectorXf":
        return _fast.MeanValueCoordinatesModel_getInitialState(self, image)

    def getMeasurementVectors(self, state: "VectorXf", shape: "fast::Shape::pointer") -> "std::vector< MatrixXf,std::allocator< MatrixXf > >":
        return _fast.MeanValueCoordinatesModel_getMeasurementVectors(self, state, shape)

    def initializeShapeToImageCenter(self) -> "void":
        return _fast.MeanValueCoordinatesModel_initializeShapeToImageCenter(self)

    def setInitialScaling(self, x: "float", y: "float", z: "float") -> "void":
        return _fast.MeanValueCoordinatesModel_setInitialScaling(self, x, y, z)

    def setInitialTranslation(self, x: "float", y: "float", z: "float") -> "void":
        return _fast.MeanValueCoordinatesModel_setInitialTranslation(self, x, y, z)

    def setLocalProcessError(self, error: "float") -> "void":
        return _fast.MeanValueCoordinatesModel_setLocalProcessError(self, error)

    def setGlobalProcessError(self, error: "float") -> "void":
        return _fast.MeanValueCoordinatesModel_setGlobalProcessError(self, error)
    __swig_destroy__ = _fast.delete_MeanValueCoordinatesModel

# Register MeanValueCoordinatesModel in _fast:
_fast.MeanValueCoordinatesModel_swigregister(MeanValueCoordinatesModel)

def MeanValueCoordinatesModel_New() -> "std::shared_ptr< fast::MeanValueCoordinatesModel >":
    return _fast.MeanValueCoordinatesModel_New()

def MeanValueCoordinatesModel_getStaticNameOfClass() -> "std::string":
    return _fast.MeanValueCoordinatesModel_getStaticNameOfClass()

class Dilation(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Dilation >":
        return _fast.Dilation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Dilation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Dilation_getStaticNameOfClass()

    def setStructuringElementSize(self, size: "int") -> "void":
        r"""
        Set size of structuring element, must be odd
        :type size: int
        :param size:
        """
        return _fast.Dilation_setStructuringElementSize(self, size)
    __swig_destroy__ = _fast.delete_Dilation

# Register Dilation in _fast:
_fast.Dilation_swigregister(Dilation)

def Dilation_New() -> "std::shared_ptr< fast::Dilation >":
    return _fast.Dilation_New()

def Dilation_getStaticNameOfClass() -> "std::string":
    return _fast.Dilation_getStaticNameOfClass()

class Erosion(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Erosion >":
        return _fast.Erosion_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Erosion_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Erosion_getStaticNameOfClass()

    def setStructuringElementSize(self, size: "int") -> "void":
        r"""
        Set size of structuring element, must be odd
        :type size: int
        :param size:
        """
        return _fast.Erosion_setStructuringElementSize(self, size)
    __swig_destroy__ = _fast.delete_Erosion

# Register Erosion in _fast:
_fast.Erosion_swigregister(Erosion)

def Erosion_New() -> "std::shared_ptr< fast::Erosion >":
    return _fast.Erosion_New()

def Erosion_getStaticNameOfClass() -> "std::string":
    return _fast.Erosion_getStaticNameOfClass()

ImageOrdering_ChannelFirst = _fast.ImageOrdering_ChannelFirst
ImageOrdering_ChannelLast = _fast.ImageOrdering_ChannelLast
NodeType_IMAGE = _fast.NodeType_IMAGE
NodeType_TENSOR = _fast.NodeType_TENSOR
InferenceDeviceType_ANY = _fast.InferenceDeviceType_ANY
InferenceDeviceType_CPU = _fast.InferenceDeviceType_CPU
InferenceDeviceType_GPU = _fast.InferenceDeviceType_GPU
InferenceDeviceType_VPU = _fast.InferenceDeviceType_VPU
InferenceDeviceType_OTHER = _fast.InferenceDeviceType_OTHER
class InferenceDeviceInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_fast.InferenceDeviceInfo_name_get, _fast.InferenceDeviceInfo_name_set)
    type = property(_fast.InferenceDeviceInfo_type_get, _fast.InferenceDeviceInfo_type_set)
    index = property(_fast.InferenceDeviceInfo_index_get, _fast.InferenceDeviceInfo_index_set)

    def __init__(self):
        _fast.InferenceDeviceInfo_swiginit(self, _fast.new_InferenceDeviceInfo())
    __swig_destroy__ = _fast.delete_InferenceDeviceInfo

# Register InferenceDeviceInfo in _fast:
_fast.InferenceDeviceInfo_swigregister(InferenceDeviceInfo)

ModelFormat_PROTOBUF = _fast.ModelFormat_PROTOBUF
ModelFormat_SAVEDMODEL = _fast.ModelFormat_SAVEDMODEL
ModelFormat_ONNX = _fast.ModelFormat_ONNX
ModelFormat_OPENVINO = _fast.ModelFormat_OPENVINO
ModelFormat_UFF = _fast.ModelFormat_UFF

def getModelFileExtension(format: "fast::ModelFormat") -> "std::string":
    r"""Get model format file extension."""
    return _fast.getModelFileExtension(format)

def getModelFormat(filename: "std::string") -> "fast::ModelFormat":
    r"""Get model format of the given file."""
    return _fast.getModelFormat(filename)

def getModelFormatName(format: "fast::ModelFormat") -> "std::string":
    r"""
    Get name of model format as string
    :type format: int
    :param format:
    :rtype: string
    :return: 
    """
    return _fast.getModelFormatName(format)
class InferenceEngine(Object):
    r"""Abstract class for neural network inference engines (TensorFlow, TensorRT ++)"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.InferenceEngine_setFilename(self, filename)

    def setModelAndWeights(self, model: "std::vector< uint8_t,std::allocator< uint8_t > >", weights: "std::vector< uint8_t,std::allocator< uint8_t > >") -> "void":
        return _fast.InferenceEngine_setModelAndWeights(self, model, weights)

    def getFilename(self) -> "std::string":
        return _fast.InferenceEngine_getFilename(self)

    def run(self) -> "void":
        return _fast.InferenceEngine_run(self)

    def addInputNode(self, *args) -> "void":
        return _fast.InferenceEngine_addInputNode(self, *args)

    def addOutputNode(self, *args) -> "void":
        return _fast.InferenceEngine_addOutputNode(self, *args)

    def setInputNodeShape(self, name: "std::string", shape: "TensorShape") -> "void":
        return _fast.InferenceEngine_setInputNodeShape(self, name, shape)

    def setOutputNodeShape(self, name: "std::string", shape: "TensorShape") -> "void":
        return _fast.InferenceEngine_setOutputNodeShape(self, name, shape)

    def getInputNode(self, name: "std::string") -> "fast::InferenceEngine::NetworkNode":
        return _fast.InferenceEngine_getInputNode(self, name)

    def getOutputNode(self, name: "std::string") -> "fast::InferenceEngine::NetworkNode":
        return _fast.InferenceEngine_getOutputNode(self, name)

    def getOutputNodes(self) -> "std::unordered_map< std::string,fast::InferenceEngine::NetworkNode >":
        return _fast.InferenceEngine_getOutputNodes(self)

    def getInputNodes(self) -> "std::unordered_map< std::string,fast::InferenceEngine::NetworkNode >":
        return _fast.InferenceEngine_getInputNodes(self)

    def setInputData(self, inputNodeName: "std::string", tensor: "std::shared_ptr< fast::Tensor >") -> "void":
        return _fast.InferenceEngine_setInputData(self, inputNodeName, tensor)

    def getOutputData(self, inputNodeName: "std::string") -> "std::shared_ptr< fast::Tensor >":
        return _fast.InferenceEngine_getOutputData(self, inputNodeName)

    def load(self) -> "void":
        return _fast.InferenceEngine_load(self)

    def isLoaded(self) -> "bool":
        return _fast.InferenceEngine_isLoaded(self)

    def getPreferredImageOrdering(self) -> "fast::ImageOrdering":
        return _fast.InferenceEngine_getPreferredImageOrdering(self)

    def getName(self) -> "std::string":
        return _fast.InferenceEngine_getName(self)

    def getSupportedModelFormats(self) -> "std::vector< fast::ModelFormat,std::allocator< fast::ModelFormat > >":
        return _fast.InferenceEngine_getSupportedModelFormats(self)

    def getPreferredModelFormat(self) -> "fast::ModelFormat":
        return _fast.InferenceEngine_getPreferredModelFormat(self)

    def isModelFormatSupported(self, format: "fast::ModelFormat") -> "bool":
        return _fast.InferenceEngine_isModelFormatSupported(self, format)

    def setDeviceType(self, type: "fast::InferenceDeviceType") -> "void":
        r"""
        Set which device type the inference engine should use
        (assuming the IE supports multiple devices like OpenVINO)
        :type type: int
        :param type:
        """
        return _fast.InferenceEngine_setDeviceType(self, type)

    def setDevice(self, *args) -> "void":
        r"""
        Specify which device index and/or device type to use
        :type index: int
        :param index: Index of the device to use. -1 means any device can be used
        :type type: int
        :param type:
        """
        return _fast.InferenceEngine_setDevice(self, *args)

    def getDeviceList(self) -> "std::vector< fast::InferenceDeviceInfo,std::allocator< fast::InferenceDeviceInfo > >":
        r"""
        Get a list of devices available for this inference engine.

        :rtype: std::vector< fast::InferenceDeviceInfo,std::allocator< fast::InferenceDeviceInfo > >
        :return: vector with info on each device
        """
        return _fast.InferenceEngine_getDeviceList(self)

    def getMaxBatchSize(self) -> "int":
        return _fast.InferenceEngine_getMaxBatchSize(self)

    def setMaxBatchSize(self, size: "int") -> "void":
        return _fast.InferenceEngine_setMaxBatchSize(self, size)
    __swig_destroy__ = _fast.delete_InferenceEngine

# Register InferenceEngine in _fast:
_fast.InferenceEngine_swigregister(InferenceEngine)

class InferenceEngineManager(object):
    r"""A purely static class to dynamically load inference engines at runtime"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def getEngineList() -> "std::vector< std::string,std::allocator< std::string > >":
        return _fast.InferenceEngineManager_getEngineList()

    @staticmethod
    def loadAll() -> "void":
        return _fast.InferenceEngineManager_loadAll()

    @staticmethod
    def loadEngine(name: "std::string") -> "std::shared_ptr< fast::InferenceEngine >":
        return _fast.InferenceEngineManager_loadEngine(name)

    @staticmethod
    def loadBestAvailableEngine(*args) -> "std::shared_ptr< fast::InferenceEngine >":
        return _fast.InferenceEngineManager_loadBestAvailableEngine(*args)

    @staticmethod
    def isEngineAvailable(name: "std::string") -> "bool":
        return _fast.InferenceEngineManager_isEngineAvailable(name)

    def __init__(self):
        _fast.InferenceEngineManager_swiginit(self, _fast.new_InferenceEngineManager())
    __swig_destroy__ = _fast.delete_InferenceEngineManager

# Register InferenceEngineManager in _fast:
_fast.InferenceEngineManager_swigregister(InferenceEngineManager)

def InferenceEngineManager_getEngineList() -> "std::vector< std::string,std::allocator< std::string > >":
    return _fast.InferenceEngineManager_getEngineList()

def InferenceEngineManager_loadAll() -> "void":
    return _fast.InferenceEngineManager_loadAll()

def InferenceEngineManager_loadEngine(name: "std::string") -> "std::shared_ptr< fast::InferenceEngine >":
    return _fast.InferenceEngineManager_loadEngine(name)

def InferenceEngineManager_loadBestAvailableEngine(*args) -> "std::shared_ptr< fast::InferenceEngine >":
    return _fast.InferenceEngineManager_loadBestAvailableEngine(*args)

def InferenceEngineManager_isEngineAvailable(name: "std::string") -> "bool":
    return _fast.InferenceEngineManager_isEngineAvailable(name)

class InferenceDataList(object):
    r"""A class containing a list of data objects for inference, either FAST images or tensors"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _fast.InferenceDataList_swiginit(self, _fast.new_InferenceDataList(*args))

    def getImages(self) -> "std::vector< std::shared_ptr< fast::Image >,std::allocator< std::shared_ptr< fast::Image > > >":
        return _fast.InferenceDataList_getImages(self)

    def getTensors(self) -> "std::vector< std::shared_ptr< fast::Tensor >,std::allocator< std::shared_ptr< fast::Tensor > > >":
        return _fast.InferenceDataList_getTensors(self)

    def isTensors(self) -> "bool":
        return _fast.InferenceDataList_isTensors(self)

    def isImages(self) -> "bool":
        return _fast.InferenceDataList_isImages(self)

    def getSize(self) -> "int":
        return _fast.InferenceDataList_getSize(self)
    __swig_destroy__ = _fast.delete_InferenceDataList

# Register InferenceDataList in _fast:
_fast.InferenceDataList_swigregister(InferenceDataList)

class Sequence(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Sequence >":
        return _fast.Sequence_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Sequence_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Sequence_getStaticNameOfClass()

    def create(self, *args) -> "void":
        return _fast.Sequence_create(self, *args)
    __swig_destroy__ = _fast.delete_Sequence

# Register Sequence in _fast:
_fast.Sequence_swigregister(Sequence)

def Sequence_New() -> "std::shared_ptr< fast::Sequence >":
    return _fast.Sequence_New()

def Sequence_getStaticNameOfClass() -> "std::string":
    return _fast.Sequence_getStaticNameOfClass()

class Batch(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Batch >":
        return _fast.Batch_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Batch_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Batch_getStaticNameOfClass()

    def create(self, *args) -> "void":
        return _fast.Batch_create(self, *args)
    __swig_destroy__ = _fast.delete_Batch

# Register Batch in _fast:
_fast.Batch_swigregister(Batch)

def Batch_New() -> "std::shared_ptr< fast::Batch >":
    return _fast.Batch_New()

def Batch_getStaticNameOfClass() -> "std::string":
    return _fast.Batch_getStaticNameOfClass()

class NeuralNetwork(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::NeuralNetwork >":
        return _fast.NeuralNetwork_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.NeuralNetwork_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.NeuralNetwork_getStaticNameOfClass()

    def load(self, *args) -> "void":
        r"""
        *Overload 1:*

        Load a given netowrk file. This takes time.
        :type filename: string
        :param filename:

        |

        *Overload 2:*

        Load a network from memory provided as byte two byte vectors: model and weights
        :type model: std::vector< uint8_t,std::allocator< uint8_t > >
        :param model:
        :type weights: std::vector< uint8_t,std::allocator< uint8_t > >
        :param weights:
        """
        return _fast.NeuralNetwork_load(self, *args)

    def setInferenceEngine(self, *args) -> "void":
        r"""
        *Overload 1:*

        Specify which inference engine to use
        :type engine: :py:class:`InferenceEngine`
        :param engine:

        |

        *Overload 2:*

        Specify which inference engine to use
        :type engine: string
        :param engine:
        """
        return _fast.NeuralNetwork_setInferenceEngine(self, *args)

    def getInferenceEngine(self) -> "fast::InferenceEngine::pointer":
        r"""
        Retrieve current inference engine
        :rtype: :py:class:`InferenceEngine`
        :return: 
        """
        return _fast.NeuralNetwork_getInferenceEngine(self)

    def setInputNode(self, *args) -> "void":
        return _fast.NeuralNetwork_setInputNode(self, *args)

    def setOutputNode(self, *args) -> "void":
        return _fast.NeuralNetwork_setOutputNode(self, *args)

    def setScaleFactor(self, scale: "float") -> "void":
        r"""
        For each input value i: new_i = i*scale
        :type scale: float
        :param scale:
        """
        return _fast.NeuralNetwork_setScaleFactor(self, scale)

    def setMeanAndStandardDeviation(self, mean: "float", std: "float") -> "void":
        r"""
        For each input value i: new_i = (i - mean)/std, this is applied after the scale factor
        :type mean: float
        :param mean:
        :type std: float
        :param std:
        """
        return _fast.NeuralNetwork_setMeanAndStandardDeviation(self, mean, std)

    def setMinAndMaxIntensity(self, min: "float", max: "float") -> "void":
        r"""
        Intensities of input image will be clipped at these values
        :type min: float
        :param min:
        :type max: float
        :param max:
        """
        return _fast.NeuralNetwork_setMinAndMaxIntensity(self, min, max)

    def setSignedInputNormalization(self, signedInputNormalization: "bool") -> "void":
        return _fast.NeuralNetwork_setSignedInputNormalization(self, signedInputNormalization)

    def setPreserveAspectRatio(self, preserve: "bool") -> "void":
        return _fast.NeuralNetwork_setPreserveAspectRatio(self, preserve)

    def setHorizontalFlipping(self, flip: "bool") -> "void":
        r"""
        Setting this parameter to true will flip the input image horizontally.
        For pixel classification the output image will be flipped back.
        :type flip: boolean
        :param flip:
        """
        return _fast.NeuralNetwork_setHorizontalFlipping(self, flip)

    def setTemporalWindow(self, window: "uint") -> "void":
        r"""
        Set the temporal window for dynamic mode.
        If window > 1, assume the second dimension of the input tensor is the number of timesteps.
        If the window is set to 4, the frames t-3, t-2, t-1 and t, where t is the current timestep,
        will be given as input to the network.

        :type window: int
        :param window:
        """
        return _fast.NeuralNetwork_setTemporalWindow(self, window)

    def setInputSize(self, name: "std::string", size: "vectori") -> "void":
        return _fast.NeuralNetwork_setInputSize(self, name, size)

    def loadAttributes(self) -> "void":
        return _fast.NeuralNetwork_loadAttributes(self)
    __swig_destroy__ = _fast.delete_NeuralNetwork

# Register NeuralNetwork in _fast:
_fast.NeuralNetwork_swigregister(NeuralNetwork)

def NeuralNetwork_New() -> "std::shared_ptr< fast::NeuralNetwork >":
    return _fast.NeuralNetwork_New()

def NeuralNetwork_getStaticNameOfClass() -> "std::string":
    return _fast.NeuralNetwork_getStaticNameOfClass()

class ImageClassification(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageClassification >":
        return _fast.ImageClassification_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageClassification_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageClassification_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_ImageClassification

# Register ImageClassification in _fast:
_fast.ImageClassification_swigregister(ImageClassification)

def ImageClassification_New() -> "std::shared_ptr< fast::ImageClassification >":
    return _fast.ImageClassification_New()

def ImageClassification_getStaticNameOfClass() -> "std::string":
    return _fast.ImageClassification_getStaticNameOfClass()

class ImageClassificationNetwork(NeuralNetwork):
    r"""Neural network image classification"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageClassificationNetwork >":
        return _fast.ImageClassificationNetwork_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageClassificationNetwork_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageClassificationNetwork_getStaticNameOfClass()

    def setLabels(self, labels: "std::vector< std::string,std::allocator< std::string > >") -> "void":
        return _fast.ImageClassificationNetwork_setLabels(self, labels)

    def loadAttributes(self) -> "void":
        return _fast.ImageClassificationNetwork_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageClassificationNetwork

# Register ImageClassificationNetwork in _fast:
_fast.ImageClassificationNetwork_swigregister(ImageClassificationNetwork)

def ImageClassificationNetwork_New() -> "std::shared_ptr< fast::ImageClassificationNetwork >":
    return _fast.ImageClassificationNetwork_New()

def ImageClassificationNetwork_getStaticNameOfClass() -> "std::string":
    return _fast.ImageClassificationNetwork_getStaticNameOfClass()

class ClassificationToText(ProcessObject):
    r"""ProcessObject to convert a classification into text"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ClassificationToText >":
        return _fast.ClassificationToText_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ClassificationToText_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ClassificationToText_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_ClassificationToText

# Register ClassificationToText in _fast:
_fast.ClassificationToText_swigregister(ClassificationToText)

def ClassificationToText_New() -> "std::shared_ptr< fast::ClassificationToText >":
    return _fast.ClassificationToText_New()

def ClassificationToText_getStaticNameOfClass() -> "std::string":
    return _fast.ClassificationToText_getStaticNameOfClass()

class SegmentationNetwork(NeuralNetwork):
    r"""
    This class is a convienence class for a neural network which performs segmentation
    by having 1 input image, and outputs 1 segmentation image. Internally it uses TensorToSegmentation.
    If you need multi-input or multi-output support, use NeuralNetwork with TensorToSegmentation instead.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SegmentationNetwork >":
        return _fast.SegmentationNetwork_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SegmentationNetwork_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SegmentationNetwork_getStaticNameOfClass()

    def setHeatmapOutput(self) -> "void":
        return _fast.SegmentationNetwork_setHeatmapOutput(self)

    def setSegmentationOutput(self) -> "void":
        return _fast.SegmentationNetwork_setSegmentationOutput(self)

    def setThreshold(self, threshold: "float") -> "void":
        return _fast.SegmentationNetwork_setThreshold(self, threshold)

    def loadAttributes(self) -> "void":
        return _fast.SegmentationNetwork_loadAttributes(self)

    def setResizeBackToOriginalSize(self, resize: "bool") -> "void":
        return _fast.SegmentationNetwork_setResizeBackToOriginalSize(self, resize)
    __swig_destroy__ = _fast.delete_SegmentationNetwork

# Register SegmentationNetwork in _fast:
_fast.SegmentationNetwork_swigregister(SegmentationNetwork)

def SegmentationNetwork_New() -> "std::shared_ptr< fast::SegmentationNetwork >":
    return _fast.SegmentationNetwork_New()

def SegmentationNetwork_getStaticNameOfClass() -> "std::string":
    return _fast.SegmentationNetwork_getStaticNameOfClass()

class BoundingBoxNetwork(NeuralNetwork):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::BoundingBoxNetwork >":
        return _fast.BoundingBoxNetwork_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.BoundingBoxNetwork_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BoundingBoxNetwork_getStaticNameOfClass()

    def setThreshold(self, threshold: "float") -> "void":
        return _fast.BoundingBoxNetwork_setThreshold(self, threshold)

    def loadAttributes(self) -> "void":
        return _fast.BoundingBoxNetwork_loadAttributes(self)

    def setAnchors(self, anchors: "std::vector< std::vector< Vector2f,std::allocator< Vector2f > >,std::allocator< std::vector< Vector2f,std::allocator< Vector2f > > > >") -> "void":
        return _fast.BoundingBoxNetwork_setAnchors(self, anchors)
    __swig_destroy__ = _fast.delete_BoundingBoxNetwork

# Register BoundingBoxNetwork in _fast:
_fast.BoundingBoxNetwork_swigregister(BoundingBoxNetwork)

def BoundingBoxNetwork_New() -> "std::shared_ptr< fast::BoundingBoxNetwork >":
    return _fast.BoundingBoxNetwork_New()

def BoundingBoxNetwork_getStaticNameOfClass() -> "std::string":
    return _fast.BoundingBoxNetwork_getStaticNameOfClass()

class ImagesToSequence(ProcessObject):
    r"""
    This process object converts a stream of images to a stream of sequences of a given size.
    If the sequence size is X, for the first execute, the added item will be copied X times in the sequence.
    New images are added to the end/back of the sequence, while the first/oldest image, is removed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImagesToSequence >":
        return _fast.ImagesToSequence_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImagesToSequence_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImagesToSequence_getStaticNameOfClass()

    def setSequenceSize(self, size: "int") -> "void":
        return _fast.ImagesToSequence_setSequenceSize(self, size)

    def loadAttributes(self) -> "void":
        return _fast.ImagesToSequence_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImagesToSequence

# Register ImagesToSequence in _fast:
_fast.ImagesToSequence_swigregister(ImagesToSequence)

def ImagesToSequence_New() -> "std::shared_ptr< fast::ImagesToSequence >":
    return _fast.ImagesToSequence_New()

def ImagesToSequence_getStaticNameOfClass() -> "std::string":
    return _fast.ImagesToSequence_getStaticNameOfClass()

class FlowNetwork(NeuralNetwork):
    r"""
    A neural network which takes a sequence of images as input, and then
    outputs a flow/displacement vector field. This can be a flow network which
    estimates the motion between two frames.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::FlowNetwork >":
        return _fast.FlowNetwork_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.FlowNetwork_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.FlowNetwork_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_FlowNetwork

# Register FlowNetwork in _fast:
_fast.FlowNetwork_swigregister(FlowNetwork)

def FlowNetwork_New() -> "std::shared_ptr< fast::FlowNetwork >":
    return _fast.FlowNetwork_New()

def FlowNetwork_getStaticNameOfClass() -> "std::string":
    return _fast.FlowNetwork_getStaticNameOfClass()

class TensorToSegmentation(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TensorToSegmentation >":
        return _fast.TensorToSegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TensorToSegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TensorToSegmentation_getStaticNameOfClass()

    def setThreshold(self, threshold: "float") -> "void":
        return _fast.TensorToSegmentation_setThreshold(self, threshold)

    def getThreshold(self) -> "float":
        return _fast.TensorToSegmentation_getThreshold(self)

    def loadAttributes(self) -> "void":
        return _fast.TensorToSegmentation_loadAttributes(self)
    __swig_destroy__ = _fast.delete_TensorToSegmentation

# Register TensorToSegmentation in _fast:
_fast.TensorToSegmentation_swigregister(TensorToSegmentation)

def TensorToSegmentation_New() -> "std::shared_ptr< fast::TensorToSegmentation >":
    return _fast.TensorToSegmentation_New()

def TensorToSegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.TensorToSegmentation_getStaticNameOfClass()

class NonLocalMeans(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::NonLocalMeans >":
        return _fast.NonLocalMeans_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.NonLocalMeans_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.NonLocalMeans_getStaticNameOfClass()

    def setSmoothingAmount(self, parameterH: "float") -> "void":
        return _fast.NonLocalMeans_setSmoothingAmount(self, parameterH)

    def setPreProcess(self, preProcess: "bool") -> "void":
        return _fast.NonLocalMeans_setPreProcess(self, preProcess)

    def setMultiscaleIterations(self, iterations: "int") -> "void":
        return _fast.NonLocalMeans_setMultiscaleIterations(self, iterations)

    def setSearchSize(self, searchSize: "int") -> "void":
        return _fast.NonLocalMeans_setSearchSize(self, searchSize)

    def setFilterSize(self, filterSize: "int") -> "void":
        return _fast.NonLocalMeans_setFilterSize(self, filterSize)

    def loadAttributes(self) -> "void":
        return _fast.NonLocalMeans_loadAttributes(self)
    __swig_destroy__ = _fast.delete_NonLocalMeans

# Register NonLocalMeans in _fast:
_fast.NonLocalMeans_swigregister(NonLocalMeans)

def NonLocalMeans_New() -> "std::shared_ptr< fast::NonLocalMeans >":
    return _fast.NonLocalMeans_New()

def NonLocalMeans_getStaticNameOfClass() -> "std::string":
    return _fast.NonLocalMeans_getStaticNameOfClass()

class NonMaximumSuppression(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::NonMaximumSuppression >":
        return _fast.NonMaximumSuppression_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.NonMaximumSuppression_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.NonMaximumSuppression_getStaticNameOfClass()

    def setThreshold(self, threshold: "float") -> "void":
        return _fast.NonMaximumSuppression_setThreshold(self, threshold)

    def loadAttributes(self) -> "void":
        return _fast.NonMaximumSuppression_loadAttributes(self)
    __swig_destroy__ = _fast.delete_NonMaximumSuppression

# Register NonMaximumSuppression in _fast:
_fast.NonMaximumSuppression_swigregister(NonMaximumSuppression)

def NonMaximumSuppression_New() -> "std::shared_ptr< fast::NonMaximumSuppression >":
    return _fast.NonMaximumSuppression_New()

def NonMaximumSuppression_getStaticNameOfClass() -> "std::string":
    return _fast.NonMaximumSuppression_getStaticNameOfClass()

class Region(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    area = property(_fast.Region_area_get, _fast.Region_area_set)
    label = property(_fast.Region_label_get, _fast.Region_label_set)
    centroid = property(_fast.Region_centroid_get, _fast.Region_centroid_set)
    contour = property(_fast.Region_contour_get, _fast.Region_contour_set)
    pixels = property(_fast.Region_pixels_get, _fast.Region_pixels_set)

    def __init__(self):
        _fast.Region_swiginit(self, _fast.new_Region())
    __swig_destroy__ = _fast.delete_Region

# Register Region in _fast:
_fast.Region_swigregister(Region)

class RegionList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::RegionList >":
        return _fast.RegionList_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.RegionList_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.RegionList_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_RegionList

# Register RegionList in _fast:
_fast.RegionList_swigregister(RegionList)

def RegionList_New() -> "std::shared_ptr< fast::RegionList >":
    return _fast.RegionList_New()

def RegionList_getStaticNameOfClass() -> "std::string":
    return _fast.RegionList_getStaticNameOfClass()

class RegionProperties(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::RegionProperties >":
        return _fast.RegionProperties_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.RegionProperties_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.RegionProperties_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_RegionProperties

# Register RegionProperties in _fast:
_fast.RegionProperties_swigregister(RegionProperties)

def RegionProperties_New() -> "std::shared_ptr< fast::RegionProperties >":
    return _fast.RegionProperties_New()

def RegionProperties_getStaticNameOfClass() -> "std::string":
    return _fast.RegionProperties_getStaticNameOfClass()

class ScaleImage(ProcessObject):
    r"""
    This process object will scale the pixel values of an
    image to a value between 0 and 1 (default) or other
    values if set.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ScaleImage >":
        return _fast.ScaleImage_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ScaleImage_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ScaleImage_getStaticNameOfClass()

    def setLowestValue(self, value: "float") -> "void":
        return _fast.ScaleImage_setLowestValue(self, value)

    def setHighestValue(self, value: "float") -> "void":
        return _fast.ScaleImage_setHighestValue(self, value)
    __swig_destroy__ = _fast.delete_ScaleImage

# Register ScaleImage in _fast:
_fast.ScaleImage_swigregister(ScaleImage)

def ScaleImage_New() -> "std::shared_ptr< fast::ScaleImage >":
    return _fast.ScaleImage_New()

def ScaleImage_getStaticNameOfClass() -> "std::string":
    return _fast.ScaleImage_getStaticNameOfClass()

class SeededRegionGrowing(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SeededRegionGrowing >":
        return _fast.SeededRegionGrowing_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SeededRegionGrowing_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SeededRegionGrowing_getStaticNameOfClass()

    def setIntensityRange(self, min: "float", max: "float") -> "void":
        return _fast.SeededRegionGrowing_setIntensityRange(self, min, max)

    def addSeedPoint(self, *args) -> "void":
        return _fast.SeededRegionGrowing_addSeedPoint(self, *args)
    __swig_destroy__ = _fast.delete_SeededRegionGrowing

# Register SeededRegionGrowing in _fast:
_fast.SeededRegionGrowing_swigregister(SeededRegionGrowing)

def SeededRegionGrowing_New() -> "std::shared_ptr< fast::SeededRegionGrowing >":
    return _fast.SeededRegionGrowing_New()

def SeededRegionGrowing_getStaticNameOfClass() -> "std::string":
    return _fast.SeededRegionGrowing_getStaticNameOfClass()

class SegmentationVolumeReconstructor(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SegmentationVolumeReconstructor >":
        return _fast.SegmentationVolumeReconstructor_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SegmentationVolumeReconstructor_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SegmentationVolumeReconstructor_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_SegmentationVolumeReconstructor

# Register SegmentationVolumeReconstructor in _fast:
_fast.SegmentationVolumeReconstructor_swigregister(SegmentationVolumeReconstructor)

def SegmentationVolumeReconstructor_New() -> "std::shared_ptr< fast::SegmentationVolumeReconstructor >":
    return _fast.SegmentationVolumeReconstructor_New()

def SegmentationVolumeReconstructor_getStaticNameOfClass() -> "std::string":
    return _fast.SegmentationVolumeReconstructor_getStaticNameOfClass()

class Skeletonization(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Skeletonization >":
        return _fast.Skeletonization_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Skeletonization_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Skeletonization_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_Skeletonization

# Register Skeletonization in _fast:
_fast.Skeletonization_swigregister(Skeletonization)

def Skeletonization_New() -> "std::shared_ptr< fast::Skeletonization >":
    return _fast.Skeletonization_New()

def Skeletonization_getStaticNameOfClass() -> "std::string":
    return _fast.Skeletonization_getStaticNameOfClass()

class SurfaceExtraction(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SurfaceExtraction >":
        return _fast.SurfaceExtraction_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SurfaceExtraction_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SurfaceExtraction_getStaticNameOfClass()

    def setThreshold(self, threshold: "float") -> "void":
        return _fast.SurfaceExtraction_setThreshold(self, threshold)
    __swig_destroy__ = _fast.delete_SurfaceExtraction

# Register SurfaceExtraction in _fast:
_fast.SurfaceExtraction_swigregister(SurfaceExtraction)

def SurfaceExtraction_New() -> "std::shared_ptr< fast::SurfaceExtraction >":
    return _fast.SurfaceExtraction_New()

def SurfaceExtraction_getStaticNameOfClass() -> "std::string":
    return _fast.SurfaceExtraction_getStaticNameOfClass()

class TemplateMatching(ProcessObject):
    r"""
    This algorithms matches a template image to an image using normalized cross correlation (NCC),
    sum of absolute differences (SAD) or sum of squared differences (SSD).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TemplateMatching >":
        return _fast.TemplateMatching_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TemplateMatching_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TemplateMatching_getStaticNameOfClass()
    MatchingMetric_NORMALIZED_CROSS_CORRELATION = _fast.TemplateMatching_MatchingMetric_NORMALIZED_CROSS_CORRELATION
    MatchingMetric_SUM_OF_SQUARED_DIFFERENCES = _fast.TemplateMatching_MatchingMetric_SUM_OF_SQUARED_DIFFERENCES
    MatchingMetric_SUM_OF_ABSOLUTE_DIFFERENCES = _fast.TemplateMatching_MatchingMetric_SUM_OF_ABSOLUTE_DIFFERENCES

    def setRegionOfInterest(self, center: "Vector2i", offset: "Vector2i") -> "void":
        r"""
        Set region of interest of where to do the template matching.
        :type center: Vector2i
        :param center: 2D position
        :type offset: Vector2i
        :param offset: in x and y direction
        """
        return _fast.TemplateMatching_setRegionOfInterest(self, center, offset)

    def getBestFitPixelPosition(self) -> "Vector2i":
        r"""
        Get position of best fit
        :rtype: Vector2i
        :return: Vector2i
        """
        return _fast.TemplateMatching_getBestFitPixelPosition(self)

    def getBestFitSubPixelPosition(self) -> "Vector2f":
        r"""
        Get position of best fit with sub pixel accuracy using parabolic fitting
        :rtype: Vector2f
        :return: Vector2f
        """
        return _fast.TemplateMatching_getBestFitSubPixelPosition(self)

    def setMatchingMetric(self, type: "fast::TemplateMatching::MatchingMetric") -> "void":
        r"""
        Select which matching metric to use
        :type type: int
        :param type:
        """
        return _fast.TemplateMatching_setMatchingMetric(self, type)
    __swig_destroy__ = _fast.delete_TemplateMatching

# Register TemplateMatching in _fast:
_fast.TemplateMatching_swigregister(TemplateMatching)

def TemplateMatching_New() -> "std::shared_ptr< fast::TemplateMatching >":
    return _fast.TemplateMatching_New()

def TemplateMatching_getStaticNameOfClass() -> "std::string":
    return _fast.TemplateMatching_getStaticNameOfClass()

class ImageWeightedMovingAverage(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageWeightedMovingAverage >":
        return _fast.ImageWeightedMovingAverage_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageWeightedMovingAverage_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageWeightedMovingAverage_getStaticNameOfClass()

    def setFrameCount(self, frameCount: "int") -> "void":
        return _fast.ImageWeightedMovingAverage_setFrameCount(self, frameCount)

    def setKeepDataType(self, keep: "bool") -> "void":
        return _fast.ImageWeightedMovingAverage_setKeepDataType(self, keep)

    def reset(self) -> "void":
        return _fast.ImageWeightedMovingAverage_reset(self)
    __swig_destroy__ = _fast.delete_ImageWeightedMovingAverage

# Register ImageWeightedMovingAverage in _fast:
_fast.ImageWeightedMovingAverage_swigregister(ImageWeightedMovingAverage)

def ImageWeightedMovingAverage_New() -> "std::shared_ptr< fast::ImageWeightedMovingAverage >":
    return _fast.ImageWeightedMovingAverage_New()

def ImageWeightedMovingAverage_getStaticNameOfClass() -> "std::string":
    return _fast.ImageWeightedMovingAverage_getStaticNameOfClass()

class ImageMovingAverage(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageMovingAverage >":
        return _fast.ImageMovingAverage_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageMovingAverage_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageMovingAverage_getStaticNameOfClass()

    def setFrameCount(self, frameCount: "int") -> "void":
        return _fast.ImageMovingAverage_setFrameCount(self, frameCount)

    def setKeepDataType(self, keep: "bool") -> "void":
        return _fast.ImageMovingAverage_setKeepDataType(self, keep)

    def reset(self) -> "void":
        return _fast.ImageMovingAverage_reset(self)
    __swig_destroy__ = _fast.delete_ImageMovingAverage

# Register ImageMovingAverage in _fast:
_fast.ImageMovingAverage_swigregister(ImageMovingAverage)

def ImageMovingAverage_New() -> "std::shared_ptr< fast::ImageMovingAverage >":
    return _fast.ImageMovingAverage_New()

def ImageMovingAverage_getStaticNameOfClass() -> "std::string":
    return _fast.ImageMovingAverage_getStaticNameOfClass()

class TissueSegmentation(SegmentationAlgorithm):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TissueSegmentation >":
        return _fast.TissueSegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TissueSegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TissueSegmentation_getStaticNameOfClass()

    def setThreshold(self, thresh: "int") -> "void":
        r"""
        Set single threshold for pixel filtering based on the distance a RGB-triplet is from the color white. Default is 85
        :type thresh: int
        :param thresh:
        """
        return _fast.TissueSegmentation_setThreshold(self, thresh)

    def getThreshold(self) -> "int":
        r"""Get current threshold value"""
        return _fast.TissueSegmentation_getThreshold(self)

    def setDilate(self, radius: "int") -> "void":
        r"""
        Set radius for disk used in morphological dilation. Default is 9
        :type radius: int
        :param radius:
        """
        return _fast.TissueSegmentation_setDilate(self, radius)

    def getDilate(self) -> "int":
        r"""Get current dilation value"""
        return _fast.TissueSegmentation_getDilate(self)

    def setErode(self, radius: "int") -> "void":
        r"""
        Set radius for disk used in morphological erosion. Default is 9
        :type radius: int
        :param radius:
        """
        return _fast.TissueSegmentation_setErode(self, radius)

    def getErode(self) -> "int":
        r"""Get current erosion value"""
        return _fast.TissueSegmentation_getErode(self)
    __swig_destroy__ = _fast.delete_TissueSegmentation

# Register TissueSegmentation in _fast:
_fast.TissueSegmentation_swigregister(TissueSegmentation)

def TissueSegmentation_New() -> "std::shared_ptr< fast::TissueSegmentation >":
    return _fast.TissueSegmentation_New()

def TissueSegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.TissueSegmentation_getStaticNameOfClass()

class TubeSegmentationAndCenterlineExtraction(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TubeSegmentationAndCenterlineExtraction >":
        return _fast.TubeSegmentationAndCenterlineExtraction_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TubeSegmentationAndCenterlineExtraction_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TubeSegmentationAndCenterlineExtraction_getStaticNameOfClass()

    def setKeepLargestTree(self, keep: "bool") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setKeepLargestTree(self, keep)

    def setMinimumTreeSize(self, nrOfVoxels: "int") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setMinimumTreeSize(self, nrOfVoxels)

    def setMinimumRadius(self, radius: "float") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setMinimumRadius(self, radius)

    def setMaximumRadius(self, radius: "float") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setMaximumRadius(self, radius)

    def setRadiusStep(self, step: "float") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setRadiusStep(self, step)

    def setSensitivity(self, sensitivity: "float") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setSensitivity(self, sensitivity)

    def setMinimumIntensity(self, intensity: "float") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setMinimumIntensity(self, intensity)

    def setMaximumIntensity(self, intensity: "float") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setMaximumIntensity(self, intensity)

    def extractDarkTubes(self) -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_extractDarkTubes(self)

    def extractBrightTubes(self) -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_extractBrightTubes(self)

    def disableSegmentation(self) -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_disableSegmentation(self)

    def enableSegmentation(self) -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_enableSegmentation(self)

    def disableAutomaticCropping(self) -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_disableAutomaticCropping(self)

    def enableAutomaticCropping(self, lungCropping: "bool"=False) -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_enableAutomaticCropping(self, lungCropping)

    def getSegmentationOutputPort(self) -> "fast::DataChannel::pointer":
        return _fast.TubeSegmentationAndCenterlineExtraction_getSegmentationOutputPort(self)

    def getCenterlineOutputPort(self) -> "fast::DataChannel::pointer":
        return _fast.TubeSegmentationAndCenterlineExtraction_getCenterlineOutputPort(self)

    def getTDFOutputPort(self) -> "fast::DataChannel::pointer":
        return _fast.TubeSegmentationAndCenterlineExtraction_getTDFOutputPort(self)
    __swig_destroy__ = _fast.delete_TubeSegmentationAndCenterlineExtraction

# Register TubeSegmentationAndCenterlineExtraction in _fast:
_fast.TubeSegmentationAndCenterlineExtraction_swigregister(TubeSegmentationAndCenterlineExtraction)

def TubeSegmentationAndCenterlineExtraction_New() -> "std::shared_ptr< fast::TubeSegmentationAndCenterlineExtraction >":
    return _fast.TubeSegmentationAndCenterlineExtraction_New()

def TubeSegmentationAndCenterlineExtraction_getStaticNameOfClass() -> "std::string":
    return _fast.TubeSegmentationAndCenterlineExtraction_getStaticNameOfClass()

class UltrasoundImageCropper(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::UltrasoundImageCropper >":
        return _fast.UltrasoundImageCropper_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.UltrasoundImageCropper_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.UltrasoundImageCropper_getStaticNameOfClass()

    def setPhysicalWidth(self, width: "float") -> "void":
        r"""
        By setting the physical width of the image, the physical height can also
        be calculated and the spacing of the image set correctly.

        :type width: float
        :param width:
        """
        return _fast.UltrasoundImageCropper_setPhysicalWidth(self, width)

    def setStaticCropping(self, staticCropping: "bool") -> "void":
        r"""
        If static cropping is enabled, the cropping parameters are calculated only for the first frame.
        Otherwise, it is recalculated for every frame.
        :type staticCropping: boolean
        :param staticCropping:
        """
        return _fast.UltrasoundImageCropper_setStaticCropping(self, staticCropping)

    def loadAttributes(self) -> "void":
        return _fast.UltrasoundImageCropper_loadAttributes(self)
    __swig_destroy__ = _fast.delete_UltrasoundImageCropper

# Register UltrasoundImageCropper in _fast:
_fast.UltrasoundImageCropper_swigregister(UltrasoundImageCropper)

def UltrasoundImageCropper_New() -> "std::shared_ptr< fast::UltrasoundImageCropper >":
    return _fast.UltrasoundImageCropper_New()

def UltrasoundImageCropper_getStaticNameOfClass() -> "std::string":
    return _fast.UltrasoundImageCropper_getStaticNameOfClass()

class UltrasoundImageEnhancement(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::UltrasoundImageEnhancement >":
        return _fast.UltrasoundImageEnhancement_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.UltrasoundImageEnhancement_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.UltrasoundImageEnhancement_getStaticNameOfClass()

    def loadAttributes(self) -> "void":
        return _fast.UltrasoundImageEnhancement_loadAttributes(self)

    def setReject(self, value: "int") -> "void":
        return _fast.UltrasoundImageEnhancement_setReject(self, value)
    __swig_destroy__ = _fast.delete_UltrasoundImageEnhancement

# Register UltrasoundImageEnhancement in _fast:
_fast.UltrasoundImageEnhancement_swigregister(UltrasoundImageEnhancement)

def UltrasoundImageEnhancement_New() -> "std::shared_ptr< fast::UltrasoundImageEnhancement >":
    return _fast.UltrasoundImageEnhancement_New()

def UltrasoundImageEnhancement_getStaticNameOfClass() -> "std::string":
    return _fast.UltrasoundImageEnhancement_getStaticNameOfClass()

class VectorMedianFilter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::VectorMedianFilter >":
        return _fast.VectorMedianFilter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.VectorMedianFilter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.VectorMedianFilter_getStaticNameOfClass()

    def setWindowSize(self, size: "int") -> "void":
        r"""
        Set window size of median filter. Must be odd
        :type size: int
        :param size:
        """
        return _fast.VectorMedianFilter_setWindowSize(self, size)

    def loadAttributes(self) -> "void":
        return _fast.VectorMedianFilter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_VectorMedianFilter

# Register VectorMedianFilter in _fast:
_fast.VectorMedianFilter_swigregister(VectorMedianFilter)

def VectorMedianFilter_New() -> "std::shared_ptr< fast::VectorMedianFilter >":
    return _fast.VectorMedianFilter_New()

def VectorMedianFilter_getStaticNameOfClass() -> "std::string":
    return _fast.VectorMedianFilter_getStaticNameOfClass()

class MeshVertex(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _fast.MeshVertex_swiginit(self, _fast.new_MeshVertex(*args))

    def getPosition(self) -> "Vector3f":
        return _fast.MeshVertex_getPosition(self)

    def getNormal(self) -> "Vector3f":
        return _fast.MeshVertex_getNormal(self)

    def setPosition(self, position: "Vector3f") -> "void":
        return _fast.MeshVertex_setPosition(self, position)

    def setNormal(self, normal: "Vector3f") -> "void":
        return _fast.MeshVertex_setNormal(self, normal)

    def setLabel(self, label: "int") -> "void":
        return _fast.MeshVertex_setLabel(self, label)

    def getLabel(self) -> "int":
        return _fast.MeshVertex_getLabel(self)

    def setColor(self, color: "Color") -> "void":
        return _fast.MeshVertex_setColor(self, color)

    def getColor(self) -> "fast::Color":
        return _fast.MeshVertex_getColor(self)
    __swig_destroy__ = _fast.delete_MeshVertex

# Register MeshVertex in _fast:
_fast.MeshVertex_swigregister(MeshVertex)

class MeshConnection(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getEndpoint(self, index: "uint") -> "int":
        return _fast.MeshConnection_getEndpoint(self, index)

    def getEndpoint1(self) -> "int":
        return _fast.MeshConnection_getEndpoint1(self)

    def getEndpoint2(self) -> "int":
        return _fast.MeshConnection_getEndpoint2(self)

    def getColor(self) -> "fast::Color":
        return _fast.MeshConnection_getColor(self)

    def setEndpoint(self, endpointIndex: "int", vertexIndex: "int") -> "void":
        return _fast.MeshConnection_setEndpoint(self, endpointIndex, vertexIndex)

    def setEndpoint1(self, index: "uint") -> "void":
        return _fast.MeshConnection_setEndpoint1(self, index)

    def setEndpoint2(self, index: "uint") -> "void":
        return _fast.MeshConnection_setEndpoint2(self, index)

    def setColor(self, color: "Color") -> "void":
        return _fast.MeshConnection_setColor(self, color)
    __swig_destroy__ = _fast.delete_MeshConnection

# Register MeshConnection in _fast:
_fast.MeshConnection_swigregister(MeshConnection)

class MeshLine(MeshConnection):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _fast.MeshLine_swiginit(self, _fast.new_MeshLine(*args))
    __swig_destroy__ = _fast.delete_MeshLine

# Register MeshLine in _fast:
_fast.MeshLine_swigregister(MeshLine)

class MeshTriangle(MeshConnection):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _fast.MeshTriangle_swiginit(self, _fast.new_MeshTriangle(*args))

    def getEndpoint3(self) -> "int":
        return _fast.MeshTriangle_getEndpoint3(self)

    def setEndpoint3(self, index: "uint") -> "void":
        return _fast.MeshTriangle_setEndpoint3(self, index)
    __swig_destroy__ = _fast.delete_MeshTriangle

# Register MeshTriangle in _fast:
_fast.MeshTriangle_swigregister(MeshTriangle)

class MeshAccess(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, mCoordinates: "vectorf", mNormals: "vectorf", mColors: "vectorf", mLines: "std::vector< uint,std::allocator< uint > > *", mTriangles: "std::vector< uint,std::allocator< uint > > *", mesh: "std::shared_ptr< fast::Mesh >"):
        _fast.MeshAccess_swiginit(self, _fast.new_MeshAccess(mCoordinates, mNormals, mColors, mLines, mTriangles, mesh))

    def getVertex(self, i: "uint") -> "fast::MeshVertex":
        return _fast.MeshAccess_getVertex(self, i)

    def setVertex(self, i: "uint", arg3: "MeshVertex") -> "void":
        return _fast.MeshAccess_setVertex(self, i, arg3)

    def addVertex(self, v: "MeshVertex") -> "void":
        return _fast.MeshAccess_addVertex(self, v)

    def getTriangle(self, i: "uint") -> "fast::MeshTriangle":
        return _fast.MeshAccess_getTriangle(self, i)

    def setTriangle(self, i: "uint", arg3: "MeshTriangle") -> "void":
        return _fast.MeshAccess_setTriangle(self, i, arg3)

    def addTriangle(self, t: "MeshTriangle") -> "void":
        return _fast.MeshAccess_addTriangle(self, t)

    def getLine(self, i: "uint") -> "fast::MeshLine":
        return _fast.MeshAccess_getLine(self, i)

    def setLine(self, i: "uint", arg3: "MeshLine") -> "void":
        return _fast.MeshAccess_setLine(self, i, arg3)

    def addLine(self, l: "MeshLine") -> "void":
        return _fast.MeshAccess_addLine(self, l)

    def getTriangles(self) -> "std::vector< fast::MeshTriangle,std::allocator< fast::MeshTriangle > >":
        return _fast.MeshAccess_getTriangles(self)

    def getLines(self) -> "std::vector< fast::MeshLine,std::allocator< fast::MeshLine > >":
        return _fast.MeshAccess_getLines(self)

    def getVertices(self) -> "std::vector< fast::MeshVertex,std::allocator< fast::MeshVertex > >":
        return _fast.MeshAccess_getVertices(self)

    def release(self) -> "void":
        return _fast.MeshAccess_release(self)
    __swig_destroy__ = _fast.delete_MeshAccess

# Register MeshAccess in _fast:
_fast.MeshAccess_swigregister(MeshAccess)

class MeshOpenCLAccess(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, coordinatesBuffer: "cl::Buffer *", lineBuffer: "cl::Buffer *", triangleBuffer: "cl::Buffer *", mesh: "std::shared_ptr< fast::Mesh >"):
        _fast.MeshOpenCLAccess_swiginit(self, _fast.new_MeshOpenCLAccess(coordinatesBuffer, lineBuffer, triangleBuffer, mesh))

    def getCoordinatesBuffer(self) -> "cl::Buffer *":
        return _fast.MeshOpenCLAccess_getCoordinatesBuffer(self)

    def getLineBuffer(self) -> "cl::Buffer *":
        return _fast.MeshOpenCLAccess_getLineBuffer(self)

    def getTriangleBuffer(self) -> "cl::Buffer *":
        return _fast.MeshOpenCLAccess_getTriangleBuffer(self)

    def release(self) -> "void":
        return _fast.MeshOpenCLAccess_release(self)
    __swig_destroy__ = _fast.delete_MeshOpenCLAccess

# Register MeshOpenCLAccess in _fast:
_fast.MeshOpenCLAccess_swigregister(MeshOpenCLAccess)

class VertexBufferObjectAccess(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getCoordinateVBO(self) -> "GLuint *":
        return _fast.VertexBufferObjectAccess_getCoordinateVBO(self)

    def getNormalVBO(self) -> "GLuint *":
        return _fast.VertexBufferObjectAccess_getNormalVBO(self)

    def getColorVBO(self) -> "GLuint *":
        return _fast.VertexBufferObjectAccess_getColorVBO(self)

    def getLineEBO(self) -> "GLuint *":
        return _fast.VertexBufferObjectAccess_getLineEBO(self)

    def getTriangleEBO(self) -> "GLuint *":
        return _fast.VertexBufferObjectAccess_getTriangleEBO(self)

    def hasNormalVBO(self) -> "bool":
        return _fast.VertexBufferObjectAccess_hasNormalVBO(self)

    def hasColorVBO(self) -> "bool":
        return _fast.VertexBufferObjectAccess_hasColorVBO(self)

    def hasEBO(self) -> "bool":
        return _fast.VertexBufferObjectAccess_hasEBO(self)

    def __init__(self, coordinateVBO: "GLuint", normalVBO: "GLuint", colorVBO: "GLuint", lineEBO: "GLuint", triangleEBO: "GLuint", useNormalVBO: "bool", useColorVBO: "bool", useEBO: "bool", mesh: "std::shared_ptr< fast::Mesh >"):
        _fast.VertexBufferObjectAccess_swiginit(self, _fast.new_VertexBufferObjectAccess(coordinateVBO, normalVBO, colorVBO, lineEBO, triangleEBO, useNormalVBO, useColorVBO, useEBO, mesh))

    def release(self) -> "void":
        return _fast.VertexBufferObjectAccess_release(self)
    __swig_destroy__ = _fast.delete_VertexBufferObjectAccess

# Register VertexBufferObjectAccess in _fast:
_fast.VertexBufferObjectAccess_swigregister(VertexBufferObjectAccess)

class TensorAccess(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, data: "float *", shape: "TensorShape", tensor: "std::shared_ptr< fast::Tensor >"):
        _fast.TensorAccess_swiginit(self, _fast.new_TensorAccess(data, shape, tensor))

    def getRawData(self) -> "float *":
        return _fast.TensorAccess_getRawData(self)

    def getShape(self) -> "TensorShape":
        return _fast.TensorAccess_getShape(self)
    __swig_destroy__ = _fast.delete_TensorAccess

    def release(self) -> "void":
        return _fast.TensorAccess_release(self)

# Register TensorAccess in _fast:
_fast.TensorAccess_swigregister(TensorAccess)

class ImagePyramidAccess(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, levels: "std::vector< fast::ImagePyramidLevel,std::allocator< fast::ImagePyramidLevel > >", fileHandle: "openslide_t *", imagePyramid: "std::shared_ptr< fast::ImagePyramid >", writeAccess: "bool"):
        _fast.ImagePyramidAccess_swiginit(self, _fast.new_ImagePyramidAccess(levels, fileHandle, imagePyramid, writeAccess))

    def setScalar(self, x: "uint", y: "uint", level: "uint", value: "uint8_t", channel: "uint"=0) -> "void":
        return _fast.ImagePyramidAccess_setScalar(self, x, y, level, value, channel)

    def setScalarFast(self, x: "uint", y: "uint", level: "uint", value: "uint8_t", channel: "uint"=0) -> "void":
        return _fast.ImagePyramidAccess_setScalarFast(self, x, y, level, value, channel)

    def getScalar(self, x: "uint", y: "uint", level: "uint", channel: "uint"=0) -> "uint8_t":
        return _fast.ImagePyramidAccess_getScalar(self, x, y, level, channel)

    def getScalarFast(self, x: "uint", y: "uint", level: "uint", channel: "uint"=0) -> "uint8_t":
        return _fast.ImagePyramidAccess_getScalarFast(self, x, y, level, channel)

    def getLevelAsImage(self, level: "int") -> "std::shared_ptr< fast::Image >":
        return _fast.ImagePyramidAccess_getLevelAsImage(self, level)

    def getPatchAsImage(self, *args) -> "std::shared_ptr< fast::Image >":
        return _fast.ImagePyramidAccess_getPatchAsImage(self, *args)

    def release(self) -> "void":
        return _fast.ImagePyramidAccess_release(self)
    __swig_destroy__ = _fast.delete_ImagePyramidAccess

# Register ImagePyramidAccess in _fast:
_fast.ImagePyramidAccess_swigregister(ImagePyramidAccess)

class BoundingBox(SpatialDataObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::BoundingBox >":
        return _fast.BoundingBox_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.BoundingBox_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BoundingBox_getStaticNameOfClass()

    def create(self, position: "Vector2f", size: "Vector2f", label: "uchar"=1, score: "float"=0.0) -> "void":
        r"""Create bounding box object with position and size set in millimeters"""
        return _fast.BoundingBox_create(self, position, size, label, score)

    def setLabel(self, label: "uchar") -> "void":
        return _fast.BoundingBox_setLabel(self, label)

    def getLabel(self) -> "uchar":
        return _fast.BoundingBox_getLabel(self)

    def setPosition(self, position: "Vector2f") -> "void":
        r"""Set position in millimeters"""
        return _fast.BoundingBox_setPosition(self, position)

    def getPosition(self) -> "Vector2f":
        return _fast.BoundingBox_getPosition(self)

    def setSize(self, size: "Vector2f") -> "void":
        r"""Set size in millimeters"""
        return _fast.BoundingBox_setSize(self, size)

    def getSize(self) -> "Vector2f":
        return _fast.BoundingBox_getSize(self)

    def setScore(self, score: "float") -> "void":
        return _fast.BoundingBox_setScore(self, score)

    def getScore(self) -> "float":
        return _fast.BoundingBox_getScore(self)

    def free(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.BoundingBox_free(self, device)

    def freeAll(self) -> "void":
        return _fast.BoundingBox_freeAll(self)

    def intersectionOverUnion(self, bbox2: "fast::BoundingBox::pointer") -> "float":
        return _fast.BoundingBox_intersectionOverUnion(self, bbox2)
    __swig_destroy__ = _fast.delete_BoundingBox

# Register BoundingBox in _fast:
_fast.BoundingBox_swigregister(BoundingBox)

def BoundingBox_New() -> "std::shared_ptr< fast::BoundingBox >":
    return _fast.BoundingBox_New()

def BoundingBox_getStaticNameOfClass() -> "std::string":
    return _fast.BoundingBox_getStaticNameOfClass()

class BoundingBoxSet(SpatialDataObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::BoundingBoxSet >":
        return _fast.BoundingBoxSet_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.BoundingBoxSet_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BoundingBoxSet_getStaticNameOfClass()

    def create(self) -> "void":
        return _fast.BoundingBoxSet_create(self)

    def getNrOfLines(self) -> "int":
        return _fast.BoundingBoxSet_getNrOfLines(self)

    def getNrOfVertices(self) -> "int":
        return _fast.BoundingBoxSet_getNrOfVertices(self)

    def getAccess(self, type: "accessType") -> "fast::BoundingBoxSetAccess::pointer":
        return _fast.BoundingBoxSet_getAccess(self, type)

    def getOpenGLAccess(self, type: "accessType") -> "fast::BoundingBoxSetOpenGLAccess::pointer":
        return _fast.BoundingBoxSet_getOpenGLAccess(self, type)

    def freeAll(self) -> "void":
        return _fast.BoundingBoxSet_freeAll(self)

    def free(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.BoundingBoxSet_free(self, device)
    __swig_destroy__ = _fast.delete_BoundingBoxSet

    def getBoundingBox(self) -> "DataBoundingBox":
        return _fast.BoundingBoxSet_getBoundingBox(self)

# Register BoundingBoxSet in _fast:
_fast.BoundingBoxSet_swigregister(BoundingBoxSet)

def BoundingBoxSet_New() -> "std::shared_ptr< fast::BoundingBoxSet >":
    return _fast.BoundingBoxSet_New()

def BoundingBoxSet_getStaticNameOfClass() -> "std::string":
    return _fast.BoundingBoxSet_getStaticNameOfClass()

class BoundingBoxSetAccumulator(ProcessObject):
    r"""Process object which accumulates incoming bounding box sets to a single bounding box set."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::BoundingBoxSetAccumulator >":
        return _fast.BoundingBoxSetAccumulator_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.BoundingBoxSetAccumulator_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BoundingBoxSetAccumulator_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_BoundingBoxSetAccumulator

# Register BoundingBoxSetAccumulator in _fast:
_fast.BoundingBoxSetAccumulator_swigregister(BoundingBoxSetAccumulator)

def BoundingBoxSetAccumulator_New() -> "std::shared_ptr< fast::BoundingBoxSetAccumulator >":
    return _fast.BoundingBoxSetAccumulator_New()

def BoundingBoxSetAccumulator_getStaticNameOfClass() -> "std::string":
    return _fast.BoundingBoxSetAccumulator_getStaticNameOfClass()

class Image(SpatialDataObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Image >":
        return _fast.Image_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Image_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Image_getStaticNameOfClass()

    def createFromImage(self, image: "fast::Image::pointer") -> "void":
        r"""
        Setup an image object with the same size, data type and pixel spacing as the given image.
        Does not allocate any memory.

        :type image: :py:class:`Image`
        :param image: to copy size and pixel spacing from
        """
        return _fast.Image_createFromImage(self, image)

    def create(self, *args) -> "void":
        r"""
        *Overload 1:*

        Setup a 2D/3D image object, but does not allocate any memory

        :type size: fast::VectorXui
        :param size:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:

        |

        *Overload 2:*

        Setup a 2D image object, but does not allocate any memory

        :type width: int
        :param width:
        :type height: int
        :param height:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:

        |

        *Overload 3:*

        Setup a 3D image object, but does not allocate any memory.

        :type width: int
        :param width:
        :type height: int
        :param height:
        :type depth: int
        :param depth:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:

        |

        *Overload 4:*

        Copies 2D/3D data to given device

        :type size: fast::VectorXui
        :param size:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:
        :type device: :py:class:`ExecutionDevice`
        :param device:
        :type data: void
        :param data:

        |

        *Overload 5:*

        Copies 2D data to given device

        :type width: int
        :param width:
        :type height: int
        :param height:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:
        :type device: :py:class:`ExecutionDevice`
        :param device:
        :type data: void
        :param data:

        |

        *Overload 6:*

        Copies 3D data to given device

        :type width: int
        :param width:
        :type height: int
        :param height:
        :type depth: int
        :param depth:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:
        :type device: :py:class:`ExecutionDevice`
        :param device:
        :type data: void
        :param data:

        |

        *Overload 7:*

        Copies 2D/3D data to default device

        :type size: fast::VectorXui
        :param size:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:
        :type data: void
        :param data:

        |

        *Overload 8:*

        Copies 2D data to default device

        :type width: int
        :param width:
        :type height: int
        :param height:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:
        :type data: void
        :param data:

        |

        *Overload 9:*

        Copies 3D data to default device

        :type width: int
        :param width:
        :type height: int
        :param height:
        :type depth: int
        :param depth:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:
        :type data: void
        :param data:
        """
        return _fast.Image_create(self, *args)

    def getOpenCLImageAccess(self, type: "accessType", arg3: "fast::OpenCLDevice::pointer") -> "fast::OpenCLImageAccess::pointer":
        return _fast.Image_getOpenCLImageAccess(self, type, arg3)

    def getOpenCLBufferAccess(self, type: "accessType", arg3: "fast::OpenCLDevice::pointer") -> "fast::OpenCLBufferAccess::pointer":
        return _fast.Image_getOpenCLBufferAccess(self, type, arg3)

    def getImageAccess(self, type: "accessType") -> "fast::ImageAccess::pointer":
        return _fast.Image_getImageAccess(self, type)
    __swig_destroy__ = _fast.delete_Image

    def getWidth(self) -> "int":
        return _fast.Image_getWidth(self)

    def getHeight(self) -> "int":
        return _fast.Image_getHeight(self)

    def getDepth(self) -> "int":
        return _fast.Image_getDepth(self)

    def getNrOfVoxels(self) -> "int":
        r"""
        :rtype: int
        :return: the number of pixels/voxels width*height*depth
        """
        return _fast.Image_getNrOfVoxels(self)

    def getSize(self) -> "fast::Vector3ui":
        return _fast.Image_getSize(self)

    def getDimensions(self) -> "uchar":
        return _fast.Image_getDimensions(self)

    def getDataType(self) -> "fast::DataType":
        return _fast.Image_getDataType(self)

    def getNrOfChannels(self) -> "int":
        return _fast.Image_getNrOfChannels(self)

    def getSpacing(self) -> "Vector3f":
        return _fast.Image_getSpacing(self)

    def setSpacing(self, *args) -> "void":
        return _fast.Image_setSpacing(self, *args)

    def calculateMaximumIntensity(self) -> "float":
        return _fast.Image_calculateMaximumIntensity(self)

    def calculateMinimumIntensity(self) -> "float":
        return _fast.Image_calculateMinimumIntensity(self)

    def calculateAverageIntensity(self) -> "float":
        return _fast.Image_calculateAverageIntensity(self)

    def copy(self, device: "fast::ExecutionDevice::pointer") -> "fast::Image::pointer":
        r"""Copy image and put contents to specific device"""
        return _fast.Image_copy(self, device)

    def crop(self, offset: "VectorXi", size: "VectorXi", allowOutOfBoundsCropping: "bool"=False) -> "fast::Image::pointer":
        r"""Create a new image which is a cropped version of this image"""
        return _fast.Image_crop(self, offset, size, allowOutOfBoundsCropping)

    def fill(self, value: "float") -> "void":
        r"""
        Fill entire image with a value
        :type value: float
        :param value:
        """
        return _fast.Image_fill(self, value)

    def getTransformedBoundingBox(self) -> "DataBoundingBox":
        return _fast.Image_getTransformedBoundingBox(self)

    def getBoundingBox(self) -> "DataBoundingBox":
        return _fast.Image_getBoundingBox(self)

    def free(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.Image_free(self, device)

    def freeAll(self) -> "void":
        return _fast.Image_freeAll(self)

    def _getHostDataPointer(self) -> "std::size_t":
        return _fast.Image__getHostDataPointer(self)

    def _intToVoidPointer(self, intPointer: "std::size_t") -> "void *":
        return _fast.Image__intToVoidPointer(self, intPointer)

    _data_type_to_str = {
      TYPE_UINT8: 'u1',
      TYPE_INT8: 'i1',
      TYPE_UINT16: 'u2',
      TYPE_INT16: 'i2',
      TYPE_FLOAT: 'f4',
    }
    _str_to_data_type = {value : key for (key, value) in _data_type_to_str.items()}
    @property
    def __array_interface__(self):
      if self.getDimensions() == 2:
          shape = (self.getHeight(), self.getWidth(), self.getNrOfChannels())
      else:
          shape = (self.getDepth(), self.getHeight(), self.getWidth(), self.getNrOfChannels())
      return {
        'shape': shape,
        'data': (self._getHostDataPointer(), False),
        'typestr': self._data_type_to_str[self.getDataType()],
        'version': 3,
        'strides': None,
      }


    def createFromArray(self, ndarray):
      """Create a FAST image from a N-D array (e.g. numpy ndarray)"""
      if not hasattr(ndarray, '__array_interface__'):
        raise ValueError('Input to Image createFromArray() must have the array_interface property')
      array_interface = ndarray.__array_interface__
      shape = array_interface['shape']
      is_2d = True
      has_channels = False
      if len(shape) > 2 and shape[-1] <= 4:
          has_channels = True
      elif len(shape) == 3 and shape[-1] > 4:
          is_2d = False
      elif len(shape) > 3:
          is_2d = False
          has_channels = True
      if is_2d:
          self.create(
              shape[1],
              shape[0],
              self._str_to_data_type[array_interface['typestr'][1:]],
              shape[-1] if has_channels else 1,
                  self._intToVoidPointer(array_interface['data'][0])
          )
      else:
          self.create(
              shape[2],
              shape[1],
              shape[0],
              self._str_to_data_type[array_interface['typestr'][1:]],
              shape[-1] if has_channels else 1,
                  self._intToVoidPointer(array_interface['data'][0])
          )


# Register Image in _fast:
_fast.Image_swigregister(Image)

def Image_New() -> "std::shared_ptr< fast::Image >":
    return _fast.Image_New()

def Image_getStaticNameOfClass() -> "std::string":
    return _fast.Image_getStaticNameOfClass()

class Mesh(SpatialDataObject):
    r"""
    The mesh data object contains vertices and optionally a set of lines and/or triangles.
         Each vertex is represented as a MeshVertex and the lines and triangles as MeshLine and MeshTriangle respectively.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Mesh >":
        return _fast.Mesh_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Mesh_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Mesh_getStaticNameOfClass()

    def create(self, *args) -> "void":
        return _fast.Mesh_create(self, *args)

    def getVertexBufferObjectAccess(self, access: "accessType") -> "fast::VertexBufferObjectAccess::pointer":
        return _fast.Mesh_getVertexBufferObjectAccess(self, access)

    def getMeshAccess(self, access: "accessType") -> "fast::MeshAccess::pointer":
        return _fast.Mesh_getMeshAccess(self, access)

    def getOpenCLAccess(self, access: "accessType", device: "fast::OpenCLDevice::pointer") -> "fast::MeshOpenCLAccess::pointer":
        return _fast.Mesh_getOpenCLAccess(self, access, device)

    def getNrOfTriangles(self) -> "int":
        return _fast.Mesh_getNrOfTriangles(self)

    def getNrOfLines(self) -> "int":
        return _fast.Mesh_getNrOfLines(self)

    def getNrOfVertices(self) -> "int":
        return _fast.Mesh_getNrOfVertices(self)

    def setBoundingBox(self, box: "DataBoundingBox") -> "void":
        return _fast.Mesh_setBoundingBox(self, box)
    __swig_destroy__ = _fast.delete_Mesh

# Register Mesh in _fast:
_fast.Mesh_swigregister(Mesh)

def Mesh_New() -> "std::shared_ptr< fast::Mesh >":
    return _fast.Mesh_New()

def Mesh_getStaticNameOfClass() -> "std::string":
    return _fast.Mesh_getStaticNameOfClass()

class TensorShape(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Construct tensor shape
        :type dimensions: std::initializer_list< int >
        :param dimensions:

        |

        *Overload 2:*

        Construct tensor shape
        :type dimensions: VectorXi
        :param dimensions:

        |

        *Overload 3:*

        Construct tensor shape
        :type dimensions: std::vector< int,std::allocator< int > >
        :param dimensions:

        |

        *Overload 4:*

        Copy constructor
        :type other: :py:class:`TensorShape`
        :param other:

        |

        *Overload 5:*

        Construct empty (invalid) tensor shape
        """
        _fast.TensorShape_swiginit(self, _fast.new_TensorShape(*args))

    def empty(self) -> "bool":
        r"""If shape is empty or not"""
        return _fast.TensorShape_empty(self)

    def getTotalSize(self) -> "int":
        r"""
        Total size of tensor, excluding any unknown dimensions
        :rtype: int
        :return: 
        """
        return _fast.TensorShape_getTotalSize(self)

    def getDimensions(self) -> "int":
        r"""
        Get nr of dimensions
        :rtype: int
        :return: 
        """
        return _fast.TensorShape_getDimensions(self)

    def getKnownDimensions(self) -> "int":
        r"""
        Get nr of known dimensions (dimension not -1)
        :rtype: int
        :return: 
        """
        return _fast.TensorShape_getKnownDimensions(self)

    def getUnknownDimensions(self) -> "int":
        r"""Get nr of unknown dimensions (dimensions that are -1)"""
        return _fast.TensorShape_getUnknownDimensions(self)

    def getAll(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Get all dimensions as vector
        :rtype: std::vector< int,std::allocator< int > >
        :return: 
        """
        return _fast.TensorShape_getAll(self)

    def setDimension(self, i: "int", value: "int") -> "void":
        r"""
        Set dimension i to value
        :type i: int
        :param i:
        :type value: int
        :param value:
        """
        return _fast.TensorShape_setDimension(self, i, value)

    def addDimension(self, value: "int") -> "void":
        r"""
        Add a dimension to the end of the shape with value
        :type value: int
        :param value:
        """
        return _fast.TensorShape_addDimension(self, value)

    def insertDimension(self, position: "int", value: "int") -> "void":
        r"""
        Insert a new dimension at a given position with the given value
        :type position: int
        :param position:
        :type value: int
        :param value:
        """
        return _fast.TensorShape_insertDimension(self, position, value)

    def toString(self) -> "std::string":
        r"""Convert shape into string"""
        return _fast.TensorShape_toString(self)

    def deleteDimension(self, index: "int") -> "void":
        r"""
        Delete a dimension
        :type index: int
        :param index:
        """
        return _fast.TensorShape_deleteDimension(self, index)

    def deleteDimensions(self, startIndex: "int", endIndex: "int") -> "void":
        r"""
        Delete a range of dimensions
        :type startIndex: int
        :param startIndex:
        :type endIndex: int
        :param endIndex:
        """
        return _fast.TensorShape_deleteDimensions(self, startIndex, endIndex)
    __swig_destroy__ = _fast.delete_TensorShape

# Register TensorShape in _fast:
_fast.TensorShape_swigregister(TensorShape)

class Tensor(SpatialDataObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Tensor >":
        return _fast.Tensor_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Tensor_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Tensor_getStaticNameOfClass()

    def create(self, *args) -> "void":
        r"""
        *Overload 1:*

        Create a tensor using the provided data and shape. This method will COPY the data.
        :type data: float
        :param data:
        :type shape: :py:class:`TensorShape`
        :param shape:

        |

        *Overload 2:*

        Create an unitialized tensor with the provided shape
        :type shape: :py:class:`TensorShape`
        :param shape:

        |

        *Overload 3:*

        Create a 1D tensor with the provided data. Its shape will be equal to its length
        :type data: std::initializer_list< float >
        :param data:
        """
        return _fast.Tensor_create(self, *args)

    def expandDims(self, position: "int"=0) -> "void":
        r"""
        Add a dimension of size 1 at provided position. -1 is last position.
        :type position: int
        :param position:
        """
        return _fast.Tensor_expandDims(self, position)

    def getShape(self) -> "fast::TensorShape":
        return _fast.Tensor_getShape(self)

    def getAccess(self, type: "accessType") -> "fast::TensorAccess::pointer":
        return _fast.Tensor_getAccess(self, type)

    def getOpenCLBufferAccess(self, type: "accessType", arg3: "fast::OpenCLDevice::pointer") -> "std::unique_ptr< fast::OpenCLBufferAccess >":
        return _fast.Tensor_getOpenCLBufferAccess(self, type, arg3)

    def freeAll(self) -> "void":
        return _fast.Tensor_freeAll(self)

    def free(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.Tensor_free(self, device)

    def setSpacing(self, spacing: "VectorXf") -> "void":
        return _fast.Tensor_setSpacing(self, spacing)

    def getSpacing(self) -> "VectorXf":
        return _fast.Tensor_getSpacing(self)

    def deleteDimension(self, dimension: "int") -> "void":
        return _fast.Tensor_deleteDimension(self, dimension)

    def getTransformedBoundingBox(self) -> "DataBoundingBox":
        return _fast.Tensor_getTransformedBoundingBox(self)

    def getBoundingBox(self) -> "DataBoundingBox":
        return _fast.Tensor_getBoundingBox(self)
    __swig_destroy__ = _fast.delete_Tensor

    def _getHostDataPointer(self) -> "std::size_t":
        return _fast.Tensor__getHostDataPointer(self)

    def _intToFloatPointer(self, intPointer: "std::size_t") -> "float *":
        return _fast.Tensor__intToFloatPointer(self, intPointer)

    @property
    def __array_interface__(self):
      return {
        'shape': self.getShape().getAll(),
        'data': (self._getHostDataPointer(), False),
        'typestr': 'f4',
        'version': 3,
        'strides': None,
      }


    def createFromArray(self, ndarray):
      """Create a FAST Tensor from a N-D array (e.g. numpy ndarray)"""
      if not hasattr(ndarray, '__array_interface__'):
        raise ValueError('Input to Tensor createFromArray() must have the array_interface property')
      array_interface = ndarray.__array_interface__
    # Check data type if it is correct
      if array_interface['typestr'] != 'f4':
        import numpy as np
    # Convert if numpy, else raise error
        if isinstance(ndarray, np.ndarray):
          print('WARNING: ndarray given to fast::Tensor::createFromArray was not 32 bit float and will now be converted.')
          ndarray = ndarray.astype(np.float32)
          array_interface = ndarray.__array_interface__
        else:
          raise ValueError('Array given to Tensor::createFromArray must be 32 bit float, but you sent ' + array_interface['typestr'])
      shape = array_interface['shape']
      fast_shape = TensorShape()
      for i in shape:
          fast_shape.addDimension(i)

      self.create(self._intToFloatPointer(array_interface['data'][0]), fast_shape)


# Register Tensor in _fast:
_fast.Tensor_swigregister(Tensor)

def Tensor_New() -> "std::shared_ptr< fast::Tensor >":
    return _fast.Tensor_New()

def Tensor_getStaticNameOfClass() -> "std::string":
    return _fast.Tensor_getStaticNameOfClass()

class Segmentation(Image):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Segmentation >":
        return _fast.Segmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Segmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Segmentation_getStaticNameOfClass()

    def createFromImage(self, image: "fast::Image::pointer") -> "void":
        return _fast.Segmentation_createFromImage(self, image)
    LABEL_BACKGROUND = _fast.Segmentation_LABEL_BACKGROUND
    LABEL_FOREGROUND = _fast.Segmentation_LABEL_FOREGROUND
    LABEL_BLOOD = _fast.Segmentation_LABEL_BLOOD
    LABEL_VEIN = _fast.Segmentation_LABEL_VEIN
    LABEL_ARTERY = _fast.Segmentation_LABEL_ARTERY
    LABEL_BONE = _fast.Segmentation_LABEL_BONE
    LABEL_MUSCLE = _fast.Segmentation_LABEL_MUSCLE
    LABEL_NERVE = _fast.Segmentation_LABEL_NERVE
    LABEL_YELLOW = _fast.Segmentation_LABEL_YELLOW
    LABEL_GREEN = _fast.Segmentation_LABEL_GREEN
    LABEL_MAGENTA = _fast.Segmentation_LABEL_MAGENTA
    LABEL_RED = _fast.Segmentation_LABEL_RED
    LABEL_WHITE = _fast.Segmentation_LABEL_WHITE
    LABEL_BLUE = _fast.Segmentation_LABEL_BLUE
    __swig_destroy__ = _fast.delete_Segmentation

# Register Segmentation in _fast:
_fast.Segmentation_swigregister(Segmentation)

def Segmentation_New() -> "std::shared_ptr< fast::Segmentation >":
    return _fast.Segmentation_New()

def Segmentation_getStaticNameOfClass() -> "std::string":
    return _fast.Segmentation_getStaticNameOfClass()

class Text(SpatialDataObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Text >":
        return _fast.Text_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Text_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Text_getStaticNameOfClass()

    def create(self, *args) -> "void":
        return _fast.Text_create(self, *args)

    def setPosition(self, position: "Vector2f") -> "void":
        return _fast.Text_setPosition(self, position)

    def free(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.Text_free(self, device)

    def freeAll(self) -> "void":
        return _fast.Text_freeAll(self)

    def getText(self) -> "std::string":
        return _fast.Text_getText(self)

    def setText(self, text: "std::string") -> "void":
        return _fast.Text_setText(self, text)

    def getColor(self) -> "fast::Color":
        return _fast.Text_getColor(self)

    def setColor(self, color: "Color") -> "void":
        return _fast.Text_setColor(self, color)

    def setTextHeight(self, millimeters: "float") -> "void":
        return _fast.Text_setTextHeight(self, millimeters)

    def getTextHeight(self) -> "float":
        return _fast.Text_getTextHeight(self)
    __swig_destroy__ = _fast.delete_Text

# Register Text in _fast:
_fast.Text_swigregister(Text)

def Text_New() -> "std::shared_ptr< fast::Text >":
    return _fast.Text_New()

def Text_getStaticNameOfClass() -> "std::string":
    return _fast.Text_getStaticNameOfClass()

class ImagePyramid(SpatialDataObject):
    r"""
    Data object for storing large images as tiled image pyramids.
    Storage uses virtual memory enabling the images to be larger than
    the available RAM.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImagePyramid >":
        return _fast.ImagePyramid_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImagePyramid_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImagePyramid_getStaticNameOfClass()

    def create(self, *args) -> "void":
        return _fast.ImagePyramid_create(self, *args)

    def getNrOfLevels(self) -> "int":
        return _fast.ImagePyramid_getNrOfLevels(self)

    def getLevelWidth(self, level: "int") -> "int":
        return _fast.ImagePyramid_getLevelWidth(self, level)

    def getLevelHeight(self, level: "int") -> "int":
        return _fast.ImagePyramid_getLevelHeight(self, level)

    def getLevelTileWidth(self, level: "int") -> "int":
        return _fast.ImagePyramid_getLevelTileWidth(self, level)

    def getLevelTileHeight(self, level: "int") -> "int":
        return _fast.ImagePyramid_getLevelTileHeight(self, level)

    def getLevelTilesX(self, level: "int") -> "int":
        return _fast.ImagePyramid_getLevelTilesX(self, level)

    def getLevelTilesY(self, level: "int") -> "int":
        return _fast.ImagePyramid_getLevelTilesY(self, level)

    def getFullWidth(self) -> "int":
        return _fast.ImagePyramid_getFullWidth(self)

    def getFullHeight(self) -> "int":
        return _fast.ImagePyramid_getFullHeight(self)

    def getNrOfChannels(self) -> "int":
        return _fast.ImagePyramid_getNrOfChannels(self)

    def setSpacing(self, spacing: "Vector3f") -> "void":
        return _fast.ImagePyramid_setSpacing(self, spacing)

    def getSpacing(self) -> "Vector3f":
        return _fast.ImagePyramid_getSpacing(self)

    def getAccess(self, type: "accessType") -> "fast::ImagePyramidAccess::pointer":
        return _fast.ImagePyramid_getAccess(self, type)

    def getDirtyPatches(self) -> "std::unordered_set< std::string >":
        return _fast.ImagePyramid_getDirtyPatches(self)

    def isDirtyPatch(self, tileID: "std::string const &") -> "bool":
        return _fast.ImagePyramid_isDirtyPatch(self, tileID)

    def setDirtyPatch(self, level: "int", patchIdX: "int", patchIdY: "int") -> "void":
        return _fast.ImagePyramid_setDirtyPatch(self, level, patchIdX, patchIdY)

    def clearDirtyPatches(self, patches: "std::set< std::string >") -> "void":
        return _fast.ImagePyramid_clearDirtyPatches(self, patches)

    def free(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.ImagePyramid_free(self, device)

    def freeAll(self) -> "void":
        return _fast.ImagePyramid_freeAll(self)
    __swig_destroy__ = _fast.delete_ImagePyramid

# Register ImagePyramid in _fast:
_fast.ImagePyramid_swigregister(ImagePyramid)

def ImagePyramid_New() -> "std::shared_ptr< fast::ImagePyramid >":
    return _fast.ImagePyramid_New()

def ImagePyramid_getStaticNameOfClass() -> "std::string":
    return _fast.ImagePyramid_getStaticNameOfClass()

class ImageFileImporter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageFileImporter >":
        return _fast.ImageFileImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageFileImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageFileImporter_getStaticNameOfClass()

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.ImageFileImporter_setFilename(self, filename)

    def loadAttributes(self) -> "void":
        return _fast.ImageFileImporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageFileImporter

# Register ImageFileImporter in _fast:
_fast.ImageFileImporter_swigregister(ImageFileImporter)

def ImageFileImporter_New() -> "std::shared_ptr< fast::ImageFileImporter >":
    return _fast.ImageFileImporter_New()

def ImageFileImporter_getStaticNameOfClass() -> "std::string":
    return _fast.ImageFileImporter_getStaticNameOfClass()

class MetaImageImporter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MetaImageImporter >":
        return _fast.MetaImageImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MetaImageImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MetaImageImporter_getStaticNameOfClass()

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.MetaImageImporter_setFilename(self, filename)
    __swig_destroy__ = _fast.delete_MetaImageImporter

# Register MetaImageImporter in _fast:
_fast.MetaImageImporter_swigregister(MetaImageImporter)

def MetaImageImporter_New() -> "std::shared_ptr< fast::MetaImageImporter >":
    return _fast.MetaImageImporter_New()

def MetaImageImporter_getStaticNameOfClass() -> "std::string":
    return _fast.MetaImageImporter_getStaticNameOfClass()

class VTKMeshFileImporter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::VTKMeshFileImporter >":
        return _fast.VTKMeshFileImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.VTKMeshFileImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.VTKMeshFileImporter_getStaticNameOfClass()

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.VTKMeshFileImporter_setFilename(self, filename)
    __swig_destroy__ = _fast.delete_VTKMeshFileImporter

# Register VTKMeshFileImporter in _fast:
_fast.VTKMeshFileImporter_swigregister(VTKMeshFileImporter)

def VTKMeshFileImporter_New() -> "std::shared_ptr< fast::VTKMeshFileImporter >":
    return _fast.VTKMeshFileImporter_New()

def VTKMeshFileImporter_getStaticNameOfClass() -> "std::string":
    return _fast.VTKMeshFileImporter_getStaticNameOfClass()

class DICOMFileImporter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::DICOMFileImporter >":
        return _fast.DICOMFileImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.DICOMFileImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.DICOMFileImporter_getStaticNameOfClass()

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.DICOMFileImporter_setFilename(self, filename)

    def setLoadSeries(self, load: "bool") -> "void":
        return _fast.DICOMFileImporter_setLoadSeries(self, load)
    __swig_destroy__ = _fast.delete_DICOMFileImporter

# Register DICOMFileImporter in _fast:
_fast.DICOMFileImporter_swigregister(DICOMFileImporter)

def DICOMFileImporter_New() -> "std::shared_ptr< fast::DICOMFileImporter >":
    return _fast.DICOMFileImporter_New()

def DICOMFileImporter_getStaticNameOfClass() -> "std::string":
    return _fast.DICOMFileImporter_getStaticNameOfClass()

class WholeSlideImageImporter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::WholeSlideImageImporter >":
        return _fast.WholeSlideImageImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.WholeSlideImageImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.WholeSlideImageImporter_getStaticNameOfClass()

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.WholeSlideImageImporter_setFilename(self, filename)

    def __init__(self):
        _fast.WholeSlideImageImporter_swiginit(self, _fast.new_WholeSlideImageImporter())

    def setGrayscale(self, grayscale: "bool") -> "void":
        return _fast.WholeSlideImageImporter_setGrayscale(self, grayscale)

    def loadAttributes(self) -> "void":
        return _fast.WholeSlideImageImporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_WholeSlideImageImporter

# Register WholeSlideImageImporter in _fast:
_fast.WholeSlideImageImporter_swigregister(WholeSlideImageImporter)

def WholeSlideImageImporter_New() -> "std::shared_ptr< fast::WholeSlideImageImporter >":
    return _fast.WholeSlideImageImporter_New()

def WholeSlideImageImporter_getStaticNameOfClass() -> "std::string":
    return _fast.WholeSlideImageImporter_getStaticNameOfClass()

class HDF5TensorImporter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::HDF5TensorImporter >":
        return _fast.HDF5TensorImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.HDF5TensorImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.HDF5TensorImporter_getStaticNameOfClass()

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.HDF5TensorImporter_setFilename(self, filename)

    def setDatasetName(self, datasetName: "std::string") -> "void":
        return _fast.HDF5TensorImporter_setDatasetName(self, datasetName)

    def loadAttributes(self) -> "void":
        return _fast.HDF5TensorImporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_HDF5TensorImporter

# Register HDF5TensorImporter in _fast:
_fast.HDF5TensorImporter_swigregister(HDF5TensorImporter)

def HDF5TensorImporter_New() -> "std::shared_ptr< fast::HDF5TensorImporter >":
    return _fast.HDF5TensorImporter_New()

def HDF5TensorImporter_getStaticNameOfClass() -> "std::string":
    return _fast.HDF5TensorImporter_getStaticNameOfClass()

class FileExporter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.FileExporter_setFilename(self, filename)
    __swig_destroy__ = _fast.delete_FileExporter

# Register FileExporter in _fast:
_fast.FileExporter_swigregister(FileExporter)

class ImageExporter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageExporter >":
        return _fast.ImageExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageExporter_getStaticNameOfClass()

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.ImageExporter_setFilename(self, filename)
    __swig_destroy__ = _fast.delete_ImageExporter

# Register ImageExporter in _fast:
_fast.ImageExporter_swigregister(ImageExporter)

def ImageExporter_New() -> "std::shared_ptr< fast::ImageExporter >":
    return _fast.ImageExporter_New()

def ImageExporter_getStaticNameOfClass() -> "std::string":
    return _fast.ImageExporter_getStaticNameOfClass()

class MetaImageExporter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MetaImageExporter >":
        return _fast.MetaImageExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MetaImageExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MetaImageExporter_getStaticNameOfClass()

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.MetaImageExporter_setFilename(self, filename)

    def setCompression(self, compress: "bool") -> "void":
        r"""
        Enable or disable lossless compression
        :type compress: boolean
        :param compress:
        """
        return _fast.MetaImageExporter_setCompression(self, compress)

    def enableCompression(self) -> "void":
        r"""Deprecated"""
        return _fast.MetaImageExporter_enableCompression(self)

    def disableCompression(self) -> "void":
        r"""Deprecated"""
        return _fast.MetaImageExporter_disableCompression(self)

    def setMetadata(self, key: "std::string", value: "std::string") -> "void":
        r"""
        Add additional meta data to the mhd file.
        This can also be added to the input image object.

        :type key: string
        :param key:
        :type value: string
        :param value:
        """
        return _fast.MetaImageExporter_setMetadata(self, key, value)
    __swig_destroy__ = _fast.delete_MetaImageExporter

# Register MetaImageExporter in _fast:
_fast.MetaImageExporter_swigregister(MetaImageExporter)

def MetaImageExporter_New() -> "std::shared_ptr< fast::MetaImageExporter >":
    return _fast.MetaImageExporter_New()

def MetaImageExporter_getStaticNameOfClass() -> "std::string":
    return _fast.MetaImageExporter_getStaticNameOfClass()

class StreamExporter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::StreamExporter >":
        return _fast.StreamExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.StreamExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.StreamExporter_getStaticNameOfClass()

    def setFilenameFormat(self, format: "std::string") -> "void":
        return _fast.StreamExporter_setFilenameFormat(self, format)

    def setExporter(self, exporter: "std::shared_ptr< fast::FileExporter >") -> "void":
        return _fast.StreamExporter_setExporter(self, exporter)

    def isFinished(self) -> "bool":
        return _fast.StreamExporter_isFinished(self)
    __swig_destroy__ = _fast.delete_StreamExporter

# Register StreamExporter in _fast:
_fast.StreamExporter_swigregister(StreamExporter)

def StreamExporter_New() -> "std::shared_ptr< fast::StreamExporter >":
    return _fast.StreamExporter_New()

def StreamExporter_getStaticNameOfClass() -> "std::string":
    return _fast.StreamExporter_getStaticNameOfClass()

class ImageFileExporter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageFileExporter >":
        return _fast.ImageFileExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageFileExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageFileExporter_getStaticNameOfClass()

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.ImageFileExporter_setFilename(self, filename)

    def __init__(self):
        _fast.ImageFileExporter_swiginit(self, _fast.new_ImageFileExporter())

    def setCompression(self, compress: "bool") -> "void":
        return _fast.ImageFileExporter_setCompression(self, compress)
    __swig_destroy__ = _fast.delete_ImageFileExporter

# Register ImageFileExporter in _fast:
_fast.ImageFileExporter_swigregister(ImageFileExporter)

def ImageFileExporter_New() -> "std::shared_ptr< fast::ImageFileExporter >":
    return _fast.ImageFileExporter_New()

def ImageFileExporter_getStaticNameOfClass() -> "std::string":
    return _fast.ImageFileExporter_getStaticNameOfClass()

class StreamToFileExporter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::StreamToFileExporter >":
        return _fast.StreamToFileExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.StreamToFileExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.StreamToFileExporter_getStaticNameOfClass()

    def setPath(self, path: "std::string") -> "void":
        return _fast.StreamToFileExporter_setPath(self, path)

    def setRecordingFolderName(self, folder: "std::string") -> "void":
        return _fast.StreamToFileExporter_setRecordingFolderName(self, folder)

    def setFrameFilename(self, name: "std::string") -> "void":
        return _fast.StreamToFileExporter_setFrameFilename(self, name)

    def setEnabled(self, enabled: "bool") -> "void":
        return _fast.StreamToFileExporter_setEnabled(self, enabled)

    def setFrameLimit(self, limit: "uint64_t") -> "void":
        return _fast.StreamToFileExporter_setFrameLimit(self, limit)

    def getFrameCounter(self) -> "uint64_t":
        return _fast.StreamToFileExporter_getFrameCounter(self)

    def getCurrentDestinationFolder(self) -> "std::string":
        return _fast.StreamToFileExporter_getCurrentDestinationFolder(self)

    def getRecordingDuration(self) -> "float":
        return _fast.StreamToFileExporter_getRecordingDuration(self)

    def reset(self) -> "void":
        return _fast.StreamToFileExporter_reset(self)

    def isEnabled(self) -> "bool":
        return _fast.StreamToFileExporter_isEnabled(self)
    __swig_destroy__ = _fast.delete_StreamToFileExporter

# Register StreamToFileExporter in _fast:
_fast.StreamToFileExporter_swigregister(StreamToFileExporter)

def StreamToFileExporter_New() -> "std::shared_ptr< fast::StreamToFileExporter >":
    return _fast.StreamToFileExporter_New()

def StreamToFileExporter_getStaticNameOfClass() -> "std::string":
    return _fast.StreamToFileExporter_getStaticNameOfClass()

class VTKMeshFileExporter(FileExporter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::VTKMeshFileExporter >":
        return _fast.VTKMeshFileExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.VTKMeshFileExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.VTKMeshFileExporter_getStaticNameOfClass()

    def setWriteNormals(self, writeNormals: "bool") -> "void":
        return _fast.VTKMeshFileExporter_setWriteNormals(self, writeNormals)

    def setWriteColors(self, writeColors: "bool") -> "void":
        return _fast.VTKMeshFileExporter_setWriteColors(self, writeColors)
    __swig_destroy__ = _fast.delete_VTKMeshFileExporter

# Register VTKMeshFileExporter in _fast:
_fast.VTKMeshFileExporter_swigregister(VTKMeshFileExporter)

def VTKMeshFileExporter_New() -> "std::shared_ptr< fast::VTKMeshFileExporter >":
    return _fast.VTKMeshFileExporter_New()

def VTKMeshFileExporter_getStaticNameOfClass() -> "std::string":
    return _fast.VTKMeshFileExporter_getStaticNameOfClass()

class HDF5TensorExporter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::HDF5TensorExporter >":
        return _fast.HDF5TensorExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.HDF5TensorExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.HDF5TensorExporter_getStaticNameOfClass()

    def setFilename(self, name: "std::string") -> "void":
        return _fast.HDF5TensorExporter_setFilename(self, name)

    def setDatasetName(self, name: "std::string") -> "void":
        return _fast.HDF5TensorExporter_setDatasetName(self, name)

    def loadAttributes(self) -> "void":
        return _fast.HDF5TensorExporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_HDF5TensorExporter

# Register HDF5TensorExporter in _fast:
_fast.HDF5TensorExporter_swigregister(HDF5TensorExporter)

def HDF5TensorExporter_New() -> "std::shared_ptr< fast::HDF5TensorExporter >":
    return _fast.HDF5TensorExporter_New()

def HDF5TensorExporter_getStaticNameOfClass() -> "std::string":
    return _fast.HDF5TensorExporter_getStaticNameOfClass()

class Renderer(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def draw(self, perspectiveMatrix: "Matrix4f", viewingMatrix: "Matrix4f", zNear: "float", zFar: "float", mode2D: "bool") -> "void":
        return _fast.Renderer_draw(self, perspectiveMatrix, viewingMatrix, zNear, zFar, mode2D)

    def postDraw(self) -> "void":
        return _fast.Renderer_postDraw(self)

    def addInputConnection(self, port: "fast::DataChannel::pointer") -> "uint":
        r"""
        Adds a new input connection
        :type port: :py:class:`DataChannel`
        :param port:
        :rtype: int
        :return: the input nr of the new connection
        """
        return _fast.Renderer_addInputConnection(self, port)

    def addInputData(self, data: "fast::DataObject::pointer") -> "uint":
        r"""
        Adds a new input connection to a specific data object
        :type data: :py:class:`DataObject`
        :param data:
        :rtype: int
        :return: the input nr of the new connection
        """
        return _fast.Renderer_addInputData(self, data)

    def getBoundingBox(self, transform: "bool"=True) -> "fast::DataBoundingBox":
        return _fast.Renderer_getBoundingBox(self, transform)

    def stopPipeline(self) -> "void":
        return _fast.Renderer_stopPipeline(self)

    def reset(self) -> "void":
        return _fast.Renderer_reset(self)

    def setDisabled(self, disabled: "bool") -> "void":
        r"""
        Set renderer to disabled or enabled. A disabled renderer will not draw.
        :type disabled: boolean
        :param disabled:
        """
        return _fast.Renderer_setDisabled(self, disabled)

    def isDisabled(self) -> "bool":
        r"""
        Get whether this renderer is disabled or not
        :rtype: boolean
        :return: 
        """
        return _fast.Renderer_isDisabled(self)

    def setView(self, view: "View") -> "void":
        return _fast.Renderer_setView(self, view)

    def setSynchronizedRendering(self, synched: "bool") -> "void":
        return _fast.Renderer_setSynchronizedRendering(self, synched)

    def getSynchronizedRendering(self) -> "bool":
        return _fast.Renderer_getSynchronizedRendering(self)
    __swig_destroy__ = _fast.delete_Renderer

# Register Renderer in _fast:
_fast.Renderer_swigregister(Renderer)

class View(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def addRenderer(self, renderer: "fast::Renderer::pointer") -> "void":
        return _fast.View_addRenderer(self, renderer)

    def removeRenderer(self, renderer: "fast::Renderer::pointer") -> "void":
        return _fast.View_removeRenderer(self, renderer)

    def removeAllRenderers(self) -> "void":
        return _fast.View_removeAllRenderers(self)

    def keyPressEvent(self, event: "QKeyEvent *") -> "void":
        return _fast.View_keyPressEvent(self, event)

    def mouseMoveEvent(self, event: "QMouseEvent *") -> "void":
        return _fast.View_mouseMoveEvent(self, event)

    def mousePressEvent(self, event: "QMouseEvent *") -> "void":
        return _fast.View_mousePressEvent(self, event)

    def mouseReleaseEvent(self, event: "QMouseEvent *") -> "void":
        return _fast.View_mouseReleaseEvent(self, event)

    def wheelEvent(self, event: "QWheelEvent *") -> "void":
        return _fast.View_wheelEvent(self, event)

    def setMaximumFramerate(self, framerate: "unsigned int") -> "void":
        return _fast.View_setMaximumFramerate(self, framerate)

    def setCameraInputConnection(self, port: "fast::DataChannel::pointer") -> "void":
        return _fast.View_setCameraInputConnection(self, port)

    def set2DMode(self) -> "void":
        return _fast.View_set2DMode(self)

    def set3DMode(self) -> "void":
        return _fast.View_set3DMode(self)

    def setLookAt(self, cameraPosition: "Vector3f", targetPosition: "Vector3f", cameraUpVector: "Vector3f", zNear: "float"=0.1, zFar: "float"=1000) -> "void":
        return _fast.View_setLookAt(self, cameraPosition, targetPosition, cameraUpVector, zNear, zFar)

    def quit(self) -> "void":
        return _fast.View_quit(self)

    def reinitialize(self) -> "void":
        return _fast.View_reinitialize(self)

    def hasQuit(self) -> "bool":
        return _fast.View_hasQuit(self)
    __swig_destroy__ = _fast.delete_View

    def recalculateCamera(self) -> "void":
        return _fast.View_recalculateCamera(self)

    def setBackgroundColor(self, color: "Color") -> "void":
        return _fast.View_setBackgroundColor(self, color)

    def setAutoUpdateCamera(self, autoUpdate: "bool") -> "void":
        return _fast.View_setAutoUpdateCamera(self, autoUpdate)

    def getOrthoProjectionParameters(self) -> "Vector4f":
        return _fast.View_getOrthoProjectionParameters(self)

    def getNameOfClass(self) -> "std::string":
        return _fast.View_getNameOfClass(self)

    def __init__(self):
        _fast.View_swiginit(self, _fast.new_View())

    def getRenderers(self) -> "std::vector< fast::Renderer::pointer,std::allocator< fast::Renderer::pointer > >":
        return _fast.View_getRenderers(self)

    @staticmethod
    def getGLFormat() -> "QGLFormat":
        return _fast.View_getGLFormat()

    def getViewMatrix(self) -> "Matrix4f":
        return _fast.View_getViewMatrix(self)

    def getPerspectiveMatrix(self) -> "Matrix4f":
        return _fast.View_getPerspectiveMatrix(self)

    def loadAttributes(self) -> "void":
        return _fast.View_loadAttributes(self)

    def setZoom(self, zoom: "float") -> "void":
        r"""
        Function for setting the zoom level of the view. Level 1 is no zooming.
                   Level 0.5 makes images in the view half its size. Level 2 makes images in the view double in size.
        """
        return _fast.View_setZoom(self, zoom)

# Register View in _fast:
_fast.View_swigregister(View)

def View_getGLFormat() -> "QGLFormat":
    return _fast.View_getGLFormat()

class Window(Object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def initializeQtApp() -> "void":
        return _fast.Window_initializeQtApp()

    @staticmethod
    def getMainGLContext() -> "QGLContext *":
        return _fast.Window_getMainGLContext()

    @staticmethod
    def setMainGLContext(context: "QGLContext *") -> "void":
        return _fast.Window_setMainGLContext(context)

    def setTimeout(self, milliseconds: "unsigned int") -> "void":
        r"""Makes the window close after a specific number of ms"""
        return _fast.Window_setTimeout(self, milliseconds)
    __swig_destroy__ = _fast.delete_Window

    def start(self) -> "void":
        r"""Starts an update loop on all renderers attached to each view in this window."""
        return _fast.Window_start(self)

    def setWidth(self, width: "uint") -> "void":
        return _fast.Window_setWidth(self, width)

    def setHeight(self, height: "uint") -> "void":
        return _fast.Window_setHeight(self, height)

    def setSize(self, width: "uint", height: "uint") -> "void":
        return _fast.Window_setSize(self, width, height)

    def enableMaximized(self) -> "void":
        return _fast.Window_enableMaximized(self)

    def disableMaximized(self) -> "void":
        return _fast.Window_disableMaximized(self)

    def enableFullscreen(self) -> "void":
        return _fast.Window_enableFullscreen(self)

    def disableFullscreen(self) -> "void":
        return _fast.Window_disableFullscreen(self)

    def setTitle(self, arg2: "std::string") -> "void":
        return _fast.Window_setTitle(self, arg2)

    def getViews(self) -> "std::vector< fast::View *,std::allocator< fast::View * > >":
        return _fast.Window_getViews(self)

    def getView(self, i: "uint") -> "fast::View *":
        return _fast.Window_getView(self, i)

    @staticmethod
    def cleanup() -> "void":
        return _fast.Window_cleanup()

    def getScreenWidth(self) -> "int":
        r"""
        Get screen width in pixels
        :rtype: int
        :return: width in pixels
        """
        return _fast.Window_getScreenWidth(self)

    def getScreenHeight(self) -> "int":
        r"""
        Get screen height in pixels
        :rtype: int
        :return: height in pixels
        """
        return _fast.Window_getScreenHeight(self)

    def getScalingFactor(self) -> "float":
        r"""
        Get GUI scaling factor
        :rtype: float
        :return: 
        """
        return _fast.Window_getScalingFactor(self)

    def saveScreenshotOnClose(self, filename: "std::string") -> "void":
        return _fast.Window_saveScreenshotOnClose(self, filename)

    def saveScreenshotOfViewsOnClose(self, filename: "std::string") -> "void":
        return _fast.Window_saveScreenshotOfViewsOnClose(self, filename)

    def getWidget(self) -> "QWidget *":
        return _fast.Window_getWidget(self)

    def addProcessObject(self, po: "std::shared_ptr< fast::ProcessObject >") -> "void":
        return _fast.Window_addProcessObject(self, po)

    def stop(self) -> "void":
        return _fast.Window_stop(self)

# Register Window in _fast:
_fast.Window_swigregister(Window)

def Window_initializeQtApp() -> "void":
    return _fast.Window_initializeQtApp()

def Window_getMainGLContext() -> "QGLContext *":
    return _fast.Window_getMainGLContext()

def Window_setMainGLContext(context: "QGLContext *") -> "void":
    return _fast.Window_setMainGLContext(context)

def Window_cleanup() -> "void":
    return _fast.Window_cleanup()

class SimpleWindow(Window):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SimpleWindow >":
        return _fast.SimpleWindow_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SimpleWindow_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SimpleWindow_getStaticNameOfClass()

    def addRenderer(self, renderer: "std::shared_ptr< fast::Renderer >") -> "void":
        return _fast.SimpleWindow_addRenderer(self, renderer)

    def removeAllRenderers(self) -> "void":
        return _fast.SimpleWindow_removeAllRenderers(self)

    def setMaximumFramerate(self, framerate: "unsigned int") -> "void":
        return _fast.SimpleWindow_setMaximumFramerate(self, framerate)

    def getView(self) -> "fast::View *":
        return _fast.SimpleWindow_getView(self)
    __swig_destroy__ = _fast.delete_SimpleWindow

    def set2DMode(self) -> "void":
        return _fast.SimpleWindow_set2DMode(self)

    def set3DMode(self) -> "void":
        return _fast.SimpleWindow_set3DMode(self)

    def __init__(self):
        _fast.SimpleWindow_swiginit(self, _fast.new_SimpleWindow())

# Register SimpleWindow in _fast:
_fast.SimpleWindow_swigregister(SimpleWindow)

def SimpleWindow_New() -> "std::shared_ptr< fast::SimpleWindow >":
    return _fast.SimpleWindow_New()

def SimpleWindow_getStaticNameOfClass() -> "std::string":
    return _fast.SimpleWindow_getStaticNameOfClass()

class DualViewWindow(Window):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::DualViewWindow >":
        return _fast.DualViewWindow_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.DualViewWindow_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.DualViewWindow_getStaticNameOfClass()

    def addRendererToTopLeftView(self, renderer: "fast::Renderer::pointer") -> "void":
        return _fast.DualViewWindow_addRendererToTopLeftView(self, renderer)

    def addRendererToBottomRightView(self, renderer: "fast::Renderer::pointer") -> "void":
        return _fast.DualViewWindow_addRendererToBottomRightView(self, renderer)

    def removeAllRenderers(self) -> "void":
        return _fast.DualViewWindow_removeAllRenderers(self)

    def getTopLeftView(self) -> "fast::View *":
        return _fast.DualViewWindow_getTopLeftView(self)

    def getBottomRightView(self) -> "fast::View *":
        return _fast.DualViewWindow_getBottomRightView(self)

    def setHorizontalMode(self) -> "void":
        return _fast.DualViewWindow_setHorizontalMode(self)

    def setVerticalMode(self) -> "void":
        return _fast.DualViewWindow_setVerticalMode(self)
    __swig_destroy__ = _fast.delete_DualViewWindow

# Register DualViewWindow in _fast:
_fast.DualViewWindow_swigregister(DualViewWindow)

def DualViewWindow_New() -> "std::shared_ptr< fast::DualViewWindow >":
    return _fast.DualViewWindow_New()

def DualViewWindow_getStaticNameOfClass() -> "std::string":
    return _fast.DualViewWindow_getStaticNameOfClass()

class MultiViewWindow(Window):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MultiViewWindow >":
        return _fast.MultiViewWindow_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MultiViewWindow_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MultiViewWindow_getStaticNameOfClass()

    def addView(self, view: "View") -> "void":
        return _fast.MultiViewWindow_addView(self, view)

    def setNrOfViews(self, viewCount: "int") -> "void":
        return _fast.MultiViewWindow_setNrOfViews(self, viewCount)

    def addRenderer(self, viewIndex: "int", renderer: "fast::Renderer::pointer") -> "void":
        return _fast.MultiViewWindow_addRenderer(self, viewIndex, renderer)

    def removeAllRenderers(self) -> "void":
        return _fast.MultiViewWindow_removeAllRenderers(self)

    def setHorizontalMode(self) -> "void":
        return _fast.MultiViewWindow_setHorizontalMode(self)

    def setVerticalMode(self) -> "void":
        return _fast.MultiViewWindow_setVerticalMode(self)

    def start(self) -> "void":
        return _fast.MultiViewWindow_start(self)
    __swig_destroy__ = _fast.delete_MultiViewWindow

# Register MultiViewWindow in _fast:
_fast.MultiViewWindow_swigregister(MultiViewWindow)

def MultiViewWindow_New() -> "std::shared_ptr< fast::MultiViewWindow >":
    return _fast.MultiViewWindow_New()

def MultiViewWindow_getStaticNameOfClass() -> "std::string":
    return _fast.MultiViewWindow_getStaticNameOfClass()

class BoundingBoxRenderer(Renderer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::BoundingBoxRenderer >":
        return _fast.BoundingBoxRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.BoundingBoxRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BoundingBoxRenderer_getStaticNameOfClass()

    def setLabelColor(self, label: "int", color: "Color") -> "void":
        return _fast.BoundingBoxRenderer_setLabelColor(self, label, color)
    __swig_destroy__ = _fast.delete_BoundingBoxRenderer

# Register BoundingBoxRenderer in _fast:
_fast.BoundingBoxRenderer_swigregister(BoundingBoxRenderer)

def BoundingBoxRenderer_New() -> "std::shared_ptr< fast::BoundingBoxRenderer >":
    return _fast.BoundingBoxRenderer_New()

def BoundingBoxRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.BoundingBoxRenderer_getStaticNameOfClass()

class HeatmapRenderer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::HeatmapRenderer >":
        return _fast.HeatmapRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.HeatmapRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.HeatmapRenderer_getStaticNameOfClass()

    def setMinConfidence(self, confidence: "float") -> "void":
        return _fast.HeatmapRenderer_setMinConfidence(self, confidence)

    def setMaxOpacity(self, opacity: "float") -> "void":
        return _fast.HeatmapRenderer_setMaxOpacity(self, opacity)

    def setChannelColor(self, channel: "uint", color: "Color") -> "void":
        return _fast.HeatmapRenderer_setChannelColor(self, channel, color)

    def setChannelHidden(self, channel: "uint", hide: "bool") -> "void":
        return _fast.HeatmapRenderer_setChannelHidden(self, channel, hide)

    def setInterpolation(self, useInterpolation: "bool") -> "void":
        return _fast.HeatmapRenderer_setInterpolation(self, useInterpolation)

    def loadAttributes(self) -> "void":
        return _fast.HeatmapRenderer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_HeatmapRenderer

# Register HeatmapRenderer in _fast:
_fast.HeatmapRenderer_swigregister(HeatmapRenderer)

def HeatmapRenderer_New() -> "std::shared_ptr< fast::HeatmapRenderer >":
    return _fast.HeatmapRenderer_New()

def HeatmapRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.HeatmapRenderer_getStaticNameOfClass()

class ImagePyramidRenderer(Renderer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImagePyramidRenderer >":
        return _fast.ImagePyramidRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImagePyramidRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImagePyramidRenderer_getStaticNameOfClass()

    def loadAttributes(self) -> "void":
        return _fast.ImagePyramidRenderer_loadAttributes(self)

    def setIntensityLevel(self, level: "float") -> "void":
        return _fast.ImagePyramidRenderer_setIntensityLevel(self, level)

    def getIntensityLevel(self) -> "float":
        return _fast.ImagePyramidRenderer_getIntensityLevel(self)

    def setIntensityWindow(self, window: "float") -> "void":
        return _fast.ImagePyramidRenderer_setIntensityWindow(self, window)

    def getIntensityWindow(self) -> "float":
        return _fast.ImagePyramidRenderer_getIntensityWindow(self)
    __swig_destroy__ = _fast.delete_ImagePyramidRenderer

    def clearPyramid(self) -> "void":
        return _fast.ImagePyramidRenderer_clearPyramid(self)

# Register ImagePyramidRenderer in _fast:
_fast.ImagePyramidRenderer_swigregister(ImagePyramidRenderer)

def ImagePyramidRenderer_New() -> "std::shared_ptr< fast::ImagePyramidRenderer >":
    return _fast.ImagePyramidRenderer_New()

def ImagePyramidRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.ImagePyramidRenderer_getStaticNameOfClass()

class ImageRenderer(Renderer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageRenderer >":
        return _fast.ImageRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageRenderer_getStaticNameOfClass()

    def loadAttributes(self) -> "void":
        return _fast.ImageRenderer_loadAttributes(self)

    def setIntensityLevel(self, level: "float") -> "void":
        return _fast.ImageRenderer_setIntensityLevel(self, level)

    def getIntensityLevel(self) -> "float":
        return _fast.ImageRenderer_getIntensityLevel(self)

    def setIntensityWindow(self, window: "float") -> "void":
        return _fast.ImageRenderer_setIntensityWindow(self, window)

    def getIntensityWindow(self) -> "float":
        return _fast.ImageRenderer_getIntensityWindow(self)
    __swig_destroy__ = _fast.delete_ImageRenderer

# Register ImageRenderer in _fast:
_fast.ImageRenderer_swigregister(ImageRenderer)

def ImageRenderer_New() -> "std::shared_ptr< fast::ImageRenderer >":
    return _fast.ImageRenderer_New()

def ImageRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.ImageRenderer_getStaticNameOfClass()

class SegmentationLabelRenderer(Renderer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SegmentationLabelRenderer >":
        return _fast.SegmentationLabelRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SegmentationLabelRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SegmentationLabelRenderer_getStaticNameOfClass()

    def setLabelName(self, label: "int", name: "std::string") -> "void":
        return _fast.SegmentationLabelRenderer_setLabelName(self, label, name)

    def setLabelColor(self, label: "int", color: "Color") -> "void":
        return _fast.SegmentationLabelRenderer_setLabelColor(self, label, color)

    def setAreaThreshold(self, threshold: "float") -> "void":
        return _fast.SegmentationLabelRenderer_setAreaThreshold(self, threshold)

    def draw(self, perspectiveMatrix: "Matrix4f", viewingMatrix: "Matrix4f", zNear: "float", zFar: "float", mode2D: "bool") -> "void":
        return _fast.SegmentationLabelRenderer_draw(self, perspectiveMatrix, viewingMatrix, zNear, zFar, mode2D)

    def loadAttributes(self) -> "void":
        return _fast.SegmentationLabelRenderer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_SegmentationLabelRenderer

# Register SegmentationLabelRenderer in _fast:
_fast.SegmentationLabelRenderer_swigregister(SegmentationLabelRenderer)

def SegmentationLabelRenderer_New() -> "std::shared_ptr< fast::SegmentationLabelRenderer >":
    return _fast.SegmentationLabelRenderer_New()

def SegmentationLabelRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.SegmentationLabelRenderer_getStaticNameOfClass()

class SegmentationPyramidRenderer(Renderer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SegmentationPyramidRenderer >":
        return _fast.SegmentationPyramidRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SegmentationPyramidRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SegmentationPyramidRenderer_getStaticNameOfClass()

    def loadAttributes(self) -> "void":
        return _fast.SegmentationPyramidRenderer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_SegmentationPyramidRenderer

    def clearPyramid(self) -> "void":
        return _fast.SegmentationPyramidRenderer_clearPyramid(self)

    def setOpacity(self, opacity: "float") -> "void":
        return _fast.SegmentationPyramidRenderer_setOpacity(self, opacity)

    def stopPipeline(self) -> "void":
        return _fast.SegmentationPyramidRenderer_stopPipeline(self)

# Register SegmentationPyramidRenderer in _fast:
_fast.SegmentationPyramidRenderer_swigregister(SegmentationPyramidRenderer)

def SegmentationPyramidRenderer_New() -> "std::shared_ptr< fast::SegmentationPyramidRenderer >":
    return _fast.SegmentationPyramidRenderer_New()

def SegmentationPyramidRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.SegmentationPyramidRenderer_getStaticNameOfClass()

class SegmentationRenderer(ImageRenderer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SegmentationRenderer >":
        return _fast.SegmentationRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SegmentationRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SegmentationRenderer_getStaticNameOfClass()

    def setColor(self, *args) -> "void":
        return _fast.SegmentationRenderer_setColor(self, *args)

    def setFillArea(self, *args) -> "void":
        return _fast.SegmentationRenderer_setFillArea(self, *args)

    def setBorderRadius(self, radius: "int") -> "void":
        return _fast.SegmentationRenderer_setBorderRadius(self, radius)

    def setOpacity(self, opacity: "float") -> "void":
        return _fast.SegmentationRenderer_setOpacity(self, opacity)

    def setInterpolation(self, useInterpolation: "bool") -> "void":
        return _fast.SegmentationRenderer_setInterpolation(self, useInterpolation)

    def loadAttributes(self) -> "void":
        return _fast.SegmentationRenderer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_SegmentationRenderer

# Register SegmentationRenderer in _fast:
_fast.SegmentationRenderer_swigregister(SegmentationRenderer)

def SegmentationRenderer_New() -> "std::shared_ptr< fast::SegmentationRenderer >":
    return _fast.SegmentationRenderer_New()

def SegmentationRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.SegmentationRenderer_getStaticNameOfClass()

class SliceRenderer(ImageRenderer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SliceRenderer >":
        return _fast.SliceRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SliceRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SliceRenderer_getStaticNameOfClass()

    def addInputConnection(self, *args) -> "uint":
        r"""
        *Overload 1:*

        Orthogonal slicing using the specified orthogonal plane.
        :type port: :py:class:`DataChannel`
        :param port:
        :type orthogonalSlicePlane: int
        :param orthogonalSlicePlane:
        :type sliceNr: int
        :param sliceNr:
        :rtype: int
        :return: port id of new port

        |

        *Overload 2:*

        Orthogonal slicing using the specified orthogonal plane.
        :type port: :py:class:`DataChannel`
        :param port:
        :type orthogonalSlicePlane: int
        :param orthogonalSlicePlane:
        :param sliceNr:
        :rtype: int
        :return: port id of new port

        |

        *Overload 3:*

        Arbitrary slicing using the supplied plane.
        :type port: :py:class:`DataChannel`
        :param port:
        :type slicePlane: :py:class:`Plane`
        :param slicePlane:
        :rtype: int
        :return: port id of new port

        |

        *Overload 4:*

        Add new input connection using supplied slicer
        :type port: :py:class:`DataChannel`
        :param port:
        :type slicer: :py:class:`ImageSlicer`
        :param slicer:
        :rtype: int
        :return: port id of new port
        """
        return _fast.SliceRenderer_addInputConnection(self, *args)

    def setOrthogonalSlicePlane(self, portID: "uint", orthogonalSlicePlane: "fast::PlaneType", sliceNr: "int"=-1) -> "void":
        return _fast.SliceRenderer_setOrthogonalSlicePlane(self, portID, orthogonalSlicePlane, sliceNr)

    def setArbitrarySlicePlane(self, portID: "uint", slicePlane: "Plane") -> "void":
        return _fast.SliceRenderer_setArbitrarySlicePlane(self, portID, slicePlane)
    __swig_destroy__ = _fast.delete_SliceRenderer

# Register SliceRenderer in _fast:
_fast.SliceRenderer_swigregister(SliceRenderer)

def SliceRenderer_New() -> "std::shared_ptr< fast::SliceRenderer >":
    return _fast.SliceRenderer_New()

def SliceRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.SliceRenderer_getStaticNameOfClass()

class TextRenderer(Renderer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TextRenderer >":
        return _fast.TextRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TextRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TextRenderer_getStaticNameOfClass()

    def getBoundingBox(self, transform: "bool") -> "fast::DataBoundingBox":
        return _fast.TextRenderer_getBoundingBox(self, transform)
    STYLE_NORMAL = _fast.TextRenderer_STYLE_NORMAL
    STYLE_BOLD = _fast.TextRenderer_STYLE_BOLD
    STYLE_ITALIC = _fast.TextRenderer_STYLE_ITALIC
    POSITION_CENTER = _fast.TextRenderer_POSITION_CENTER
    POSITION_TOP_CENTER = _fast.TextRenderer_POSITION_TOP_CENTER
    POSITION_BOTTOM_CENTER = _fast.TextRenderer_POSITION_BOTTOM_CENTER
    POSITION_BOTTOM_LEFT = _fast.TextRenderer_POSITION_BOTTOM_LEFT
    POSITION_BOTTOM_RIGHT = _fast.TextRenderer_POSITION_BOTTOM_RIGHT
    POSITION_TOP_LEFT = _fast.TextRenderer_POSITION_TOP_LEFT
    POSITION_TOP_RIGHT = _fast.TextRenderer_POSITION_TOP_RIGHT
    PositionType_STANDARD = _fast.TextRenderer_PositionType_STANDARD
    PositionType_VIEW = _fast.TextRenderer_PositionType_VIEW
    PositionType_WORLD = _fast.TextRenderer_PositionType_WORLD

    def setPosition(self, position: "fast::TextRenderer::TextPosition") -> "void":
        return _fast.TextRenderer_setPosition(self, position)

    def setViewPosition(self, position: "Vector2f", centerPosition: "float"=True) -> "void":
        r"""
        Set text position in normalization view position (x,y 0-1)
        :type position: Vector2f
        :param position:
        :type centerPosition: float
        :param centerPosition:
        """
        return _fast.TextRenderer_setViewPosition(self, position, centerPosition)

    def setWorldPosition(self, position: "Vector2f", centerPosition: "float"=True) -> "void":
        r"""
        Set text position in world coordinates (millimeters)
        :type position: Vector2f
        :param position:
        :type centerPosition: float
        :param centerPosition:
        """
        return _fast.TextRenderer_setWorldPosition(self, position, centerPosition)

    def setFontHeightInMM(self, heightInMillimeters: "float") -> "void":
        r"""
        Set font height in millimeters
        :type heightInMillimeters: float
        :param heightInMillimeters:
        """
        return _fast.TextRenderer_setFontHeightInMM(self, heightInMillimeters)

    def setPositionType(self, position: "fast::TextRenderer::PositionType") -> "void":
        return _fast.TextRenderer_setPositionType(self, position)

    def setFontSize(self, fontSize: "uint") -> "void":
        return _fast.TextRenderer_setFontSize(self, fontSize)

    def setColor(self, color: "Color") -> "void":
        return _fast.TextRenderer_setColor(self, color)

    def setStyle(self, arg2: "fast::TextRenderer::TextStyleType") -> "void":
        return _fast.TextRenderer_setStyle(self, arg2)

    def draw(self, perspectiveMatrix: "Matrix4f", viewingMatrix: "Matrix4f", zNear: "float", zFar: "float", mode2D: "bool") -> "void":
        return _fast.TextRenderer_draw(self, perspectiveMatrix, viewingMatrix, zNear, zFar, mode2D)

    def loadAttributes(self) -> "void":
        return _fast.TextRenderer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_TextRenderer

# Register TextRenderer in _fast:
_fast.TextRenderer_swigregister(TextRenderer)

def TextRenderer_New() -> "std::shared_ptr< fast::TextRenderer >":
    return _fast.TextRenderer_New()

def TextRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.TextRenderer_getStaticNameOfClass()

class VectorFieldRenderer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::VectorFieldRenderer >":
        return _fast.VectorFieldRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.VectorFieldRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.VectorFieldRenderer_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_VectorFieldRenderer

# Register VectorFieldRenderer in _fast:
_fast.VectorFieldRenderer_swigregister(VectorFieldRenderer)

def VectorFieldRenderer_New() -> "std::shared_ptr< fast::VectorFieldRenderer >":
    return _fast.VectorFieldRenderer_New()

def VectorFieldRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.VectorFieldRenderer_getStaticNameOfClass()

class VectorFieldColorRenderer(ImageRenderer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::VectorFieldColorRenderer >":
        return _fast.VectorFieldColorRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.VectorFieldColorRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.VectorFieldColorRenderer_getStaticNameOfClass()

    def setMaxOpacity(self, maxOpacity: "float") -> "void":
        r"""
        Set the maximum opacity for the color overlay.

        :type maxOpacity: float
        :param maxOpacity:
        """
        return _fast.VectorFieldColorRenderer_setMaxOpacity(self, maxOpacity)

    def setMaxLength(self, max: "float") -> "void":
        return _fast.VectorFieldColorRenderer_setMaxLength(self, max)
    __swig_destroy__ = _fast.delete_VectorFieldColorRenderer

# Register VectorFieldColorRenderer in _fast:
_fast.VectorFieldColorRenderer_swigregister(VectorFieldColorRenderer)

def VectorFieldColorRenderer_New() -> "std::shared_ptr< fast::VectorFieldColorRenderer >":
    return _fast.VectorFieldColorRenderer_New()

def VectorFieldColorRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.VectorFieldColorRenderer_getStaticNameOfClass()

class AlphaBlendingVolumeRenderer(object):
    r"""
    Ray-casting based volume rendering using alpha blending.
    Rays are cast back to front, accumulating color along the way based on a provided transfer function.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::AlphaBlendingVolumeRenderer >":
        return _fast.AlphaBlendingVolumeRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.AlphaBlendingVolumeRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.AlphaBlendingVolumeRenderer_getStaticNameOfClass()

    def setTransferFunction(self, transferFunction: "TransferFunction") -> "void":
        r"""
        Set transfer function to use during alpha blending

        :type transferFunction: TransferFunction
        :param transferFunction:
        """
        return _fast.AlphaBlendingVolumeRenderer_setTransferFunction(self, transferFunction)
    __swig_destroy__ = _fast.delete_AlphaBlendingVolumeRenderer

# Register AlphaBlendingVolumeRenderer in _fast:
_fast.AlphaBlendingVolumeRenderer_swigregister(AlphaBlendingVolumeRenderer)

def AlphaBlendingVolumeRenderer_New() -> "std::shared_ptr< fast::AlphaBlendingVolumeRenderer >":
    return _fast.AlphaBlendingVolumeRenderer_New()

def AlphaBlendingVolumeRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.AlphaBlendingVolumeRenderer_getStaticNameOfClass()

class PythonProcessObject(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def execute(self) -> "void":
        return _fast.PythonProcessObject_execute(self)

    def getNameOfClass(self) -> "std::string":
        return _fast.PythonProcessObject_getNameOfClass(self)
    __swig_destroy__ = _fast.delete_PythonProcessObject
    m_hack = property(_fast.PythonProcessObject_m_hack_get, _fast.PythonProcessObject_m_hack_set)

    def __init__(self):
        if self.__class__ == PythonProcessObject:
            _self = None
        else:
            _self = self
        _fast.PythonProcessObject_swiginit(self, _fast.new_PythonProcessObject(_self, ))

    def setInputConnection(self, *args) -> "void":
        return _fast.PythonProcessObject_setInputConnection(self, *args)

    def getOutputPort(self, portID: "uint"=0) -> "fast::DataChannel::pointer":
        return _fast.PythonProcessObject_getOutputPort(self, portID)

    def getInputImage(self, port: "int"=0) -> "std::shared_ptr< fast::Image >":
        return _fast.PythonProcessObject_getInputImage(self, port)

    def getInputImagePyramid(self, port: "int"=0) -> "std::shared_ptr< fast::ImagePyramid >":
        return _fast.PythonProcessObject_getInputImagePyramid(self, port)

    def getInputSegmentation(self, port: "int"=0) -> "std::shared_ptr< fast::Segmentation >":
        return _fast.PythonProcessObject_getInputSegmentation(self, port)

    def getInputTensor(self, port: "int"=0) -> "std::shared_ptr< fast::Tensor >":
        return _fast.PythonProcessObject_getInputTensor(self, port)

    def getInputMesh(self, port: "int"=0) -> "std::shared_ptr< fast::Mesh >":
        return _fast.PythonProcessObject_getInputMesh(self, port)

    def getInputBoundingBox(self, port: "int"=0) -> "std::shared_ptr< fast::BoundingBox >":
        return _fast.PythonProcessObject_getInputBoundingBox(self, port)

    def getInputBoundingBoxSet(self, port: "int"=0) -> "std::shared_ptr< fast::BoundingBoxSet >":
        return _fast.PythonProcessObject_getInputBoundingBoxSet(self, port)

    def getInputText(self, port: "int"=0) -> "std::shared_ptr< fast::Text >":
        return _fast.PythonProcessObject_getInputText(self, port)

    def addOutputData(self, port: "int", image: "std::shared_ptr< fast::DataObject >") -> "void":
        return _fast.PythonProcessObject_addOutputData(self, port, image)

    def createInputPort(self, port: "int") -> "void":
        return _fast.PythonProcessObject_createInputPort(self, port)

    def createOutputPort(self, port: "int") -> "void":
        return _fast.PythonProcessObject_createOutputPort(self, port)

    @classmethod
    def New(cls):
        instance = cls()
        return instance

    def __disown__(self):
        self.this.disown()
        _fast.disown_PythonProcessObject(self)
        return weakref.proxy(self)

    def preExecute(self) -> "void":
        return _fast.PythonProcessObject_preExecute(self)

    def postExecute(self) -> "void":
        return _fast.PythonProcessObject_postExecute(self)

    def waitToFinish(self) -> "void":
        return _fast.PythonProcessObject_waitToFinish(self)

# Register PythonProcessObject in _fast:
_fast.PythonProcessObject_swigregister(PythonProcessObject)



