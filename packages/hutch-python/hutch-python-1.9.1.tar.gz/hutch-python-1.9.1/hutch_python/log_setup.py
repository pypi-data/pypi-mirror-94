"""
This module is used to set up and manipulate the ``logging`` configuration for
utilities like debug mode.
"""
import logging
import logging.config
import os
import time
from contextlib import contextmanager
from pathlib import Path

import pcdsutils.log
import yaml

from .constants import FILE_YAML, NO_LOG_EXCEPTIONS

logger = logging.getLogger(__name__)
central_logger = pcdsutils.log.logger


def setup_logging(dir_logs=None):
    """
    Sets up the ``logging`` configuration.

    Uses ``logging.yml`` to define the config
    and manages the ``log`` directory paths.

    Also sets up the standard pcds logstash handler.

    Parameters
    ----------
    dir_logs: ``str`` or ``Path``, optional
        Path to the log directory. If omitted, we won't use a log file.
    """
    with open(FILE_YAML, 'rt') as f:
        config = yaml.safe_load(f.read())

    if dir_logs is None:
        # Remove debug file from the config
        del config['handlers']['debug']
        config['root']['handlers'].remove('debug')
    else:
        # Ensure Path object
        dir_logs = Path(dir_logs)

        # Subdirectory for year/month
        dir_month = dir_logs / time.strftime('%Y_%m')

        # Make the log directories if they don't exist
        # Make sure each level is all permissions
        for directory in (dir_logs, dir_month):
            if not directory.exists():
                directory.mkdir()
                directory.chmod(0o777)

        user = os.environ['USER']
        timestamp = time.strftime('%d_%Hh%Mm%Ss')
        log_file = '{}_{}.{}'.format(user, timestamp, 'log')
        path_log_file = dir_month / log_file
        path_log_file.touch()
        config['handlers']['debug']['filename'] = str(path_log_file)

    # Configure centralized PCDS logging:
    pcdsutils.log.configure_pcds_logging()
    central_logger.propagate = False

    logging.config.dictConfig(config)
    noisy_loggers = ['parso', 'pyPDB.dbd.yacc', 'ophyd', 'bluesky']
    hush_noisy_loggers(noisy_loggers)


def hush_noisy_loggers(modules, level=logging.WARNING):
    """
    Some loggers spam on INFO with no restraint, so we must raise their levels.

    It seems there is some disagreement over what log levels should mean. In
    our repos, INFO is used as the de-facto print replacement, but in some
    repos it is used as the secondary debug stream.
    """
    for module in modules:
        logging.getLogger(module).setLevel(level)


def get_session_logfiles():
    """
    Get the path to the current debug log file

    Returns
    -------
    logs : list
        List of absolute paths to log files that were created by this session.
        Returns an empty list if there is no ``RotatingFileHandler`` with the
        name ``debug``
    """
    # Grab the debug file handler
    try:
        handler = get_debug_handler()
    except RuntimeError:
        logger.warning("No debug RotatingFileHandler configured for session")
        return list()
    # Find all the log files that were generated by this session
    base = Path(handler.baseFilename)
    return [str(base.parent / log)
            for log in os.listdir(base.parent)
            if log.startswith(base.name)]


def get_console_handler():
    """
    Helper function to find the console ``StreamHandler``.

    Returns
    -------
    console: ``StreamHandler``
        The ``Handler`` that prints to the screen.
    """
    return get_handler('console')


def get_debug_handler():
    """
    Helper function to find the debug ``RotatingFileHandler``

    Returns
    -------
    debug: ``RotatingFileHandler``
        The ``Handler`` that prints to the log files
    """
    return get_handler('debug')


def get_handler(name):
    """
    Helper function to get an arbitrary `Handler`

    Returns
    -------
    hander : `Handler`
    """
    root = logging.getLogger('')
    for handler in root.handlers:
        if handler.name == name:
            return handler
    raise RuntimeError('No {} handler'.format(name))


def get_console_level():
    """
    Helper function to get the console's log level.

    Returns
    -------
    level: ``int``
        Compare to ``logging.INFO``, ``logging.DEBUG``, etc. to see which log
        messages will be printed to the screen.
    """
    handler = get_console_handler()
    return handler.level


def set_console_level(level=logging.INFO):
    """
    Helper function to set the console's log level.

    Parameters
    ----------
    level: ``int``
        Likely one of ``logging.INFO``, ``logging.DEBUG``, etc.
    """
    handler = get_console_handler()
    handler.level = level


def debug_mode(debug=None):
    """
    Enable, disable, or check if we're in debug mode.

    Debug mode means that the console's logging level is ``logging.DEBUG`` or
    lower, which means we'll see all of the internal log messages that usually
    are not sent to the screen.

    Parameters
    ----------
    debug: ``bool``, optional
        If provided, we'll turn debug mode on (``True``) or off (``False``)

    Returns
    -------
    debug: ``bool`` or ``None``
        Returned if `debug_mode` is called with no arguments. This is ``True`
        if we're in debug mode, and ``False`` otherwise.
    """
    if debug is None:
        level = get_console_level()
        return level <= logging.DEBUG
    elif debug:
        set_console_level(level=logging.DEBUG)
    else:
        set_console_level(level=logging.INFO)


@contextmanager
def debug_context():
    """
    Context manager for running a block of code in `debug_mode`.

    For example:

    .. code-block:: python

        with debug_context():
            buggy_function()
    """
    old_level = get_console_level()
    debug_mode(True)
    yield
    set_console_level(level=old_level)


def debug_wrapper(f, *args, **kwargs):
    """
    Wrapper for running a function in `debug_mode`.

    Parameters
    ----------
    f: ``function``
        Wrapped function to call

    *args:
        Function arguments

    **kwargs:
        Function keyword arguments
    """
    with debug_context():
        f(*args, **kwargs)


def log_exception_to_central_server(exc_info, *, context='exception',
                                    level=logging.ERROR):
    """
    Log an exception to the central server (i.e., logstash/grafana).

    Parameters
    ----------
    exc_info : (exc_type, exc_value, exc_traceback)
        The exception information.

    context : str, optional
        Additional context for the log message.

    level : int, optional
        The log level to use.  Defaults to ERROR.
    """
    exc_type, exc_value, exc_traceback = exc_info
    if issubclass(exc_type, NO_LOG_EXCEPTIONS):
        return

    central_logger.log(
        level, f'[{context}] {exc_value}',
        exc_info=(exc_type, exc_value, exc_traceback)
    )
