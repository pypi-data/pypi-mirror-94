#
#     setup_scmversion - Builds a pythonic version number based on scm tags
#                        and branches.
#
#     Copyright (C) 2019 Jorge M. Faleiro Jr.
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU Affero General Public License as published
#     by the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU Affero General Public License for more details.
#
#     You should have received a copy of the GNU Affero General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

from abc import ABC, abstractmethod
from enum import Enum
from typing import Optional

from setuptools import find_packages

PARSERS = dict()
DEFAULT_SCM = 'git'


def init():
    # python and circular import references...
    if len(PARSERS) == 0:
        from .scm.git import GitParser
        PARSERS['git'] = GitParser()


class Tags(Enum):
    RELEASE = 1
    RELEASE_BRANCH = 2
    FEATURE_BRANCH = 3
    OTHER = 4


class ScmParser(ABC):

    @abstractmethod
    def version(self) -> str:  # pragma: no cover
        pass

    @abstractmethod
    def version_type(self) -> Tags:  # pragma: no cover
        pass


def parser_factory(scm: str = DEFAULT_SCM) -> ScmParser:
    """builds a version number based on information on the scm"""
    init()
    if scm not in PARSERS:
        raise ValueError(
            f"scm '{scm}' invalid (options: {[k for k in PARSERS.keys()]})")
    return PARSERS[scm]


def parsers():
    init()
    return str(list(PARSERS.keys()))


def tag_version(parser: ScmParser = None, package: Optional[str] = None,
                file: Optional[str] = None, exclude=['test*']) -> str:
    """ based on
    https://stackoverflow.com/questions/458550/standard-way-to-embed-version-into-python-package"""  # noqa: E501

    init()

    def detect_package():
        packages = find_packages(exclude=exclude)
        packages = [p for p in packages if '.' not in p]  # remove sub-packages
        if len(packages) == 0:
            raise ValueError('no default package detected')
        elif len(packages) > 1:
            raise ValueError(
                f'multiple packages detected: {str(sorted(packages))}')
        else:
            return packages[0]

    parser = parser if parser is not None else parser_factory()
    package = package if package is not None else detect_package()
    file = file if file is not None else '_version'
    file_name = '%s.py' % file
    version = parser.version()
    version_type = parser.version_type()
    with open('%s/%s' % (package, file_name), 'w') as f:
        f.write('# \n')
        f.write('# automatically generated by setup_scmversion\n')
        f.write('# - do not overwrite\n')
        f.write('# - do not add to source control\n')
        f.write('# \n')
        f.write(f'__version__ = "{version}"\n')
        f.write(f'__version_type__ = "{version_type.name}"\n')
    return package, file_name
