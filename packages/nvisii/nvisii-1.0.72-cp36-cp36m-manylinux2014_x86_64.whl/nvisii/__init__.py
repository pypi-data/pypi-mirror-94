# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

_built_major_version = 3
_built_minor_version = 6

from sys import version_info as _import_version_info
if _import_version_info < (_built_major_version, _built_minor_version, 0):
    raise RuntimeError("This module was built for Python " + str(_built_major_version) + "." + str(_built_minor_version) 
        + " but current interpreter is Python " + str(_import_version_info[0]) + "." + str(_import_version_info[1]) )


import sys
if hasattr(sys, 'gettotalrefcount'):
   raise RuntimeError("This module was built in release mode; however, the current interpreter was built in debug mode.")



import os, sys, platform, math
try:
    from . import version
    __version__ = version.__version__
except ImportError:
    pass

__this_dir__= os.path.dirname(os.path.abspath(__file__))

WIN32=platform.system()=="Windows" or platform.system()=="win32"
if WIN32:
	def AddSysPath(value):
		os.environ['PATH'] = value + os.pathsep + os.environ['PATH']
		sys.path.insert(0, value)
		if hasattr(os,'add_dll_directory'): 
			os.add_dll_directory(value) # this is needed for python 38  

	AddSysPath(__this_dir__)

else:
	sys.path.append(__this_dir__)




from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _nvisii
else:
    import _nvisii

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class ivec2(object):
    r"""Proxy of C++ glm::ivec2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    x = property(_nvisii.ivec2_x_get, _nvisii.ivec2_x_set, doc=r"""x""")
    y = property(_nvisii.ivec2_y_get, _nvisii.ivec2_y_set, doc=r"""y""")

    @staticmethod
    def length():
        r"""length() -> glm::length_t"""
        return _nvisii.ivec2_length()

    def __init__(self, *args):
        r"""
        __init__(self) -> ivec2
        __init__(self, v) -> ivec2

        Parameters
        ----------
        v: glm::ivec2 const &

        __init__(self, scalar) -> ivec2

        Parameters
        ----------
        scalar: int

        __init__(self, s1, s2) -> ivec2

        Parameters
        ----------
        s1: int
        s2: int

        __init__(self, v) -> ivec2

        Parameters
        ----------
        v: glm::ivec3 const &

        __init__(self, v) -> ivec2

        Parameters
        ----------
        v: glm::ivec4 const &

        """
        _nvisii.ivec2_swiginit(self, _nvisii.new_ivec2(*args))

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> int

        Parameters
        ----------
        i: int

        """
        return _nvisii.ivec2___getitem__(self, i)

    def __setitem__(self, i, f):
        r"""
        __setitem__(self, i, f)

        Parameters
        ----------
        i: int
        f: int

        """
        return _nvisii.ivec2___setitem__(self, i, f)

    def __tostring(self):
        r"""__tostring(self) -> std::string"""
        return _nvisii.ivec2___tostring(self)

    def __add__(self, *args):
        r"""
        __add__(self, v) -> ivec2

        Parameters
        ----------
        v: glm::ivec2 const &

        __add__(self, scalar) -> ivec2

        Parameters
        ----------
        scalar: int

        """
        return _nvisii.ivec2___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(self, v) -> ivec2

        Parameters
        ----------
        v: glm::ivec2 const &

        __sub__(self, scalar) -> ivec2

        Parameters
        ----------
        scalar: int

        """
        return _nvisii.ivec2___sub__(self, *args)

    def __mul__(self, *args):
        r"""
        __mul__(self, v) -> ivec2

        Parameters
        ----------
        v: glm::ivec2 const &

        __mul__(self, scalar) -> ivec2

        Parameters
        ----------
        scalar: int

        """
        return _nvisii.ivec2___mul__(self, *args)

    def __truediv__(self, *args):
        return _nvisii.ivec2___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, v):
        r"""
        __eq__(self, v) -> bool

        Parameters
        ----------
        v: glm::ivec2 const &

        """
        return _nvisii.ivec2___eq__(self, v)

    def __ne__(self, v):
        r"""
        __ne__(self, v) -> bool

        Parameters
        ----------
        v: glm::ivec2 const &

        """
        return _nvisii.ivec2___ne__(self, v)

    def __repr__(self):
        r"""__repr__(self) -> std::string"""
        return _nvisii.ivec2___repr__(self)
    __swig_destroy__ = _nvisii.delete_ivec2

# Register ivec2 in _nvisii:
_nvisii.ivec2_swigregister(ivec2)

def ivec2_length():
    r"""ivec2_length() -> glm::length_t"""
    return _nvisii.ivec2_length()

class ivec3(object):
    r"""Proxy of C++ glm::ivec3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    x = property(_nvisii.ivec3_x_get, _nvisii.ivec3_x_set, doc=r"""x""")
    y = property(_nvisii.ivec3_y_get, _nvisii.ivec3_y_set, doc=r"""y""")
    z = property(_nvisii.ivec3_z_get, _nvisii.ivec3_z_set, doc=r"""z""")

    @staticmethod
    def length():
        r"""length() -> glm::length_t"""
        return _nvisii.ivec3_length()

    def __init__(self, *args):
        r"""
        __init__(self) -> ivec3
        __init__(self, v) -> ivec3

        Parameters
        ----------
        v: glm::ivec3 const &

        __init__(self, scalar) -> ivec3

        Parameters
        ----------
        scalar: int

        __init__(self, s1, s2, s3) -> ivec3

        Parameters
        ----------
        s1: int
        s2: int
        s3: int

        __init__(self, a, b) -> ivec3

        Parameters
        ----------
        a: glm::ivec2 const &
        b: int

        __init__(self, a, b) -> ivec3

        Parameters
        ----------
        a: int
        b: glm::ivec2 const &

        __init__(self, v) -> ivec3

        Parameters
        ----------
        v: glm::ivec4 const &

        """
        _nvisii.ivec3_swiginit(self, _nvisii.new_ivec3(*args))

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> int

        Parameters
        ----------
        i: int

        """
        return _nvisii.ivec3___getitem__(self, i)

    def __setitem__(self, i, f):
        r"""
        __setitem__(self, i, f)

        Parameters
        ----------
        i: int
        f: int

        """
        return _nvisii.ivec3___setitem__(self, i, f)

    def __tostring(self):
        r"""__tostring(self) -> std::string"""
        return _nvisii.ivec3___tostring(self)

    def __add__(self, *args):
        r"""
        __add__(self, v) -> ivec3

        Parameters
        ----------
        v: glm::ivec3 const &

        __add__(self, scalar) -> ivec3

        Parameters
        ----------
        scalar: int

        """
        return _nvisii.ivec3___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(self, v) -> ivec3

        Parameters
        ----------
        v: glm::ivec3 const &

        __sub__(self, scalar) -> ivec3

        Parameters
        ----------
        scalar: int

        """
        return _nvisii.ivec3___sub__(self, *args)

    def __mul__(self, *args):
        r"""
        __mul__(self, v) -> ivec3

        Parameters
        ----------
        v: glm::ivec3 const &

        __mul__(self, scalar) -> ivec3

        Parameters
        ----------
        scalar: int

        """
        return _nvisii.ivec3___mul__(self, *args)

    def __truediv__(self, *args):
        return _nvisii.ivec3___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, v):
        r"""
        __eq__(self, v) -> bool

        Parameters
        ----------
        v: glm::ivec3 const &

        """
        return _nvisii.ivec3___eq__(self, v)

    def __ne__(self, v):
        r"""
        __ne__(self, v) -> bool

        Parameters
        ----------
        v: glm::ivec3 const &

        """
        return _nvisii.ivec3___ne__(self, v)

    def __repr__(self):
        r"""__repr__(self) -> std::string"""
        return _nvisii.ivec3___repr__(self)
    __swig_destroy__ = _nvisii.delete_ivec3

# Register ivec3 in _nvisii:
_nvisii.ivec3_swigregister(ivec3)

def ivec3_length():
    r"""ivec3_length() -> glm::length_t"""
    return _nvisii.ivec3_length()

class ivec4(object):
    r"""Proxy of C++ glm::ivec4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    x = property(_nvisii.ivec4_x_get, _nvisii.ivec4_x_set, doc=r"""x""")
    y = property(_nvisii.ivec4_y_get, _nvisii.ivec4_y_set, doc=r"""y""")
    z = property(_nvisii.ivec4_z_get, _nvisii.ivec4_z_set, doc=r"""z""")
    w = property(_nvisii.ivec4_w_get, _nvisii.ivec4_w_set, doc=r"""w""")

    @staticmethod
    def length():
        r"""length() -> glm::length_t"""
        return _nvisii.ivec4_length()

    def __init__(self, *args):
        r"""
        __init__(self) -> ivec4
        __init__(self, v) -> ivec4

        Parameters
        ----------
        v: glm::ivec4 const &

        __init__(self, scalar) -> ivec4

        Parameters
        ----------
        scalar: int

        __init__(self, s1, s2, s3, s4) -> ivec4

        Parameters
        ----------
        s1: int
        s2: int
        s3: int
        s4: int

        __init__(self, a, b) -> ivec4

        Parameters
        ----------
        a: glm::ivec2 const &
        b: glm::ivec2 const &

        __init__(self, a, b, c) -> ivec4

        Parameters
        ----------
        a: glm::ivec2 const &
        b: int
        c: int

        __init__(self, a, b, c) -> ivec4

        Parameters
        ----------
        a: int
        b: glm::ivec2 const &
        c: int

        __init__(self, a, b, c) -> ivec4

        Parameters
        ----------
        a: int
        b: int
        c: glm::ivec2 const &

        __init__(self, a, b) -> ivec4

        Parameters
        ----------
        a: glm::ivec3 const &
        b: int

        __init__(self, a, b) -> ivec4

        Parameters
        ----------
        a: int
        b: glm::ivec3 const &

        """
        _nvisii.ivec4_swiginit(self, _nvisii.new_ivec4(*args))

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> int

        Parameters
        ----------
        i: int

        """
        return _nvisii.ivec4___getitem__(self, i)

    def __setitem__(self, i, f):
        r"""
        __setitem__(self, i, f)

        Parameters
        ----------
        i: int
        f: int

        """
        return _nvisii.ivec4___setitem__(self, i, f)

    def __tostring(self):
        r"""__tostring(self) -> std::string"""
        return _nvisii.ivec4___tostring(self)

    def __add__(self, *args):
        r"""
        __add__(self, v) -> ivec4

        Parameters
        ----------
        v: glm::ivec4 const &

        __add__(self, scalar) -> ivec4

        Parameters
        ----------
        scalar: int

        """
        return _nvisii.ivec4___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(self, v) -> ivec4

        Parameters
        ----------
        v: glm::ivec4 const &

        __sub__(self, scalar) -> ivec4

        Parameters
        ----------
        scalar: int

        """
        return _nvisii.ivec4___sub__(self, *args)

    def __mul__(self, *args):
        r"""
        __mul__(self, v) -> ivec4

        Parameters
        ----------
        v: glm::ivec4 const &

        __mul__(self, scalar) -> ivec4

        Parameters
        ----------
        scalar: int

        """
        return _nvisii.ivec4___mul__(self, *args)

    def __truediv__(self, *args):
        return _nvisii.ivec4___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, v):
        r"""
        __eq__(self, v) -> bool

        Parameters
        ----------
        v: glm::ivec4 const &

        """
        return _nvisii.ivec4___eq__(self, v)

    def __ne__(self, v):
        r"""
        __ne__(self, v) -> bool

        Parameters
        ----------
        v: glm::ivec4 const &

        """
        return _nvisii.ivec4___ne__(self, v)

    def __repr__(self):
        r"""__repr__(self) -> std::string"""
        return _nvisii.ivec4___repr__(self)
    __swig_destroy__ = _nvisii.delete_ivec4

# Register ivec4 in _nvisii:
_nvisii.ivec4_swigregister(ivec4)

def ivec4_length():
    r"""ivec4_length() -> glm::length_t"""
    return _nvisii.ivec4_length()

class vec2(object):
    r"""Proxy of C++ glm::vec2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    x = property(_nvisii.vec2_x_get, _nvisii.vec2_x_set, doc=r"""x""")
    y = property(_nvisii.vec2_y_get, _nvisii.vec2_y_set, doc=r"""y""")

    @staticmethod
    def length():
        r"""length() -> glm::length_t"""
        return _nvisii.vec2_length()

    def __init__(self, *args):
        r"""
        __init__(self) -> vec2
        __init__(self, v) -> vec2

        Parameters
        ----------
        v: glm::vec2 const &

        __init__(self, scalar) -> vec2

        Parameters
        ----------
        scalar: float

        __init__(self, s1, s2) -> vec2

        Parameters
        ----------
        s1: float
        s2: float

        __init__(self, v) -> vec2

        Parameters
        ----------
        v: glm::vec3 const &

        __init__(self, v) -> vec2

        Parameters
        ----------
        v: glm::vec4 const &

        """
        _nvisii.vec2_swiginit(self, _nvisii.new_vec2(*args))

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> float

        Parameters
        ----------
        i: int

        """
        return _nvisii.vec2___getitem__(self, i)

    def __setitem__(self, i, f):
        r"""
        __setitem__(self, i, f)

        Parameters
        ----------
        i: int
        f: float

        """
        return _nvisii.vec2___setitem__(self, i, f)

    def __tostring(self):
        r"""__tostring(self) -> std::string"""
        return _nvisii.vec2___tostring(self)

    def __add__(self, *args):
        r"""
        __add__(self, v) -> vec2

        Parameters
        ----------
        v: glm::vec2 const &

        __add__(self, scalar) -> vec2

        Parameters
        ----------
        scalar: float

        """
        return _nvisii.vec2___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(self, v) -> vec2

        Parameters
        ----------
        v: glm::vec2 const &

        __sub__(self, scalar) -> vec2

        Parameters
        ----------
        scalar: float

        """
        return _nvisii.vec2___sub__(self, *args)

    def __mul__(self, *args):
        r"""
        __mul__(self, v) -> vec2

        Parameters
        ----------
        v: glm::vec2 const &

        __mul__(self, scalar) -> vec2

        Parameters
        ----------
        scalar: float

        """
        return _nvisii.vec2___mul__(self, *args)

    def __truediv__(self, *args):
        return _nvisii.vec2___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, v):
        r"""
        __eq__(self, v) -> bool

        Parameters
        ----------
        v: glm::vec2 const &

        """
        return _nvisii.vec2___eq__(self, v)

    def __ne__(self, v):
        r"""
        __ne__(self, v) -> bool

        Parameters
        ----------
        v: glm::vec2 const &

        """
        return _nvisii.vec2___ne__(self, v)

    def __repr__(self):
        r"""__repr__(self) -> std::string"""
        return _nvisii.vec2___repr__(self)
    __swig_destroy__ = _nvisii.delete_vec2

# Register vec2 in _nvisii:
_nvisii.vec2_swigregister(vec2)

def vec2_length():
    r"""vec2_length() -> glm::length_t"""
    return _nvisii.vec2_length()

class vec3(object):
    r"""Proxy of C++ glm::vec3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    x = property(_nvisii.vec3_x_get, _nvisii.vec3_x_set, doc=r"""x""")
    y = property(_nvisii.vec3_y_get, _nvisii.vec3_y_set, doc=r"""y""")
    z = property(_nvisii.vec3_z_get, _nvisii.vec3_z_set, doc=r"""z""")

    @staticmethod
    def length():
        r"""length() -> glm::length_t"""
        return _nvisii.vec3_length()

    def __init__(self, *args):
        r"""
        __init__(self) -> vec3
        __init__(self, v) -> vec3

        Parameters
        ----------
        v: glm::vec3 const &

        __init__(self, scalar) -> vec3

        Parameters
        ----------
        scalar: float

        __init__(self, s1, s2, s3) -> vec3

        Parameters
        ----------
        s1: float
        s2: float
        s3: float

        __init__(self, a, b) -> vec3

        Parameters
        ----------
        a: glm::vec2 const &
        b: float

        __init__(self, a, b) -> vec3

        Parameters
        ----------
        a: float
        b: glm::vec2 const &

        __init__(self, v) -> vec3

        Parameters
        ----------
        v: glm::vec4 const &

        """
        _nvisii.vec3_swiginit(self, _nvisii.new_vec3(*args))

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> float

        Parameters
        ----------
        i: int

        """
        return _nvisii.vec3___getitem__(self, i)

    def __setitem__(self, i, f):
        r"""
        __setitem__(self, i, f)

        Parameters
        ----------
        i: int
        f: float

        """
        return _nvisii.vec3___setitem__(self, i, f)

    def __tostring(self):
        r"""__tostring(self) -> std::string"""
        return _nvisii.vec3___tostring(self)

    def __add__(self, *args):
        r"""
        __add__(self, v) -> vec3

        Parameters
        ----------
        v: glm::vec3 const &

        __add__(self, scalar) -> vec3

        Parameters
        ----------
        scalar: float

        """
        return _nvisii.vec3___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(self, v) -> vec3

        Parameters
        ----------
        v: glm::vec3 const &

        __sub__(self, scalar) -> vec3

        Parameters
        ----------
        scalar: float

        """
        return _nvisii.vec3___sub__(self, *args)

    def __mul__(self, *args):
        r"""
        __mul__(self, v) -> vec3

        Parameters
        ----------
        v: glm::vec3 const &

        __mul__(self, scalar) -> vec3

        Parameters
        ----------
        scalar: float

        """
        return _nvisii.vec3___mul__(self, *args)

    def __truediv__(self, *args):
        return _nvisii.vec3___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, v):
        r"""
        __eq__(self, v) -> bool

        Parameters
        ----------
        v: glm::vec3 const &

        """
        return _nvisii.vec3___eq__(self, v)

    def __ne__(self, v):
        r"""
        __ne__(self, v) -> bool

        Parameters
        ----------
        v: glm::vec3 const &

        """
        return _nvisii.vec3___ne__(self, v)

    def __repr__(self):
        r"""__repr__(self) -> std::string"""
        return _nvisii.vec3___repr__(self)
    __swig_destroy__ = _nvisii.delete_vec3

# Register vec3 in _nvisii:
_nvisii.vec3_swigregister(vec3)

def vec3_length():
    r"""vec3_length() -> glm::length_t"""
    return _nvisii.vec3_length()

class vec4(object):
    r"""Proxy of C++ glm::vec4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    x = property(_nvisii.vec4_x_get, _nvisii.vec4_x_set, doc=r"""x""")
    y = property(_nvisii.vec4_y_get, _nvisii.vec4_y_set, doc=r"""y""")
    z = property(_nvisii.vec4_z_get, _nvisii.vec4_z_set, doc=r"""z""")
    w = property(_nvisii.vec4_w_get, _nvisii.vec4_w_set, doc=r"""w""")

    @staticmethod
    def length():
        r"""length() -> glm::length_t"""
        return _nvisii.vec4_length()

    def __init__(self, *args):
        r"""
        __init__(self) -> vec4
        __init__(self, v) -> vec4

        Parameters
        ----------
        v: glm::vec4 const &

        __init__(self, scalar) -> vec4

        Parameters
        ----------
        scalar: float

        __init__(self, s1, s2, s3, s4) -> vec4

        Parameters
        ----------
        s1: float
        s2: float
        s3: float
        s4: float

        __init__(self, a, b) -> vec4

        Parameters
        ----------
        a: glm::vec2 const &
        b: glm::vec2 const &

        __init__(self, a, b, c) -> vec4

        Parameters
        ----------
        a: glm::vec2 const &
        b: float
        c: float

        __init__(self, a, b, c) -> vec4

        Parameters
        ----------
        a: float
        b: glm::vec2 const &
        c: float

        __init__(self, a, b, c) -> vec4

        Parameters
        ----------
        a: float
        b: float
        c: glm::vec2 const &

        __init__(self, a, b) -> vec4

        Parameters
        ----------
        a: glm::vec3 const &
        b: float

        __init__(self, a, b) -> vec4

        Parameters
        ----------
        a: float
        b: glm::vec3 const &

        """
        _nvisii.vec4_swiginit(self, _nvisii.new_vec4(*args))

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> float

        Parameters
        ----------
        i: int

        """
        return _nvisii.vec4___getitem__(self, i)

    def __setitem__(self, i, f):
        r"""
        __setitem__(self, i, f)

        Parameters
        ----------
        i: int
        f: float

        """
        return _nvisii.vec4___setitem__(self, i, f)

    def __tostring(self):
        r"""__tostring(self) -> std::string"""
        return _nvisii.vec4___tostring(self)

    def __add__(self, *args):
        r"""
        __add__(self, v) -> vec4

        Parameters
        ----------
        v: glm::vec4 const &

        __add__(self, scalar) -> vec4

        Parameters
        ----------
        scalar: float

        """
        return _nvisii.vec4___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(self, v) -> vec4

        Parameters
        ----------
        v: glm::vec4 const &

        __sub__(self, scalar) -> vec4

        Parameters
        ----------
        scalar: float

        """
        return _nvisii.vec4___sub__(self, *args)

    def __mul__(self, *args):
        r"""
        __mul__(self, v) -> vec4

        Parameters
        ----------
        v: glm::vec4 const &

        __mul__(self, scalar) -> vec4

        Parameters
        ----------
        scalar: float

        """
        return _nvisii.vec4___mul__(self, *args)

    def __truediv__(self, *args):
        return _nvisii.vec4___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, v):
        r"""
        __eq__(self, v) -> bool

        Parameters
        ----------
        v: glm::vec4 const &

        """
        return _nvisii.vec4___eq__(self, v)

    def __ne__(self, v):
        r"""
        __ne__(self, v) -> bool

        Parameters
        ----------
        v: glm::vec4 const &

        """
        return _nvisii.vec4___ne__(self, v)

    def __repr__(self):
        r"""__repr__(self) -> std::string"""
        return _nvisii.vec4___repr__(self)
    __swig_destroy__ = _nvisii.delete_vec4

# Register vec4 in _nvisii:
_nvisii.vec4_swigregister(vec4)

def vec4_length():
    r"""vec4_length() -> glm::length_t"""
    return _nvisii.vec4_length()

class u16vec2(object):
    r"""Proxy of C++ glm::u16vec2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_nvisii.u16vec2_x_get, _nvisii.u16vec2_x_set, doc=r"""x""")
    y = property(_nvisii.u16vec2_y_get, _nvisii.u16vec2_y_set, doc=r"""y""")

    @staticmethod
    def length():
        r"""length() -> glm::length_t"""
        return _nvisii.u16vec2_length()

    def __init__(self, *args):
        r"""
        __init__(self) -> u16vec2
        __init__(self, v) -> u16vec2

        Parameters
        ----------
        v: glm::u16vec2 const &

        __init__(self, scalar) -> u16vec2

        Parameters
        ----------
        scalar: uint16_t

        __init__(self, s1, s2) -> u16vec2

        Parameters
        ----------
        s1: uint16_t
        s2: uint16_t

        __init__(self, v) -> u16vec2

        Parameters
        ----------
        v: glm::u16vec3 const &

        __init__(self, v) -> u16vec2

        Parameters
        ----------
        v: glm::u16vec4 const &

        """
        _nvisii.u16vec2_swiginit(self, _nvisii.new_u16vec2(*args))

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> int

        Parameters
        ----------
        i: int

        """
        return _nvisii.u16vec2___getitem__(self, i)

    def __setitem__(self, i, f):
        r"""
        __setitem__(self, i, f)

        Parameters
        ----------
        i: int
        f: int

        """
        return _nvisii.u16vec2___setitem__(self, i, f)

    def __tostring(self):
        r"""__tostring(self) -> std::string"""
        return _nvisii.u16vec2___tostring(self)

    def __add__(self, *args):
        r"""
        __add__(self, v) -> u16vec2

        Parameters
        ----------
        v: glm::u16vec2 const &

        __add__(self, scalar) -> u16vec2

        Parameters
        ----------
        scalar: uint16_t

        """
        return _nvisii.u16vec2___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(self, v) -> u16vec2

        Parameters
        ----------
        v: glm::u16vec2 const &

        __sub__(self, scalar) -> u16vec2

        Parameters
        ----------
        scalar: uint16_t

        """
        return _nvisii.u16vec2___sub__(self, *args)

    def __mul__(self, *args):
        r"""
        __mul__(self, v) -> u16vec2

        Parameters
        ----------
        v: glm::u16vec2 const &

        __mul__(self, scalar) -> u16vec2

        Parameters
        ----------
        scalar: uint16_t

        """
        return _nvisii.u16vec2___mul__(self, *args)

    def __truediv__(self, *args):
        return _nvisii.u16vec2___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, v):
        r"""
        __eq__(self, v) -> bool

        Parameters
        ----------
        v: glm::u16vec2 const &

        """
        return _nvisii.u16vec2___eq__(self, v)

    def __ne__(self, v):
        r"""
        __ne__(self, v) -> bool

        Parameters
        ----------
        v: glm::u16vec2 const &

        """
        return _nvisii.u16vec2___ne__(self, v)
    __swig_destroy__ = _nvisii.delete_u16vec2

# Register u16vec2 in _nvisii:
_nvisii.u16vec2_swigregister(u16vec2)

def u16vec2_length():
    r"""u16vec2_length() -> glm::length_t"""
    return _nvisii.u16vec2_length()

class u16vec3(object):
    r"""Proxy of C++ glm::u16vec3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_nvisii.u16vec3_x_get, _nvisii.u16vec3_x_set, doc=r"""x""")
    y = property(_nvisii.u16vec3_y_get, _nvisii.u16vec3_y_set, doc=r"""y""")
    z = property(_nvisii.u16vec3_z_get, _nvisii.u16vec3_z_set, doc=r"""z""")

    @staticmethod
    def length():
        r"""length() -> glm::length_t"""
        return _nvisii.u16vec3_length()

    def __init__(self, *args):
        r"""
        __init__(self) -> u16vec3
        __init__(self, v) -> u16vec3

        Parameters
        ----------
        v: glm::u16vec3 const &

        __init__(self, scalar) -> u16vec3

        Parameters
        ----------
        scalar: uint16_t

        __init__(self, s1, s2, s3) -> u16vec3

        Parameters
        ----------
        s1: uint16_t
        s2: uint16_t
        s3: uint16_t

        __init__(self, a, b) -> u16vec3

        Parameters
        ----------
        a: glm::u16vec2 const &
        b: int

        __init__(self, a, b) -> u16vec3

        Parameters
        ----------
        a: uint16_t
        b: glm::u16vec2 const &

        __init__(self, v) -> u16vec3

        Parameters
        ----------
        v: glm::u16vec4 const &

        """
        _nvisii.u16vec3_swiginit(self, _nvisii.new_u16vec3(*args))

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> int

        Parameters
        ----------
        i: int

        """
        return _nvisii.u16vec3___getitem__(self, i)

    def __setitem__(self, i, f):
        r"""
        __setitem__(self, i, f)

        Parameters
        ----------
        i: int
        f: int

        """
        return _nvisii.u16vec3___setitem__(self, i, f)

    def __tostring(self):
        r"""__tostring(self) -> std::string"""
        return _nvisii.u16vec3___tostring(self)

    def __add__(self, *args):
        r"""
        __add__(self, v) -> u16vec3

        Parameters
        ----------
        v: glm::u16vec3 const &

        __add__(self, scalar) -> u16vec3

        Parameters
        ----------
        scalar: uint16_t

        """
        return _nvisii.u16vec3___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(self, v) -> u16vec3

        Parameters
        ----------
        v: glm::u16vec3 const &

        __sub__(self, scalar) -> u16vec3

        Parameters
        ----------
        scalar: uint16_t

        """
        return _nvisii.u16vec3___sub__(self, *args)

    def __mul__(self, *args):
        r"""
        __mul__(self, v) -> u16vec3

        Parameters
        ----------
        v: glm::u16vec3 const &

        __mul__(self, scalar) -> u16vec3

        Parameters
        ----------
        scalar: uint16_t

        """
        return _nvisii.u16vec3___mul__(self, *args)

    def __truediv__(self, *args):
        return _nvisii.u16vec3___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, v):
        r"""
        __eq__(self, v) -> bool

        Parameters
        ----------
        v: glm::u16vec3 const &

        """
        return _nvisii.u16vec3___eq__(self, v)

    def __ne__(self, v):
        r"""
        __ne__(self, v) -> bool

        Parameters
        ----------
        v: glm::u16vec3 const &

        """
        return _nvisii.u16vec3___ne__(self, v)
    __swig_destroy__ = _nvisii.delete_u16vec3

# Register u16vec3 in _nvisii:
_nvisii.u16vec3_swigregister(u16vec3)

def u16vec3_length():
    r"""u16vec3_length() -> glm::length_t"""
    return _nvisii.u16vec3_length()

class u16vec4(object):
    r"""Proxy of C++ glm::u16vec4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_nvisii.u16vec4_x_get, _nvisii.u16vec4_x_set, doc=r"""x""")
    y = property(_nvisii.u16vec4_y_get, _nvisii.u16vec4_y_set, doc=r"""y""")
    z = property(_nvisii.u16vec4_z_get, _nvisii.u16vec4_z_set, doc=r"""z""")
    w = property(_nvisii.u16vec4_w_get, _nvisii.u16vec4_w_set, doc=r"""w""")

    @staticmethod
    def length():
        r"""length() -> glm::length_t"""
        return _nvisii.u16vec4_length()

    def __init__(self, *args):
        r"""
        __init__(self) -> u16vec4
        __init__(self, v) -> u16vec4

        Parameters
        ----------
        v: glm::u16vec4 const &

        __init__(self, scalar) -> u16vec4

        Parameters
        ----------
        scalar: uint16_t

        __init__(self, s1, s2, s3, s4) -> u16vec4

        Parameters
        ----------
        s1: uint16_t
        s2: uint16_t
        s3: uint16_t
        s4: uint16_t

        __init__(self, a, b) -> u16vec4

        Parameters
        ----------
        a: glm::u16vec2 const &
        b: glm::u16vec2 const &

        __init__(self, a, b, c) -> u16vec4

        Parameters
        ----------
        a: glm::u16vec2 const &
        b: uint16_t
        c: uint16_t

        __init__(self, a, b, c) -> u16vec4

        Parameters
        ----------
        a: uint16_t
        b: glm::u16vec2 const &
        c: uint16_t

        __init__(self, a, b, c) -> u16vec4

        Parameters
        ----------
        a: uint16_t
        b: uint16_t
        c: glm::u16vec2 const &

        __init__(self, a, b) -> u16vec4

        Parameters
        ----------
        a: glm::u16vec3 const &
        b: uint16_t

        __init__(self, a, b) -> u16vec4

        Parameters
        ----------
        a: uint16_t
        b: glm::u16vec3 const &

        """
        _nvisii.u16vec4_swiginit(self, _nvisii.new_u16vec4(*args))

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> int

        Parameters
        ----------
        i: int

        """
        return _nvisii.u16vec4___getitem__(self, i)

    def __setitem__(self, i, f):
        r"""
        __setitem__(self, i, f)

        Parameters
        ----------
        i: int
        f: int

        """
        return _nvisii.u16vec4___setitem__(self, i, f)

    def __tostring(self):
        r"""__tostring(self) -> std::string"""
        return _nvisii.u16vec4___tostring(self)

    def __add__(self, *args):
        r"""
        __add__(self, v) -> u16vec4

        Parameters
        ----------
        v: glm::u16vec4 const &

        __add__(self, scalar) -> u16vec4

        Parameters
        ----------
        scalar: uint16_t

        """
        return _nvisii.u16vec4___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(self, v) -> u16vec4

        Parameters
        ----------
        v: glm::u16vec4 const &

        __sub__(self, scalar) -> u16vec4

        Parameters
        ----------
        scalar: uint16_t

        """
        return _nvisii.u16vec4___sub__(self, *args)

    def __mul__(self, *args):
        r"""
        __mul__(self, v) -> u16vec4

        Parameters
        ----------
        v: glm::u16vec4 const &

        __mul__(self, scalar) -> u16vec4

        Parameters
        ----------
        scalar: uint16_t

        """
        return _nvisii.u16vec4___mul__(self, *args)

    def __truediv__(self, *args):
        return _nvisii.u16vec4___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, v):
        r"""
        __eq__(self, v) -> bool

        Parameters
        ----------
        v: glm::u16vec4 const &

        """
        return _nvisii.u16vec4___eq__(self, v)

    def __ne__(self, v):
        r"""
        __ne__(self, v) -> bool

        Parameters
        ----------
        v: glm::u16vec4 const &

        """
        return _nvisii.u16vec4___ne__(self, v)
    __swig_destroy__ = _nvisii.delete_u16vec4

# Register u16vec4 in _nvisii:
_nvisii.u16vec4_swigregister(u16vec4)

def u16vec4_length():
    r"""u16vec4_length() -> glm::length_t"""
    return _nvisii.u16vec4_length()

class mat3(object):
    r"""Proxy of C++ glm::mat3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    @staticmethod
    def length():
        r"""length() -> glm::length_t"""
        return _nvisii.mat3_length()

    def __init__(self, *args):
        r"""
        __init__(self) -> mat3
        __init__(self, v) -> mat3

        Parameters
        ----------
        v: glm::mat3 const &

        __init__(self, scalar) -> mat3

        Parameters
        ----------
        scalar: float

        __init__(self, x0, y0, z0, x1, y1, z1, x2, y2, z2) -> mat3

        Parameters
        ----------
        x0: float
        y0: float
        z0: float
        x1: float
        y1: float
        z1: float
        x2: float
        y2: float
        z2: float

        __init__(self, v1, v2, v3) -> mat3

        Parameters
        ----------
        v1: glm::vec3 const &
        v2: glm::vec3 const &
        v3: glm::vec3 const &

        __init__(self, m) -> mat3

        Parameters
        ----------
        m: glm::mat4 const &

        """
        _nvisii.mat3_swiginit(self, _nvisii.new_mat3(*args))

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> vec3

        Parameters
        ----------
        i: int

        """
        return _nvisii.mat3___getitem__(self, i)

    def __setitem__(self, i, v):
        r"""
        __setitem__(self, i, v)

        Parameters
        ----------
        i: int
        v: glm::vec3

        """
        return _nvisii.mat3___setitem__(self, i, v)

    def __tostring(self):
        r"""__tostring(self) -> std::string"""
        return _nvisii.mat3___tostring(self)

    def __add__(self, *args):
        r"""
        __add__(self, scalar) -> mat3

        Parameters
        ----------
        scalar: float

        __add__(self, m) -> mat3

        Parameters
        ----------
        m: glm::mat3 const &

        """
        return _nvisii.mat3___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(self, scalar) -> mat3

        Parameters
        ----------
        scalar: float

        __sub__(self, m) -> mat3

        Parameters
        ----------
        m: glm::mat3 const &

        """
        return _nvisii.mat3___sub__(self, *args)

    def __mul__(self, *args):
        r"""
        __mul__(self, scalar) -> mat3

        Parameters
        ----------
        scalar: float

        __mul__(self, m) -> mat3

        Parameters
        ----------
        m: glm::mat3 const &

        __mul__(self, v) -> vec3

        Parameters
        ----------
        v: glm::vec3 const &

        """
        return _nvisii.mat3___mul__(self, *args)

    def __truediv__(self, *args):
        return _nvisii.mat3___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, m):
        r"""
        __eq__(self, m) -> bool

        Parameters
        ----------
        m: glm::mat3 const &

        """
        return _nvisii.mat3___eq__(self, m)

    def __ne__(self, m):
        r"""
        __ne__(self, m) -> bool

        Parameters
        ----------
        m: glm::mat3 const &

        """
        return _nvisii.mat3___ne__(self, m)

    def __repr__(self):
        r"""__repr__(self) -> std::string"""
        return _nvisii.mat3___repr__(self)
    __swig_destroy__ = _nvisii.delete_mat3

# Register mat3 in _nvisii:
_nvisii.mat3_swigregister(mat3)

def mat3_length():
    r"""mat3_length() -> glm::length_t"""
    return _nvisii.mat3_length()

class mat4(object):
    r"""Proxy of C++ glm::mat4 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    @staticmethod
    def length():
        r"""length() -> glm::length_t"""
        return _nvisii.mat4_length()

    def __init__(self, *args):
        r"""
        __init__(self) -> mat4
        __init__(self, v) -> mat4

        Parameters
        ----------
        v: glm::mat4 const &

        __init__(self, scalar) -> mat4

        Parameters
        ----------
        scalar: float

        __init__(self, x0, y0, z0, w0, x1, y1, z1, w1, x2, y2, z2, w2, x3, y3, z3, w3) -> mat4

        Parameters
        ----------
        x0: float
        y0: float
        z0: float
        w0: float
        x1: float
        y1: float
        z1: float
        w1: float
        x2: float
        y2: float
        z2: float
        w2: float
        x3: float
        y3: float
        z3: float
        w3: float

        __init__(self, v1, v2, v3, v4) -> mat4

        Parameters
        ----------
        v1: glm::vec4 const &
        v2: glm::vec4 const &
        v3: glm::vec4 const &
        v4: glm::vec4 const &

        __init__(self, m) -> mat4

        Parameters
        ----------
        m: glm::mat3 const &

        """
        _nvisii.mat4_swiginit(self, _nvisii.new_mat4(*args))

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> vec4

        Parameters
        ----------
        i: int

        """
        return _nvisii.mat4___getitem__(self, i)

    def __setitem__(self, i, v):
        r"""
        __setitem__(self, i, v)

        Parameters
        ----------
        i: int
        v: glm::vec4

        """
        return _nvisii.mat4___setitem__(self, i, v)

    def __tostring(self):
        r"""__tostring(self) -> std::string"""
        return _nvisii.mat4___tostring(self)

    def __add__(self, *args):
        r"""
        __add__(self, scalar) -> mat4

        Parameters
        ----------
        scalar: float

        __add__(self, m) -> mat4

        Parameters
        ----------
        m: glm::mat4 const &

        """
        return _nvisii.mat4___add__(self, *args)

    def __sub__(self, *args):
        r"""
        __sub__(self, scalar) -> mat4

        Parameters
        ----------
        scalar: float

        __sub__(self, m) -> mat4

        Parameters
        ----------
        m: glm::mat4 const &

        """
        return _nvisii.mat4___sub__(self, *args)

    def __mul__(self, *args):
        r"""
        __mul__(self, scalar) -> mat4

        Parameters
        ----------
        scalar: float

        __mul__(self, m) -> mat4

        Parameters
        ----------
        m: glm::mat4 const &

        __mul__(self, v) -> vec4

        Parameters
        ----------
        v: glm::vec4 const &

        """
        return _nvisii.mat4___mul__(self, *args)

    def __truediv__(self, *args):
        return _nvisii.mat4___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, m):
        r"""
        __eq__(self, m) -> bool

        Parameters
        ----------
        m: glm::mat4 const &

        """
        return _nvisii.mat4___eq__(self, m)

    def __ne__(self, m):
        r"""
        __ne__(self, m) -> bool

        Parameters
        ----------
        m: glm::mat4 const &

        """
        return _nvisii.mat4___ne__(self, m)

    def __repr__(self):
        r"""__repr__(self) -> std::string"""
        return _nvisii.mat4___repr__(self)
    __swig_destroy__ = _nvisii.delete_mat4

# Register mat4 in _nvisii:
_nvisii.mat4_swigregister(mat4)

def mat4_length():
    r"""mat4_length() -> glm::length_t"""
    return _nvisii.mat4_length()

class quat(object):
    r"""Proxy of C++ glm::quat class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    x = property(_nvisii.quat_x_get, _nvisii.quat_x_set, doc=r"""x""")
    y = property(_nvisii.quat_y_get, _nvisii.quat_y_set, doc=r"""y""")
    z = property(_nvisii.quat_z_get, _nvisii.quat_z_set, doc=r"""z""")
    w = property(_nvisii.quat_w_get, _nvisii.quat_w_set, doc=r"""w""")

    @staticmethod
    def length():
        r"""length() -> glm::length_t"""
        return _nvisii.quat_length()

    def __init__(self, *args):
        r"""
        __init__(self) -> quat
        __init__(self, q) -> quat

        Parameters
        ----------
        q: glm::quat const &

        __init__(self, s, v) -> quat

        Parameters
        ----------
        s: float
        v: glm::vec3 const &

        __init__(self, w, x, y, z) -> quat

        Parameters
        ----------
        w: float
        x: float
        y: float
        z: float

        __init__(self, u, v) -> quat

        Parameters
        ----------
        u: glm::vec3 const &
        v: glm::vec3 const &

        __init__(self, eulerAngles) -> quat

        Parameters
        ----------
        eulerAngles: glm::vec3 const &

        __init__(self, m) -> quat

        Parameters
        ----------
        m: glm::mat3 const &

        __init__(self, m) -> quat

        Parameters
        ----------
        m: glm::mat4 const &

        """
        _nvisii.quat_swiginit(self, _nvisii.new_quat(*args))

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> float

        Parameters
        ----------
        i: int

        """
        return _nvisii.quat___getitem__(self, i)

    def __setitem__(self, i, f):
        r"""
        __setitem__(self, i, f)

        Parameters
        ----------
        i: int
        f: float

        """
        return _nvisii.quat___setitem__(self, i, f)

    def __tostring(self):
        r"""__tostring(self) -> std::string"""
        return _nvisii.quat___tostring(self)

    def __sub__(self, q):
        r"""
        __sub__(self, q) -> quat

        Parameters
        ----------
        q: glm::quat const &

        """
        return _nvisii.quat___sub__(self, q)

    def __add__(self, q):
        r"""
        __add__(self, q) -> quat

        Parameters
        ----------
        q: glm::quat const &

        """
        return _nvisii.quat___add__(self, q)

    def __mul__(self, *args):
        r"""
        __mul__(self, q) -> quat

        Parameters
        ----------
        q: glm::quat const &

        __mul__(self, v) -> vec3

        Parameters
        ----------
        v: glm::vec3 const &

        __mul__(self, v) -> vec4

        Parameters
        ----------
        v: glm::vec4 const &

        __mul__(self, s) -> quat

        Parameters
        ----------
        s: float const &

        """
        return _nvisii.quat___mul__(self, *args)

    def __truediv__(self, *args):
        return _nvisii.quat___truediv__(self, *args)
    __div__ = __truediv__



    def __eq__(self, q):
        r"""
        __eq__(self, q) -> bool

        Parameters
        ----------
        q: glm::quat const &

        """
        return _nvisii.quat___eq__(self, q)

    def __ne__(self, q):
        r"""
        __ne__(self, q) -> bool

        Parameters
        ----------
        q: glm::quat const &

        """
        return _nvisii.quat___ne__(self, q)

    def __repr__(self):
        r"""__repr__(self) -> std::string"""
        return _nvisii.quat___repr__(self)
    __swig_destroy__ = _nvisii.delete_quat

# Register quat in _nvisii:
_nvisii.quat_swigregister(quat)

def quat_length():
    r"""quat_length() -> glm::length_t"""
    return _nvisii.quat_length()


def __sub__(*args):
    r"""
    __sub__(v, scalar) -> ivec2

    Parameters
    ----------
    v: glm::ivec2 const &
    scalar: int

    __sub__(scalar, v) -> ivec2

    Parameters
    ----------
    scalar: int
    v: glm::ivec2 const &

    __sub__(v1, v2) -> ivec2

    Parameters
    ----------
    v1: glm::ivec2 const &
    v2: glm::ivec2 const &

    __sub__(v, scalar) -> ivec3

    Parameters
    ----------
    v: glm::ivec3 const &
    scalar: int

    __sub__(scalar, v) -> ivec3

    Parameters
    ----------
    scalar: int
    v: glm::ivec3 const &

    __sub__(v1, v2) -> ivec3

    Parameters
    ----------
    v1: glm::ivec3 const &
    v2: glm::ivec3 const &

    __sub__(v, scalar) -> ivec4

    Parameters
    ----------
    v: glm::ivec4 const &
    scalar: int

    __sub__(scalar, v) -> ivec4

    Parameters
    ----------
    scalar: int
    v: glm::ivec4 const &

    __sub__(v1, v2) -> ivec4

    Parameters
    ----------
    v1: glm::ivec4 const &
    v2: glm::ivec4 const &

    __sub__(v, scalar) -> vec2

    Parameters
    ----------
    v: glm::vec2 const &
    scalar: float

    __sub__(scalar, v) -> vec2

    Parameters
    ----------
    scalar: float
    v: glm::vec2 const &

    __sub__(v1, v2) -> vec2

    Parameters
    ----------
    v1: glm::vec2 const &
    v2: glm::vec2 const &

    __sub__(v, scalar) -> vec3

    Parameters
    ----------
    v: glm::vec3 const &
    scalar: float

    __sub__(scalar, v) -> vec3

    Parameters
    ----------
    scalar: float
    v: glm::vec3 const &

    __sub__(v1, v2) -> vec3

    Parameters
    ----------
    v1: glm::vec3 const &
    v2: glm::vec3 const &

    __sub__(v, scalar) -> vec4

    Parameters
    ----------
    v: glm::vec4 const &
    scalar: float

    __sub__(scalar, v) -> vec4

    Parameters
    ----------
    scalar: float
    v: glm::vec4 const &

    __sub__(v1, v2) -> vec4

    Parameters
    ----------
    v1: glm::vec4 const &
    v2: glm::vec4 const &

    __sub__(v, scalar) -> u16vec2

    Parameters
    ----------
    v: glm::u16vec2 const &
    scalar: uint16_t

    __sub__(scalar, v) -> u16vec2

    Parameters
    ----------
    scalar: uint16_t
    v: glm::u16vec2 const &

    __sub__(v1, v2) -> u16vec2

    Parameters
    ----------
    v1: glm::u16vec2 const &
    v2: glm::u16vec2 const &

    __sub__(v, scalar) -> u16vec3

    Parameters
    ----------
    v: glm::u16vec3 const &
    scalar: uint16_t

    __sub__(scalar, v) -> u16vec3

    Parameters
    ----------
    scalar: uint16_t
    v: glm::u16vec3 const &

    __sub__(v1, v2) -> u16vec3

    Parameters
    ----------
    v1: glm::u16vec3 const &
    v2: glm::u16vec3 const &

    __sub__(v, scalar) -> u16vec4

    Parameters
    ----------
    v: glm::u16vec4 const &
    scalar: uint16_t

    __sub__(scalar, v) -> u16vec4

    Parameters
    ----------
    scalar: uint16_t
    v: glm::u16vec4 const &

    __sub__(v1, v2) -> u16vec4

    Parameters
    ----------
    v1: glm::u16vec4 const &
    v2: glm::u16vec4 const &

    __sub__(m, scalar) -> mat3

    Parameters
    ----------
    m: glm::mat3 const &
    scalar: float

    __sub__(scalar, m) -> mat3

    Parameters
    ----------
    scalar: float
    m: glm::mat3 const &

    __sub__(m1, m2) -> mat3

    Parameters
    ----------
    m1: glm::mat3 const &
    m2: glm::mat3 const &

    __sub__(m, scalar) -> mat4

    Parameters
    ----------
    m: glm::mat4 const &
    scalar: float

    __sub__(scalar, m) -> mat4

    Parameters
    ----------
    scalar: float
    m: glm::mat4 const &

    __sub__(m1, m2) -> mat4

    Parameters
    ----------
    m1: glm::mat4 const &
    m2: glm::mat4 const &

    __sub__(q, p) -> quat

    Parameters
    ----------
    q: glm::quat const &
    p: glm::quat const &

    """
    return _nvisii.__sub__(*args)

def __add__(*args):
    r"""
    __add__(v, scalar) -> ivec2

    Parameters
    ----------
    v: glm::ivec2 const &
    scalar: int

    __add__(scalar, v) -> ivec2

    Parameters
    ----------
    scalar: int
    v: glm::ivec2 const &

    __add__(v1, v2) -> ivec2

    Parameters
    ----------
    v1: glm::ivec2 const &
    v2: glm::ivec2 const &

    __add__(v, scalar) -> ivec3

    Parameters
    ----------
    v: glm::ivec3 const &
    scalar: int

    __add__(scalar, v) -> ivec3

    Parameters
    ----------
    scalar: int
    v: glm::ivec3 const &

    __add__(v1, v2) -> ivec3

    Parameters
    ----------
    v1: glm::ivec3 const &
    v2: glm::ivec3 const &

    __add__(v, scalar) -> ivec4

    Parameters
    ----------
    v: glm::ivec4 const &
    scalar: int

    __add__(scalar, v) -> ivec4

    Parameters
    ----------
    scalar: int
    v: glm::ivec4 const &

    __add__(v1, v2) -> ivec4

    Parameters
    ----------
    v1: glm::ivec4 const &
    v2: glm::ivec4 const &

    __add__(v, scalar) -> vec2

    Parameters
    ----------
    v: glm::vec2 const &
    scalar: float

    __add__(scalar, v) -> vec2

    Parameters
    ----------
    scalar: float
    v: glm::vec2 const &

    __add__(v1, v2) -> vec2

    Parameters
    ----------
    v1: glm::vec2 const &
    v2: glm::vec2 const &

    __add__(v, scalar) -> vec3

    Parameters
    ----------
    v: glm::vec3 const &
    scalar: float

    __add__(scalar, v) -> vec3

    Parameters
    ----------
    scalar: float
    v: glm::vec3 const &

    __add__(v1, v2) -> vec3

    Parameters
    ----------
    v1: glm::vec3 const &
    v2: glm::vec3 const &

    __add__(v, scalar) -> vec4

    Parameters
    ----------
    v: glm::vec4 const &
    scalar: float

    __add__(scalar, v) -> vec4

    Parameters
    ----------
    scalar: float
    v: glm::vec4 const &

    __add__(v1, v2) -> vec4

    Parameters
    ----------
    v1: glm::vec4 const &
    v2: glm::vec4 const &

    __add__(v, scalar) -> u16vec2

    Parameters
    ----------
    v: glm::u16vec2 const &
    scalar: uint16_t

    __add__(scalar, v) -> u16vec2

    Parameters
    ----------
    scalar: uint16_t
    v: glm::u16vec2 const &

    __add__(v1, v2) -> u16vec2

    Parameters
    ----------
    v1: glm::u16vec2 const &
    v2: glm::u16vec2 const &

    __add__(v, scalar) -> u16vec3

    Parameters
    ----------
    v: glm::u16vec3 const &
    scalar: uint16_t

    __add__(scalar, v) -> u16vec3

    Parameters
    ----------
    scalar: uint16_t
    v: glm::u16vec3 const &

    __add__(v1, v2) -> u16vec3

    Parameters
    ----------
    v1: glm::u16vec3 const &
    v2: glm::u16vec3 const &

    __add__(v, scalar) -> u16vec4

    Parameters
    ----------
    v: glm::u16vec4 const &
    scalar: uint16_t

    __add__(scalar, v) -> u16vec4

    Parameters
    ----------
    scalar: uint16_t
    v: glm::u16vec4 const &

    __add__(v1, v2) -> u16vec4

    Parameters
    ----------
    v1: glm::u16vec4 const &
    v2: glm::u16vec4 const &

    __add__(m, scalar) -> mat3

    Parameters
    ----------
    m: glm::mat3 const &
    scalar: float

    __add__(scalar, m) -> mat3

    Parameters
    ----------
    scalar: float
    m: glm::mat3 const &

    __add__(m1, m2) -> mat3

    Parameters
    ----------
    m1: glm::mat3 const &
    m2: glm::mat3 const &

    __add__(m, scalar) -> mat4

    Parameters
    ----------
    m: glm::mat4 const &
    scalar: float

    __add__(scalar, m) -> mat4

    Parameters
    ----------
    scalar: float
    m: glm::mat4 const &

    __add__(m1, m2) -> mat4

    Parameters
    ----------
    m1: glm::mat4 const &
    m2: glm::mat4 const &

    __add__(q, p) -> quat

    Parameters
    ----------
    q: glm::quat const &
    p: glm::quat const &

    """
    return _nvisii.__add__(*args)

def __mul__(*args):
    r"""
    __mul__(v, scalar) -> ivec2

    Parameters
    ----------
    v: glm::ivec2 const &
    scalar: int

    __mul__(scalar, v) -> ivec2

    Parameters
    ----------
    scalar: int
    v: glm::ivec2 const &

    __mul__(v1, v2) -> ivec2

    Parameters
    ----------
    v1: glm::ivec2 const &
    v2: glm::ivec2 const &

    __mul__(v, scalar) -> ivec3

    Parameters
    ----------
    v: glm::ivec3 const &
    scalar: int

    __mul__(scalar, v) -> ivec3

    Parameters
    ----------
    scalar: int
    v: glm::ivec3 const &

    __mul__(v1, v2) -> ivec3

    Parameters
    ----------
    v1: glm::ivec3 const &
    v2: glm::ivec3 const &

    __mul__(v, scalar) -> ivec4

    Parameters
    ----------
    v: glm::ivec4 const &
    scalar: int

    __mul__(scalar, v) -> ivec4

    Parameters
    ----------
    scalar: int
    v: glm::ivec4 const &

    __mul__(v1, v2) -> ivec4

    Parameters
    ----------
    v1: glm::ivec4 const &
    v2: glm::ivec4 const &

    __mul__(v, scalar) -> vec2

    Parameters
    ----------
    v: glm::vec2 const &
    scalar: float

    __mul__(scalar, v) -> vec2

    Parameters
    ----------
    scalar: float
    v: glm::vec2 const &

    __mul__(v1, v2) -> vec2

    Parameters
    ----------
    v1: glm::vec2 const &
    v2: glm::vec2 const &

    __mul__(v, scalar) -> vec3

    Parameters
    ----------
    v: glm::vec3 const &
    scalar: float

    __mul__(scalar, v) -> vec3

    Parameters
    ----------
    scalar: float
    v: glm::vec3 const &

    __mul__(v1, v2) -> vec3

    Parameters
    ----------
    v1: glm::vec3 const &
    v2: glm::vec3 const &

    __mul__(v, scalar) -> vec4

    Parameters
    ----------
    v: glm::vec4 const &
    scalar: float

    __mul__(scalar, v) -> vec4

    Parameters
    ----------
    scalar: float
    v: glm::vec4 const &

    __mul__(v1, v2) -> vec4

    Parameters
    ----------
    v1: glm::vec4 const &
    v2: glm::vec4 const &

    __mul__(v, scalar) -> u16vec2

    Parameters
    ----------
    v: glm::u16vec2 const &
    scalar: uint16_t

    __mul__(scalar, v) -> u16vec2

    Parameters
    ----------
    scalar: uint16_t
    v: glm::u16vec2 const &

    __mul__(v1, v2) -> u16vec2

    Parameters
    ----------
    v1: glm::u16vec2 const &
    v2: glm::u16vec2 const &

    __mul__(v, scalar) -> u16vec3

    Parameters
    ----------
    v: glm::u16vec3 const &
    scalar: uint16_t

    __mul__(scalar, v) -> u16vec3

    Parameters
    ----------
    scalar: uint16_t
    v: glm::u16vec3 const &

    __mul__(v1, v2) -> u16vec3

    Parameters
    ----------
    v1: glm::u16vec3 const &
    v2: glm::u16vec3 const &

    __mul__(v, scalar) -> u16vec4

    Parameters
    ----------
    v: glm::u16vec4 const &
    scalar: uint16_t

    __mul__(scalar, v) -> u16vec4

    Parameters
    ----------
    scalar: uint16_t
    v: glm::u16vec4 const &

    __mul__(v1, v2) -> u16vec4

    Parameters
    ----------
    v1: glm::u16vec4 const &
    v2: glm::u16vec4 const &

    __mul__(m, scalar) -> mat3

    Parameters
    ----------
    m: glm::mat3 const &
    scalar: float

    __mul__(scalar, m) -> mat3

    Parameters
    ----------
    scalar: float
    m: glm::mat3 const &

    __mul__(m1, m2) -> mat3

    Parameters
    ----------
    m1: glm::mat3 const &
    m2: glm::mat3 const &

    __mul__(v, m) -> vec3

    Parameters
    ----------
    v: glm::vec3 const &
    m: glm::mat3 const &

    __mul__(m, v) -> vec3

    Parameters
    ----------
    m: glm::mat3 const &
    v: glm::vec3 const &

    __mul__(m, scalar) -> mat4

    Parameters
    ----------
    m: glm::mat4 const &
    scalar: float

    __mul__(scalar, v) -> mat4

    Parameters
    ----------
    scalar: float
    v: glm::mat4 const &

    __mul__(m1, m2) -> mat4

    Parameters
    ----------
    m1: glm::mat4 const &
    m2: glm::mat4 const &

    __mul__(m, v) -> vec4

    Parameters
    ----------
    m: glm::mat4 const &
    v: glm::vec4 const &

    __mul__(v, m) -> vec4

    Parameters
    ----------
    v: glm::vec4 const &
    m: glm::mat4 const &

    __mul__(q, p) -> quat

    Parameters
    ----------
    q: glm::quat const &
    p: glm::quat const &

    __mul__(q, v) -> vec3

    Parameters
    ----------
    q: glm::quat const &
    v: glm::vec3 const &

    __mul__(v, q) -> vec3

    Parameters
    ----------
    v: glm::vec3 const &
    q: glm::quat const &

    __mul__(q, v) -> vec4

    Parameters
    ----------
    q: glm::quat const &
    v: glm::vec4 const &

    __mul__(v, q) -> vec4

    Parameters
    ----------
    v: glm::vec4 const &
    q: glm::quat const &

    __mul__(q, s) -> quat

    Parameters
    ----------
    q: glm::quat const &
    s: float const &

    __mul__(s, q) -> quat

    Parameters
    ----------
    s: float const &
    q: glm::quat const &

    """
    return _nvisii.__mul__(*args)

def __truediv__(*args):
    r"""
    __truediv__(v, scalar) -> ivec2

    Parameters
    ----------
    v: glm::ivec2 const &
    scalar: int

    __truediv__(scalar, v) -> ivec2

    Parameters
    ----------
    scalar: int
    v: glm::ivec2 const &

    __truediv__(v1, v2) -> ivec2

    Parameters
    ----------
    v1: glm::ivec2 const &
    v2: glm::ivec2 const &

    __truediv__(v, scalar) -> ivec3

    Parameters
    ----------
    v: glm::ivec3 const &
    scalar: int

    __truediv__(scalar, v) -> ivec3

    Parameters
    ----------
    scalar: int
    v: glm::ivec3 const &

    __truediv__(v1, v2) -> ivec3

    Parameters
    ----------
    v1: glm::ivec3 const &
    v2: glm::ivec3 const &

    __truediv__(v, scalar) -> ivec4

    Parameters
    ----------
    v: glm::ivec4 const &
    scalar: int

    __truediv__(scalar, v) -> ivec4

    Parameters
    ----------
    scalar: int
    v: glm::ivec4 const &

    __truediv__(v1, v2) -> ivec4

    Parameters
    ----------
    v1: glm::ivec4 const &
    v2: glm::ivec4 const &

    __truediv__(v, scalar) -> vec2

    Parameters
    ----------
    v: glm::vec2 const &
    scalar: float

    __truediv__(scalar, v) -> vec2

    Parameters
    ----------
    scalar: float
    v: glm::vec2 const &

    __truediv__(v1, v2) -> vec2

    Parameters
    ----------
    v1: glm::vec2 const &
    v2: glm::vec2 const &

    __truediv__(v, scalar) -> vec3

    Parameters
    ----------
    v: glm::vec3 const &
    scalar: float

    __truediv__(scalar, v) -> vec3

    Parameters
    ----------
    scalar: float
    v: glm::vec3 const &

    __truediv__(v1, v2) -> vec3

    Parameters
    ----------
    v1: glm::vec3 const &
    v2: glm::vec3 const &

    __truediv__(v, scalar) -> vec4

    Parameters
    ----------
    v: glm::vec4 const &
    scalar: float

    __truediv__(scalar, v) -> vec4

    Parameters
    ----------
    scalar: float
    v: glm::vec4 const &

    __truediv__(v1, v2) -> vec4

    Parameters
    ----------
    v1: glm::vec4 const &
    v2: glm::vec4 const &

    __truediv__(v, scalar) -> u16vec2

    Parameters
    ----------
    v: glm::u16vec2 const &
    scalar: uint16_t

    __truediv__(scalar, v) -> u16vec2

    Parameters
    ----------
    scalar: uint16_t
    v: glm::u16vec2 const &

    __truediv__(v1, v2) -> u16vec2

    Parameters
    ----------
    v1: glm::u16vec2 const &
    v2: glm::u16vec2 const &

    __truediv__(v, scalar) -> u16vec3

    Parameters
    ----------
    v: glm::u16vec3 const &
    scalar: uint16_t

    __truediv__(scalar, v) -> u16vec3

    Parameters
    ----------
    scalar: uint16_t
    v: glm::u16vec3 const &

    __truediv__(v1, v2) -> u16vec3

    Parameters
    ----------
    v1: glm::u16vec3 const &
    v2: glm::u16vec3 const &

    __truediv__(v, scalar) -> u16vec4

    Parameters
    ----------
    v: glm::u16vec4 const &
    scalar: uint16_t

    __truediv__(scalar, v) -> u16vec4

    Parameters
    ----------
    scalar: uint16_t
    v: glm::u16vec4 const &

    __truediv__(v1, v2) -> u16vec4

    Parameters
    ----------
    v1: glm::u16vec4 const &
    v2: glm::u16vec4 const &

    __truediv__(m, scalar) -> mat3

    Parameters
    ----------
    m: glm::mat3 const &
    scalar: float

    __truediv__(scalar, m) -> mat3

    Parameters
    ----------
    scalar: float
    m: glm::mat3 const &

    __truediv__(m1, m2) -> mat3

    Parameters
    ----------
    m1: glm::mat3 const &
    m2: glm::mat3 const &

    __truediv__(m, v) -> vec3

    Parameters
    ----------
    m: glm::mat3 const &
    v: glm::vec3 const &

    __truediv__(v, m) -> vec3

    Parameters
    ----------
    v: glm::vec3 const &
    m: glm::mat3 const &

    __truediv__(m, scalar) -> mat4

    Parameters
    ----------
    m: glm::mat4 const &
    scalar: float

    __truediv__(scalar, m) -> mat4

    Parameters
    ----------
    scalar: float
    m: glm::mat4 const &

    __truediv__(m1, m2) -> mat4

    Parameters
    ----------
    m1: glm::mat4 const &
    m2: glm::mat4 const &

    __truediv__(m, v) -> vec4

    Parameters
    ----------
    m: glm::mat4 const &
    v: glm::vec4 const &

    __truediv__(v, m) -> vec4

    Parameters
    ----------
    v: glm::vec4 const &
    m: glm::mat4 const &

    __truediv__(q, s) -> quat

    Parameters
    ----------
    q: glm::quat const &
    s: float const &

    """
    return _nvisii.__truediv__(*args)

def __eq__(*args):
    r"""
    __eq__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::ivec2 const &
    v2: glm::ivec2 const &

    __eq__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::ivec3 const &
    v2: glm::ivec3 const &

    __eq__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::ivec4 const &
    v2: glm::ivec4 const &

    __eq__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::vec2 const &
    v2: glm::vec2 const &

    __eq__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::vec3 const &
    v2: glm::vec3 const &

    __eq__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::vec4 const &
    v2: glm::vec4 const &

    __eq__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::u16vec2 const &
    v2: glm::u16vec2 const &

    __eq__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::u16vec3 const &
    v2: glm::u16vec3 const &

    __eq__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::u16vec4 const &
    v2: glm::u16vec4 const &

    __eq__(m1, m2) -> bool

    Parameters
    ----------
    m1: glm::mat3 const &
    m2: glm::mat3 const &

    __eq__(m1, m2) -> bool

    Parameters
    ----------
    m1: glm::mat4 const &
    m2: glm::mat4 const &

    __eq__(q1, q2) -> bool

    Parameters
    ----------
    q1: glm::quat const &
    q2: glm::quat const &

    """
    return _nvisii.__eq__(*args)

def __ne__(*args):
    r"""
    __ne__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::ivec2 const &
    v2: glm::ivec2 const &

    __ne__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::ivec3 const &
    v2: glm::ivec3 const &

    __ne__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::ivec4 const &
    v2: glm::ivec4 const &

    __ne__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::vec2 const &
    v2: glm::vec2 const &

    __ne__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::vec3 const &
    v2: glm::vec3 const &

    __ne__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::vec4 const &
    v2: glm::vec4 const &

    __ne__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::u16vec2 const &
    v2: glm::u16vec2 const &

    __ne__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::u16vec3 const &
    v2: glm::u16vec3 const &

    __ne__(v1, v2) -> bool

    Parameters
    ----------
    v1: glm::u16vec4 const &
    v2: glm::u16vec4 const &

    __ne__(m1, m2) -> bool

    Parameters
    ----------
    m1: glm::mat3 const &
    m2: glm::mat3 const &

    __ne__(m1, m2) -> bool

    Parameters
    ----------
    m1: glm::mat4 const &
    m2: glm::mat4 const &

    __ne__(q1, q2) -> bool

    Parameters
    ----------
    q1: glm::quat const &
    q2: glm::quat const &

    """
    return _nvisii.__ne__(*args)

def conjugate(q):
    r"""
    conjugate(q) -> quat

    Parameters
    ----------
    q: glm::quat const &

    """
    return _nvisii.conjugate(q)

def eulerAngles(x):
    r"""
    eulerAngles(x) -> vec3

    Parameters
    ----------
    x: glm::quat const &

    """
    return _nvisii.eulerAngles(x)

def roll(x):
    r"""
    roll(x) -> float

    Parameters
    ----------
    x: glm::quat const &

    """
    return _nvisii.roll(x)

def pitch(x):
    r"""
    pitch(x) -> float

    Parameters
    ----------
    x: glm::quat const &

    """
    return _nvisii.pitch(x)

def yaw(x):
    r"""
    yaw(x) -> float

    Parameters
    ----------
    x: glm::quat const &

    """
    return _nvisii.yaw(x)

def mat3_cast(x):
    r"""
    mat3_cast(x) -> mat3

    Parameters
    ----------
    x: glm::quat const &

    """
    return _nvisii.mat3_cast(x)

def mat4_cast(x):
    r"""
    mat4_cast(x) -> mat4

    Parameters
    ----------
    x: glm::quat const &

    """
    return _nvisii.mat4_cast(x)

def quat_cast(*args):
    r"""
    quat_cast(x) -> quat

    Parameters
    ----------
    x: glm::mat3 const &

    quat_cast(x) -> quat

    Parameters
    ----------
    x: glm::mat4 const &

    """
    return _nvisii.quat_cast(*args)

def axis(x):
    r"""
    axis(x) -> vec3

    Parameters
    ----------
    x: glm::quat const &

    """
    return _nvisii.axis(x)

def angleAxis(angle, axis):
    r"""
    angleAxis(angle, axis) -> quat

    Parameters
    ----------
    angle: float const &
    axis: glm::vec3 const &

    """
    return _nvisii.angleAxis(angle, axis)

def epsilon():
    r"""epsilon() -> float"""
    return _nvisii.epsilon()

def zero():
    r"""zero() -> float"""
    return _nvisii.zero()

def one():
    r"""one() -> float"""
    return _nvisii.one()

def pi():
    r"""pi() -> float"""
    return _nvisii.pi()

def root_pi():
    r"""root_pi() -> float"""
    return _nvisii.root_pi()

def half_pi():
    r"""half_pi() -> float"""
    return _nvisii.half_pi()

def quarter_pi():
    r"""quarter_pi() -> float"""
    return _nvisii.quarter_pi()

def one_over_pi():
    r"""one_over_pi() -> float"""
    return _nvisii.one_over_pi()

def two_over_pi():
    r"""two_over_pi() -> float"""
    return _nvisii.two_over_pi()

def two_over_root_pi():
    r"""two_over_root_pi() -> float"""
    return _nvisii.two_over_root_pi()

def one_over_root_two():
    r"""one_over_root_two() -> float"""
    return _nvisii.one_over_root_two()

def root_half_pi():
    r"""root_half_pi() -> float"""
    return _nvisii.root_half_pi()

def root_two_pi():
    r"""root_two_pi() -> float"""
    return _nvisii.root_two_pi()

def root_ln_four():
    r"""root_ln_four() -> float"""
    return _nvisii.root_ln_four()

def e():
    r"""e() -> float"""
    return _nvisii.e()

def euler():
    r"""euler() -> float"""
    return _nvisii.euler()

def root_two():
    r"""root_two() -> float"""
    return _nvisii.root_two()

def root_three():
    r"""root_three() -> float"""
    return _nvisii.root_three()

def root_five():
    r"""root_five() -> float"""
    return _nvisii.root_five()

def ln_two():
    r"""ln_two() -> float"""
    return _nvisii.ln_two()

def ln_ten():
    r"""ln_ten() -> float"""
    return _nvisii.ln_ten()

def ln_ln_two():
    r"""ln_ln_two() -> float"""
    return _nvisii.ln_ln_two()

def third():
    r"""third() -> float"""
    return _nvisii.third()

def two_thirds():
    r"""two_thirds() -> float"""
    return _nvisii.two_thirds()

def golden_ratio():
    r"""golden_ratio() -> float"""
    return _nvisii.golden_ratio()

def abs(*args):
    r"""
    abs(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    abs(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    abs(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    abs(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.abs(*args)

def sign(*args):
    r"""
    sign(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    sign(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    sign(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    sign(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.sign(*args)

def floor(*args):
    r"""
    floor(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    floor(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    floor(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    floor(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.floor(*args)

def trunc(*args):
    r"""
    trunc(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    trunc(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    trunc(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    trunc(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.trunc(*args)

def round(*args):
    r"""
    round(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    round(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    round(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    round(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.round(*args)

def roundEven(*args):
    r"""
    roundEven(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    roundEven(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    roundEven(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    roundEven(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.roundEven(*args)

def ceil(*args):
    r"""
    ceil(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    ceil(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    ceil(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    ceil(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.ceil(*args)

def fract(*args):
    r"""
    fract(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    fract(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    fract(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    fract(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.fract(*args)

def mod(*args):
    r"""
    mod(arg1, arg2) -> float

    Parameters
    ----------
    arg1: float const &
    arg2: float const &

    mod(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    mod(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    mod(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    mod(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: float const &

    mod(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: float const &

    mod(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: float const &

    """
    return _nvisii.mod(*args)

def modf(*args):
    r"""
    modf(arg1, arg2) -> float

    Parameters
    ----------
    arg1: float const &
    arg2: float &

    modf(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 &

    modf(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 &

    modf(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 &

    """
    return _nvisii.modf(*args)

def min(*args):
    r"""
    min(arg1, arg2) -> float

    Parameters
    ----------
    arg1: float const &
    arg2: float const &

    min(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    min(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    min(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    min(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: float const &

    min(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: float const &

    min(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: float const &

    """
    return _nvisii.min(*args)

def max(*args):
    r"""
    max(arg1, arg2) -> float

    Parameters
    ----------
    arg1: float const &
    arg2: float const &

    max(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    max(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    max(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    max(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: float const &

    max(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: float const &

    max(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: float const &

    """
    return _nvisii.max(*args)

def clamp(*args):
    r"""
    clamp(arg1, arg2, arg3) -> float

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: float const &

    clamp(arg1, arg2, arg3) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: glm::vec2 const &

    clamp(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: glm::vec3 const &

    clamp(arg1, arg2, arg3) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &
    arg3: glm::vec4 const &

    clamp(arg1, arg2, arg3) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: float const &
    arg3: float const &

    clamp(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: float const &
    arg3: float const &

    clamp(arg1, arg2, arg3) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: float const &
    arg3: float const &

    """
    return _nvisii.clamp(*args)

def mix(*args):
    r"""
    mix(x, y, a) -> quat

    Parameters
    ----------
    x: glm::quat const &
    y: glm::quat const &
    a: float

    mix(arg1, arg2, arg3) -> float

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: float const &

    mix(arg1, arg2, arg3) -> float

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: bool const &

    mix(arg1, arg2, arg3) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: glm::vec2 const &

    mix(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: glm::vec3 const &

    mix(arg1, arg2, arg3) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &
    arg3: glm::vec4 const &

    mix(arg1, arg2, arg3) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: bool const &

    mix(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: bool const &

    mix(arg1, arg2, arg3) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &
    arg3: bool const &

    """
    return _nvisii.mix(*args)

def step(*args):
    r"""
    step(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    step(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    step(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    step(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: float const &
    arg2: glm::vec2 const &

    step(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: float const &
    arg2: glm::vec3 const &

    step(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: float const &
    arg2: glm::vec4 const &

    """
    return _nvisii.step(*args)

def smoothstep(*args):
    r"""
    smoothstep(arg1, arg2, arg3) -> float

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: float const &

    smoothstep(arg1, arg2, arg3) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: glm::vec2 const &

    smoothstep(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: glm::vec3 const &

    smoothstep(arg1, arg2, arg3) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &
    arg3: glm::vec4 const &

    smoothstep(arg1, arg2, arg3) -> vec2

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: glm::vec2 const &

    smoothstep(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: glm::vec3 const &

    smoothstep(arg1, arg2, arg3) -> vec4

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: glm::vec4 const &

    """
    return _nvisii.smoothstep(*args)

def isnan(arg1):
    r"""
    isnan(arg1) -> bool

    Parameters
    ----------
    arg1: float const &

    """
    return _nvisii.isnan(arg1)

def isinf(arg1):
    r"""
    isinf(arg1) -> bool

    Parameters
    ----------
    arg1: float const &

    """
    return _nvisii.isinf(arg1)

def pow(*args):
    r"""
    pow(arg1, arg2) -> float

    Parameters
    ----------
    arg1: float const &
    arg2: float const &

    pow(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    pow(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    pow(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    """
    return _nvisii.pow(*args)

def exp(*args):
    r"""
    exp(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    exp(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    exp(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    exp(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.exp(*args)

def log(*args):
    r"""
    log(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    log(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    log(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    log(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.log(*args)

def exp2(*args):
    r"""
    exp2(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    exp2(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    exp2(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    exp2(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.exp2(*args)

def log2(*args):
    r"""
    log2(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    log2(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    log2(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    log2(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.log2(*args)

def sqrt(*args):
    r"""
    sqrt(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    sqrt(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    sqrt(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.sqrt(*args)

def inversesqrt(*args):
    r"""
    inversesqrt(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    inversesqrt(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    inversesqrt(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    inversesqrt(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.inversesqrt(*args)

def length(*args):
    r"""
    length(q) -> float

    Parameters
    ----------
    q: glm::quat const &

    length(arg1) -> float

    Parameters
    ----------
    arg1: glm::vec2 const &

    length(arg1) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &

    length(arg1) -> float

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.length(*args)

def distance(*args):
    r"""
    distance(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    distance(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    distance(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    """
    return _nvisii.distance(*args)

def dot(*args):
    r"""
    dot(x, y) -> float

    Parameters
    ----------
    x: glm::quat const &
    y: glm::quat const &

    dot(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    dot(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    dot(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    """
    return _nvisii.dot(*args)

def cross(arg1, arg2):
    r"""
    cross(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    """
    return _nvisii.cross(arg1, arg2)

def normalize(*args):
    r"""
    normalize(q) -> quat

    Parameters
    ----------
    q: glm::quat const &

    normalize(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    normalize(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    normalize(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.normalize(*args)

def faceforward(*args):
    r"""
    faceforward(arg1, arg2, arg3) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: glm::vec2 const &

    faceforward(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: glm::vec3 const &

    faceforward(arg1, arg2, arg3) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &
    arg3: glm::vec4 const &

    """
    return _nvisii.faceforward(*args)

def reflect(*args):
    r"""
    reflect(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    reflect(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    reflect(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    """
    return _nvisii.reflect(*args)

def refract(*args):
    r"""
    refract(arg1, arg2, arg3) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: float const &

    refract(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: float const &

    refract(arg1, arg2, arg3) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &
    arg3: float const &

    """
    return _nvisii.refract(*args)

def matrixCompMult(*args):
    r"""
    matrixCompMult(arg1, arg2) -> mat3

    Parameters
    ----------
    arg1: glm::mat3 const &
    arg2: glm::mat3 const &

    matrixCompMult(arg1, arg2) -> mat4

    Parameters
    ----------
    arg1: glm::mat4 const &
    arg2: glm::mat4 const &

    """
    return _nvisii.matrixCompMult(*args)

def outerProduct(*args):
    r"""
    outerProduct(arg1, arg2) -> mat3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    outerProduct(arg1, arg2) -> mat4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    """
    return _nvisii.outerProduct(*args)

def transpose(*args):
    r"""
    transpose(arg1) -> mat3

    Parameters
    ----------
    arg1: glm::mat3 const &

    transpose(arg1) -> mat4

    Parameters
    ----------
    arg1: glm::mat4 const &

    """
    return _nvisii.transpose(*args)

def determinant(*args):
    r"""
    determinant(arg1) -> float

    Parameters
    ----------
    arg1: glm::mat3 const &

    determinant(arg1) -> float

    Parameters
    ----------
    arg1: glm::mat4 const &

    """
    return _nvisii.determinant(*args)

def inverse(*args):
    r"""
    inverse(q) -> quat

    Parameters
    ----------
    q: glm::quat const &

    inverse(arg1) -> mat3

    Parameters
    ----------
    arg1: glm::mat3 const &

    inverse(arg1) -> mat4

    Parameters
    ----------
    arg1: glm::mat4 const &

    """
    return _nvisii.inverse(*args)

def radians(*args):
    r"""
    radians(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    radians(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    radians(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    radians(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.radians(*args)

def degrees(*args):
    r"""
    degrees(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    degrees(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    degrees(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    degrees(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.degrees(*args)

def sin(*args):
    r"""
    sin(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    sin(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    sin(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    sin(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.sin(*args)

def cos(*args):
    r"""
    cos(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    cos(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    cos(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    cos(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.cos(*args)

def tan(*args):
    r"""
    tan(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    tan(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    tan(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    tan(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.tan(*args)

def asin(*args):
    r"""
    asin(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    asin(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    asin(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    asin(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.asin(*args)

def acos(*args):
    r"""
    acos(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    acos(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    acos(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    acos(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.acos(*args)

def atan(*args):
    r"""
    atan(arg1, arg2) -> float

    Parameters
    ----------
    arg1: float const &
    arg2: float const &

    atan(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    atan(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    atan(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    atan(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    atan(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    atan(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    atan(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.atan(*args)

def sinh(*args):
    r"""
    sinh(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    sinh(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    sinh(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    sinh(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.sinh(*args)

def cosh(*args):
    r"""
    cosh(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    cosh(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    cosh(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    cosh(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.cosh(*args)

def tanh(*args):
    r"""
    tanh(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    tanh(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    tanh(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    tanh(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.tanh(*args)

def asinh(*args):
    r"""
    asinh(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    asinh(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    asinh(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    asinh(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.asinh(*args)

def acosh(*args):
    r"""
    acosh(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    acosh(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    acosh(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    acosh(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.acosh(*args)

def atanh(*args):
    r"""
    atanh(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    atanh(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    atanh(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    atanh(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.atanh(*args)

def epsilonEqual(*args):
    r"""
    epsilonEqual(arg1, arg2, arg3) -> bool

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: float const &

    epsilonEqual(arg1, arg2, arg3) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: float const &

    epsilonEqual(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: float const &

    """
    return _nvisii.epsilonEqual(*args)

def epsilonNotEqual(*args):
    r"""
    epsilonNotEqual(arg1, arg2, arg3) -> bool

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: float const &

    epsilonNotEqual(arg1, arg2, arg3) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: float const &

    epsilonNotEqual(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: float const &

    """
    return _nvisii.epsilonNotEqual(*args)

def row(*args):
    r"""
    row(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::mat3 const &
    arg2: glm::length_t const &

    row(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::mat4 const &
    arg2: glm::length_t const &

    row(arg1, arg2, arg3) -> mat3

    Parameters
    ----------
    arg1: glm::mat3 const &
    arg2: glm::length_t const &
    arg3: glm::vec3 const &

    row(arg1, arg2, arg3) -> mat4

    Parameters
    ----------
    arg1: glm::mat4 const &
    arg2: glm::length_t const &
    arg3: glm::vec4 const &

    """
    return _nvisii.row(*args)

def column(*args):
    r"""
    column(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::mat3 const &
    arg2: glm::length_t const &

    column(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::mat4 const &
    arg2: glm::length_t const &

    column(arg1, arg2, arg3) -> mat3

    Parameters
    ----------
    arg1: glm::mat3 const &
    arg2: glm::length_t const &
    arg3: glm::vec3 const &

    column(arg1, arg2, arg3) -> mat4

    Parameters
    ----------
    arg1: glm::mat4 const &
    arg2: glm::length_t const &
    arg3: glm::vec4 const &

    """
    return _nvisii.column(*args)

def affineInverse(*args):
    r"""
    affineInverse(arg1) -> mat3

    Parameters
    ----------
    arg1: glm::mat3 const &

    affineInverse(arg1) -> mat4

    Parameters
    ----------
    arg1: glm::mat4 const &

    """
    return _nvisii.affineInverse(*args)

def inverseTranspose(*args):
    r"""
    inverseTranspose(arg1) -> mat3

    Parameters
    ----------
    arg1: glm::mat3 const &

    inverseTranspose(arg1) -> mat4

    Parameters
    ----------
    arg1: glm::mat4 const &

    """
    return _nvisii.inverseTranspose(*args)

def ortho(*args):
    r"""
    ortho(arg1, arg2, arg3, arg4) -> mat4

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: float const &
    arg4: float const &

    ortho(arg1, arg2, arg3, arg4, arg5, arg6) -> mat4

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: float const &
    arg4: float const &
    arg5: float const &
    arg6: float const &

    """
    return _nvisii.ortho(*args)

def frustum(arg1, arg2, arg3, arg4, arg5, arg6):
    r"""
    frustum(arg1, arg2, arg3, arg4, arg5, arg6) -> mat4

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: float const &
    arg4: float const &
    arg5: float const &
    arg6: float const &

    """
    return _nvisii.frustum(arg1, arg2, arg3, arg4, arg5, arg6)

def perspective(arg1, arg2, arg3, arg4):
    r"""
    perspective(arg1, arg2, arg3, arg4) -> mat4

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: float const &
    arg4: float const &

    """
    return _nvisii.perspective(arg1, arg2, arg3, arg4)

def perspectiveFov(arg1, arg2, arg3, arg4, arg5):
    r"""
    perspectiveFov(arg1, arg2, arg3, arg4, arg5) -> mat4

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: float const &
    arg4: float const &
    arg5: float const &

    """
    return _nvisii.perspectiveFov(arg1, arg2, arg3, arg4, arg5)

def infinitePerspective(arg1, arg2, arg3):
    r"""
    infinitePerspective(arg1, arg2, arg3) -> mat4

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: float const &

    """
    return _nvisii.infinitePerspective(arg1, arg2, arg3)

def tweakedInfinitePerspective(arg1, arg2, arg3):
    r"""
    tweakedInfinitePerspective(arg1, arg2, arg3) -> mat4

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: float const &

    """
    return _nvisii.tweakedInfinitePerspective(arg1, arg2, arg3)

def project(arg1, arg2, arg3, arg4):
    r"""
    project(arg1, arg2, arg3, arg4) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::mat4 const &
    arg3: glm::mat4 const &
    arg4: glm::vec4 const &

    """
    return _nvisii.project(arg1, arg2, arg3, arg4)

def unProject(arg1, arg2, arg3, arg4):
    r"""
    unProject(arg1, arg2, arg3, arg4) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::mat4 const &
    arg3: glm::mat4 const &
    arg4: glm::vec4 const &

    """
    return _nvisii.unProject(arg1, arg2, arg3, arg4)

def pickMatrix(arg1, arg2, arg3):
    r"""
    pickMatrix(arg1, arg2, arg3) -> mat4

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: glm::vec4 const &

    """
    return _nvisii.pickMatrix(arg1, arg2, arg3)

def lookAt(arg1, arg2, arg3):
    r"""
    lookAt(arg1, arg2, arg3) -> mat4

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: glm::vec3 const &

    """
    return _nvisii.lookAt(arg1, arg2, arg3)

def atan2(*args):
    r"""
    atan2(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    atan2(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    atan2(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    """
    return _nvisii.atan2(*args)

def isfinite(*args):
    r"""
    isfinite(arg1) -> bool

    Parameters
    ----------
    arg1: float &

    isfinite(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 &

    isfinite(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 &

    isfinite(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 &

    """
    return _nvisii.isfinite(*args)

def lerp(*args):
    r"""
    lerp(x, y, a) -> quat

    Parameters
    ----------
    x: glm::quat const &
    y: glm::quat const &
    a: float

    lerp(arg1, arg2, arg3) -> float

    Parameters
    ----------
    arg1: float const &
    arg2: float const &
    arg3: float const &

    lerp(arg1, arg2, arg3) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: glm::vec2 const &

    lerp(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: glm::vec3 const &

    lerp(arg1, arg2, arg3) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &
    arg3: glm::vec4 const &

    lerp(arg1, arg2, arg3) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: float const &

    lerp(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: float const &

    lerp(arg1, arg2, arg3) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &
    arg3: float const &

    """
    return _nvisii.lerp(*args)

def saturate(*args):
    r"""
    saturate(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    saturate(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    saturate(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.saturate(*args)

def fastSqrt(*args):
    r"""
    fastSqrt(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    fastSqrt(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    fastSqrt(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.fastSqrt(*args)

def fastInverseSqrt(*args):
    r"""
    fastInverseSqrt(arg1) -> float

    Parameters
    ----------
    arg1: float const &

    fastInverseSqrt(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    fastInverseSqrt(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    fastInverseSqrt(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.fastInverseSqrt(*args)

def fastLength(*args):
    r"""
    fastLength(arg1) -> float

    Parameters
    ----------
    arg1: glm::vec2 const &

    fastLength(arg1) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &

    fastLength(arg1) -> float

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.fastLength(*args)

def fastDistance(*args):
    r"""
    fastDistance(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    fastDistance(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    fastDistance(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    """
    return _nvisii.fastDistance(*args)

def fastNormalize(*args):
    r"""
    fastNormalize(arg1) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &

    fastNormalize(arg1) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &

    fastNormalize(arg1) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.fastNormalize(*args)

def length2(*args):
    r"""
    length2(arg1) -> float

    Parameters
    ----------
    arg1: glm::vec2 const &

    length2(arg1) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &

    length2(arg1) -> float

    Parameters
    ----------
    arg1: glm::vec4 const &

    """
    return _nvisii.length2(*args)

def distance2(*args):
    r"""
    distance2(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    distance2(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    distance2(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    """
    return _nvisii.distance2(*args)

def l1Norm(*args):
    r"""
    l1Norm(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    l1Norm(arg1) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &

    """
    return _nvisii.l1Norm(*args)

def l2Norm(*args):
    r"""
    l2Norm(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    l2Norm(arg1) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &

    """
    return _nvisii.l2Norm(*args)

def lxNorm(*args):
    r"""
    lxNorm(arg1, arg2, arg3) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: unsigned int

    lxNorm(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: unsigned int

    """
    return _nvisii.lxNorm(*args)

def perp(*args):
    r"""
    perp(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    perp(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    """
    return _nvisii.perp(*args)

def orientation(arg1, arg2):
    r"""
    orientation(arg1, arg2) -> mat4

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    """
    return _nvisii.orientation(arg1, arg2)

def rotateX(*args):
    r"""
    rotateX(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: float const &

    rotateX(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: float const &

    """
    return _nvisii.rotateX(*args)

def rotateY(*args):
    r"""
    rotateY(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: float const &

    rotateY(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: float const &

    """
    return _nvisii.rotateY(*args)

def rotateZ(*args):
    r"""
    rotateZ(arg1, arg2) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: float const &

    rotateZ(arg1, arg2) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: float const &

    """
    return _nvisii.rotateZ(*args)

def slerp(*args):
    r"""
    slerp(x, y, a) -> quat

    Parameters
    ----------
    x: glm::quat const &
    y: glm::quat const &
    a: float

    slerp(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: float const &

    """
    return _nvisii.slerp(*args)

def catmullRom(*args):
    r"""
    catmullRom(arg1, arg2, arg3, arg4, arg5) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: glm::vec2 const &
    arg4: glm::vec2 const &
    arg5: float const &

    catmullRom(arg1, arg2, arg3, arg4, arg5) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: glm::vec3 const &
    arg4: glm::vec3 const &
    arg5: float const &

    """
    return _nvisii.catmullRom(*args)

def cubic(*args):
    r"""
    cubic(arg1, arg2, arg3, arg4, arg5) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: glm::vec2 const &
    arg4: glm::vec2 const &
    arg5: float const &

    cubic(arg1, arg2, arg3, arg4, arg5) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: glm::vec3 const &
    arg4: glm::vec3 const &
    arg5: float const &

    """
    return _nvisii.cubic(*args)

def hermite(*args):
    r"""
    hermite(arg1, arg2, arg3, arg4, arg5) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &
    arg3: glm::vec2 const &
    arg4: glm::vec2 const &
    arg5: float const &

    hermite(arg1, arg2, arg3, arg4, arg5) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: glm::vec3 const &
    arg4: glm::vec3 const &
    arg5: float const &

    """
    return _nvisii.hermite(*args)

def rotate(*args):
    r"""
    rotate(q, angle, axis) -> quat

    Parameters
    ----------
    q: glm::quat const &
    angle: float const &
    axis: glm::vec3 const &

    rotate(arg1, arg2, arg3) -> mat4

    Parameters
    ----------
    arg1: glm::mat4 const &
    arg2: float const &
    arg3: glm::vec3 const &

    rotate(arg1, arg2) -> vec2

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: float const &

    rotate(arg1, arg2, arg3) -> vec3

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: float const &
    arg3: glm::vec3 const &

    rotate(arg1, arg2, arg3) -> vec4

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: float const &
    arg3: glm::vec3 const &

    rotate(angle, arg2) -> mat4

    Parameters
    ----------
    angle: float
    arg2: glm::vec3 const &

    """
    return _nvisii.rotate(*args)

def scale(*args):
    r"""
    scale(arg1, arg2) -> mat4

    Parameters
    ----------
    arg1: glm::mat4 const &
    arg2: glm::vec3 const &

    scale(arg1) -> mat4

    Parameters
    ----------
    arg1: glm::vec3 const &

    """
    return _nvisii.scale(*args)

def translate(*args):
    r"""
    translate(arg1, arg2) -> mat4

    Parameters
    ----------
    arg1: glm::mat4 const &
    arg2: glm::vec3 const &

    translate(arg1) -> mat4

    Parameters
    ----------
    arg1: glm::vec3 const &

    """
    return _nvisii.translate(*args)

def angle(*args):
    r"""
    angle(x) -> float

    Parameters
    ----------
    x: glm::quat const &

    angle(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    angle(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &

    angle(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec4 const &
    arg2: glm::vec4 const &

    """
    return _nvisii.angle(*args)

def orientedAngle(*args):
    r"""
    orientedAngle(arg1, arg2) -> float

    Parameters
    ----------
    arg1: glm::vec2 const &
    arg2: glm::vec2 const &

    orientedAngle(arg1, arg2, arg3) -> float

    Parameters
    ----------
    arg1: glm::vec3 const &
    arg2: glm::vec3 const &
    arg3: glm::vec3 const &

    """
    return _nvisii.orientedAngle(*args)
class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _nvisii.delete_SwigPyIterator

    def value(self):
        r"""value(self) -> PyObject *"""
        return _nvisii.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""
        incr(self, n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _nvisii.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""
        decr(self, n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _nvisii.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""
        distance(self, x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _nvisii.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""
        equal(self, x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _nvisii.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(self) -> SwigPyIterator"""
        return _nvisii.SwigPyIterator_copy(self)

    def next(self):
        r"""next(self) -> PyObject *"""
        return _nvisii.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(self) -> PyObject *"""
        return _nvisii.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(self) -> PyObject *"""
        return _nvisii.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""
        advance(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _nvisii.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""
        __eq__(self, x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _nvisii.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""
        __ne__(self, x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _nvisii.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""
        __iadd__(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _nvisii.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""
        __isub__(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _nvisii.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""
        __add__(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _nvisii.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        __sub__(self, x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _nvisii.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _nvisii:
_nvisii.SwigPyIterator_swigregister(SwigPyIterator)

class Vec2Vector(object):
    r"""Proxy of C++ std::vector< glm::vec2 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.Vec2Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.Vec2Vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.Vec2Vector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< glm::vec2 >::size_type"""
        return _nvisii.Vec2Vector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> Vec2Vector

        Parameters
        ----------
        i: std::vector< glm::vec2 >::difference_type
        j: std::vector< glm::vec2 >::difference_type

        """
        return _nvisii.Vec2Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::vec2 >::difference_type
        j: std::vector< glm::vec2 >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< glm::vec2 >::difference_type
        j: std::vector< glm::vec2 >::difference_type
        v: std::vector< glm::vec2,std::allocator< glm::vec2 > > const &

        """
        return _nvisii.Vec2Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::vec2 >::difference_type
        j: std::vector< glm::vec2 >::difference_type

        """
        return _nvisii.Vec2Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< glm::vec2 >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.Vec2Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> Vec2Vector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> vec2

        Parameters
        ----------
        i: std::vector< glm::vec2 >::difference_type

        """
        return _nvisii.Vec2Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< glm::vec2,std::allocator< glm::vec2 > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< glm::vec2 >::difference_type
        x: std::vector< glm::vec2 >::value_type const &

        """
        return _nvisii.Vec2Vector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> vec2"""
        return _nvisii.Vec2Vector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< glm::vec2 >::value_type const &

        """
        return _nvisii.Vec2Vector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.Vec2Vector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< glm::vec2 >::size_type"""
        return _nvisii.Vec2Vector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< glm::vec2 > &

        """
        return _nvisii.Vec2Vector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< glm::vec2 >::iterator"""
        return _nvisii.Vec2Vector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< glm::vec2 >::iterator"""
        return _nvisii.Vec2Vector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< glm::vec2 >::reverse_iterator"""
        return _nvisii.Vec2Vector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< glm::vec2 >::reverse_iterator"""
        return _nvisii.Vec2Vector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.Vec2Vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< glm::vec2 >::allocator_type"""
        return _nvisii.Vec2Vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.Vec2Vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< glm::vec2 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::vec2 >::iterator

        erase(self, first, last) -> std::vector< glm::vec2 >::iterator

        Parameters
        ----------
        first: std::vector< glm::vec2 >::iterator
        last: std::vector< glm::vec2 >::iterator

        """
        return _nvisii.Vec2Vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> Vec2Vector
        __init__(self, other) -> Vec2Vector

        Parameters
        ----------
        other: std::vector< glm::vec2 > const &

        __init__(self, size) -> Vec2Vector

        Parameters
        ----------
        size: std::vector< glm::vec2 >::size_type

        __init__(self, size, value) -> Vec2Vector

        Parameters
        ----------
        size: std::vector< glm::vec2 >::size_type
        value: std::vector< glm::vec2 >::value_type const &

        """
        _nvisii.Vec2Vector_swiginit(self, _nvisii.new_Vec2Vector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< glm::vec2 >::value_type const &

        """
        return _nvisii.Vec2Vector_push_back(self, x)

    def front(self):
        r"""front(self) -> vec2"""
        return _nvisii.Vec2Vector_front(self)

    def back(self):
        r"""back(self) -> vec2"""
        return _nvisii.Vec2Vector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< glm::vec2 >::size_type
        x: std::vector< glm::vec2 >::value_type const &

        """
        return _nvisii.Vec2Vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< glm::vec2 >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< glm::vec2 >::size_type
        x: std::vector< glm::vec2 >::value_type const &

        """
        return _nvisii.Vec2Vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< glm::vec2 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::vec2 >::iterator
        x: std::vector< glm::vec2 >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< glm::vec2 >::iterator
        n: std::vector< glm::vec2 >::size_type
        x: std::vector< glm::vec2 >::value_type const &

        """
        return _nvisii.Vec2Vector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< glm::vec2 >::size_type

        """
        return _nvisii.Vec2Vector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< glm::vec2 >::size_type"""
        return _nvisii.Vec2Vector_capacity(self)
    __swig_destroy__ = _nvisii.delete_Vec2Vector

# Register Vec2Vector in _nvisii:
_nvisii.Vec2Vector_swigregister(Vec2Vector)

class Vec4Vector(object):
    r"""Proxy of C++ std::vector< glm::vec4 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.Vec4Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.Vec4Vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.Vec4Vector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< glm::vec4 >::size_type"""
        return _nvisii.Vec4Vector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> Vec4Vector

        Parameters
        ----------
        i: std::vector< glm::vec4 >::difference_type
        j: std::vector< glm::vec4 >::difference_type

        """
        return _nvisii.Vec4Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::vec4 >::difference_type
        j: std::vector< glm::vec4 >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< glm::vec4 >::difference_type
        j: std::vector< glm::vec4 >::difference_type
        v: std::vector< glm::vec4,std::allocator< glm::vec4 > > const &

        """
        return _nvisii.Vec4Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::vec4 >::difference_type
        j: std::vector< glm::vec4 >::difference_type

        """
        return _nvisii.Vec4Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< glm::vec4 >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.Vec4Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> Vec4Vector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> vec4

        Parameters
        ----------
        i: std::vector< glm::vec4 >::difference_type

        """
        return _nvisii.Vec4Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< glm::vec4,std::allocator< glm::vec4 > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< glm::vec4 >::difference_type
        x: std::vector< glm::vec4 >::value_type const &

        """
        return _nvisii.Vec4Vector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> vec4"""
        return _nvisii.Vec4Vector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< glm::vec4 >::value_type const &

        """
        return _nvisii.Vec4Vector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.Vec4Vector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< glm::vec4 >::size_type"""
        return _nvisii.Vec4Vector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< glm::vec4 > &

        """
        return _nvisii.Vec4Vector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< glm::vec4 >::iterator"""
        return _nvisii.Vec4Vector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< glm::vec4 >::iterator"""
        return _nvisii.Vec4Vector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< glm::vec4 >::reverse_iterator"""
        return _nvisii.Vec4Vector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< glm::vec4 >::reverse_iterator"""
        return _nvisii.Vec4Vector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.Vec4Vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< glm::vec4 >::allocator_type"""
        return _nvisii.Vec4Vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.Vec4Vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< glm::vec4 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::vec4 >::iterator

        erase(self, first, last) -> std::vector< glm::vec4 >::iterator

        Parameters
        ----------
        first: std::vector< glm::vec4 >::iterator
        last: std::vector< glm::vec4 >::iterator

        """
        return _nvisii.Vec4Vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> Vec4Vector
        __init__(self, other) -> Vec4Vector

        Parameters
        ----------
        other: std::vector< glm::vec4 > const &

        __init__(self, size) -> Vec4Vector

        Parameters
        ----------
        size: std::vector< glm::vec4 >::size_type

        __init__(self, size, value) -> Vec4Vector

        Parameters
        ----------
        size: std::vector< glm::vec4 >::size_type
        value: std::vector< glm::vec4 >::value_type const &

        """
        _nvisii.Vec4Vector_swiginit(self, _nvisii.new_Vec4Vector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< glm::vec4 >::value_type const &

        """
        return _nvisii.Vec4Vector_push_back(self, x)

    def front(self):
        r"""front(self) -> vec4"""
        return _nvisii.Vec4Vector_front(self)

    def back(self):
        r"""back(self) -> vec4"""
        return _nvisii.Vec4Vector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< glm::vec4 >::size_type
        x: std::vector< glm::vec4 >::value_type const &

        """
        return _nvisii.Vec4Vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< glm::vec4 >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< glm::vec4 >::size_type
        x: std::vector< glm::vec4 >::value_type const &

        """
        return _nvisii.Vec4Vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< glm::vec4 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::vec4 >::iterator
        x: std::vector< glm::vec4 >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< glm::vec4 >::iterator
        n: std::vector< glm::vec4 >::size_type
        x: std::vector< glm::vec4 >::value_type const &

        """
        return _nvisii.Vec4Vector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< glm::vec4 >::size_type

        """
        return _nvisii.Vec4Vector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< glm::vec4 >::size_type"""
        return _nvisii.Vec4Vector_capacity(self)
    __swig_destroy__ = _nvisii.delete_Vec4Vector

# Register Vec4Vector in _nvisii:
_nvisii.Vec4Vector_swigregister(Vec4Vector)

class Vec3Vector(object):
    r"""Proxy of C++ std::vector< glm::vec3 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.Vec3Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.Vec3Vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.Vec3Vector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< glm::vec3 >::size_type"""
        return _nvisii.Vec3Vector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> Vec3Vector

        Parameters
        ----------
        i: std::vector< glm::vec3 >::difference_type
        j: std::vector< glm::vec3 >::difference_type

        """
        return _nvisii.Vec3Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::vec3 >::difference_type
        j: std::vector< glm::vec3 >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< glm::vec3 >::difference_type
        j: std::vector< glm::vec3 >::difference_type
        v: std::vector< glm::vec3,std::allocator< glm::vec3 > > const &

        """
        return _nvisii.Vec3Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::vec3 >::difference_type
        j: std::vector< glm::vec3 >::difference_type

        """
        return _nvisii.Vec3Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< glm::vec3 >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.Vec3Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> Vec3Vector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> vec3

        Parameters
        ----------
        i: std::vector< glm::vec3 >::difference_type

        """
        return _nvisii.Vec3Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< glm::vec3,std::allocator< glm::vec3 > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< glm::vec3 >::difference_type
        x: std::vector< glm::vec3 >::value_type const &

        """
        return _nvisii.Vec3Vector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> vec3"""
        return _nvisii.Vec3Vector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< glm::vec3 >::value_type const &

        """
        return _nvisii.Vec3Vector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.Vec3Vector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< glm::vec3 >::size_type"""
        return _nvisii.Vec3Vector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< glm::vec3 > &

        """
        return _nvisii.Vec3Vector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< glm::vec3 >::iterator"""
        return _nvisii.Vec3Vector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< glm::vec3 >::iterator"""
        return _nvisii.Vec3Vector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< glm::vec3 >::reverse_iterator"""
        return _nvisii.Vec3Vector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< glm::vec3 >::reverse_iterator"""
        return _nvisii.Vec3Vector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.Vec3Vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< glm::vec3 >::allocator_type"""
        return _nvisii.Vec3Vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.Vec3Vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< glm::vec3 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::vec3 >::iterator

        erase(self, first, last) -> std::vector< glm::vec3 >::iterator

        Parameters
        ----------
        first: std::vector< glm::vec3 >::iterator
        last: std::vector< glm::vec3 >::iterator

        """
        return _nvisii.Vec3Vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> Vec3Vector
        __init__(self, other) -> Vec3Vector

        Parameters
        ----------
        other: std::vector< glm::vec3 > const &

        __init__(self, size) -> Vec3Vector

        Parameters
        ----------
        size: std::vector< glm::vec3 >::size_type

        __init__(self, size, value) -> Vec3Vector

        Parameters
        ----------
        size: std::vector< glm::vec3 >::size_type
        value: std::vector< glm::vec3 >::value_type const &

        """
        _nvisii.Vec3Vector_swiginit(self, _nvisii.new_Vec3Vector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< glm::vec3 >::value_type const &

        """
        return _nvisii.Vec3Vector_push_back(self, x)

    def front(self):
        r"""front(self) -> vec3"""
        return _nvisii.Vec3Vector_front(self)

    def back(self):
        r"""back(self) -> vec3"""
        return _nvisii.Vec3Vector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< glm::vec3 >::size_type
        x: std::vector< glm::vec3 >::value_type const &

        """
        return _nvisii.Vec3Vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< glm::vec3 >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< glm::vec3 >::size_type
        x: std::vector< glm::vec3 >::value_type const &

        """
        return _nvisii.Vec3Vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< glm::vec3 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::vec3 >::iterator
        x: std::vector< glm::vec3 >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< glm::vec3 >::iterator
        n: std::vector< glm::vec3 >::size_type
        x: std::vector< glm::vec3 >::value_type const &

        """
        return _nvisii.Vec3Vector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< glm::vec3 >::size_type

        """
        return _nvisii.Vec3Vector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< glm::vec3 >::size_type"""
        return _nvisii.Vec3Vector_capacity(self)
    __swig_destroy__ = _nvisii.delete_Vec3Vector

# Register Vec3Vector in _nvisii:
_nvisii.Vec3Vector_swigregister(Vec3Vector)

class IVec2Vector(object):
    r"""Proxy of C++ std::vector< glm::ivec2 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.IVec2Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.IVec2Vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.IVec2Vector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< glm::ivec2 >::size_type"""
        return _nvisii.IVec2Vector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> IVec2Vector

        Parameters
        ----------
        i: std::vector< glm::ivec2 >::difference_type
        j: std::vector< glm::ivec2 >::difference_type

        """
        return _nvisii.IVec2Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::ivec2 >::difference_type
        j: std::vector< glm::ivec2 >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< glm::ivec2 >::difference_type
        j: std::vector< glm::ivec2 >::difference_type
        v: std::vector< glm::ivec2,std::allocator< glm::ivec2 > > const &

        """
        return _nvisii.IVec2Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::ivec2 >::difference_type
        j: std::vector< glm::ivec2 >::difference_type

        """
        return _nvisii.IVec2Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< glm::ivec2 >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.IVec2Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> IVec2Vector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> ivec2

        Parameters
        ----------
        i: std::vector< glm::ivec2 >::difference_type

        """
        return _nvisii.IVec2Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< glm::ivec2,std::allocator< glm::ivec2 > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< glm::ivec2 >::difference_type
        x: std::vector< glm::ivec2 >::value_type const &

        """
        return _nvisii.IVec2Vector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> ivec2"""
        return _nvisii.IVec2Vector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< glm::ivec2 >::value_type const &

        """
        return _nvisii.IVec2Vector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.IVec2Vector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< glm::ivec2 >::size_type"""
        return _nvisii.IVec2Vector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< glm::ivec2 > &

        """
        return _nvisii.IVec2Vector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< glm::ivec2 >::iterator"""
        return _nvisii.IVec2Vector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< glm::ivec2 >::iterator"""
        return _nvisii.IVec2Vector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< glm::ivec2 >::reverse_iterator"""
        return _nvisii.IVec2Vector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< glm::ivec2 >::reverse_iterator"""
        return _nvisii.IVec2Vector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.IVec2Vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< glm::ivec2 >::allocator_type"""
        return _nvisii.IVec2Vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.IVec2Vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< glm::ivec2 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::ivec2 >::iterator

        erase(self, first, last) -> std::vector< glm::ivec2 >::iterator

        Parameters
        ----------
        first: std::vector< glm::ivec2 >::iterator
        last: std::vector< glm::ivec2 >::iterator

        """
        return _nvisii.IVec2Vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> IVec2Vector
        __init__(self, other) -> IVec2Vector

        Parameters
        ----------
        other: std::vector< glm::ivec2 > const &

        __init__(self, size) -> IVec2Vector

        Parameters
        ----------
        size: std::vector< glm::ivec2 >::size_type

        __init__(self, size, value) -> IVec2Vector

        Parameters
        ----------
        size: std::vector< glm::ivec2 >::size_type
        value: std::vector< glm::ivec2 >::value_type const &

        """
        _nvisii.IVec2Vector_swiginit(self, _nvisii.new_IVec2Vector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< glm::ivec2 >::value_type const &

        """
        return _nvisii.IVec2Vector_push_back(self, x)

    def front(self):
        r"""front(self) -> ivec2"""
        return _nvisii.IVec2Vector_front(self)

    def back(self):
        r"""back(self) -> ivec2"""
        return _nvisii.IVec2Vector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< glm::ivec2 >::size_type
        x: std::vector< glm::ivec2 >::value_type const &

        """
        return _nvisii.IVec2Vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< glm::ivec2 >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< glm::ivec2 >::size_type
        x: std::vector< glm::ivec2 >::value_type const &

        """
        return _nvisii.IVec2Vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< glm::ivec2 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::ivec2 >::iterator
        x: std::vector< glm::ivec2 >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< glm::ivec2 >::iterator
        n: std::vector< glm::ivec2 >::size_type
        x: std::vector< glm::ivec2 >::value_type const &

        """
        return _nvisii.IVec2Vector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< glm::ivec2 >::size_type

        """
        return _nvisii.IVec2Vector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< glm::ivec2 >::size_type"""
        return _nvisii.IVec2Vector_capacity(self)
    __swig_destroy__ = _nvisii.delete_IVec2Vector

# Register IVec2Vector in _nvisii:
_nvisii.IVec2Vector_swigregister(IVec2Vector)

class IVec3Vector(object):
    r"""Proxy of C++ std::vector< glm::ivec3 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.IVec3Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.IVec3Vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.IVec3Vector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< glm::ivec3 >::size_type"""
        return _nvisii.IVec3Vector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> IVec3Vector

        Parameters
        ----------
        i: std::vector< glm::ivec3 >::difference_type
        j: std::vector< glm::ivec3 >::difference_type

        """
        return _nvisii.IVec3Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::ivec3 >::difference_type
        j: std::vector< glm::ivec3 >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< glm::ivec3 >::difference_type
        j: std::vector< glm::ivec3 >::difference_type
        v: std::vector< glm::ivec3,std::allocator< glm::ivec3 > > const &

        """
        return _nvisii.IVec3Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::ivec3 >::difference_type
        j: std::vector< glm::ivec3 >::difference_type

        """
        return _nvisii.IVec3Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< glm::ivec3 >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.IVec3Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> IVec3Vector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> ivec3

        Parameters
        ----------
        i: std::vector< glm::ivec3 >::difference_type

        """
        return _nvisii.IVec3Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< glm::ivec3,std::allocator< glm::ivec3 > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< glm::ivec3 >::difference_type
        x: std::vector< glm::ivec3 >::value_type const &

        """
        return _nvisii.IVec3Vector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> ivec3"""
        return _nvisii.IVec3Vector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< glm::ivec3 >::value_type const &

        """
        return _nvisii.IVec3Vector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.IVec3Vector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< glm::ivec3 >::size_type"""
        return _nvisii.IVec3Vector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< glm::ivec3 > &

        """
        return _nvisii.IVec3Vector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< glm::ivec3 >::iterator"""
        return _nvisii.IVec3Vector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< glm::ivec3 >::iterator"""
        return _nvisii.IVec3Vector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< glm::ivec3 >::reverse_iterator"""
        return _nvisii.IVec3Vector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< glm::ivec3 >::reverse_iterator"""
        return _nvisii.IVec3Vector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.IVec3Vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< glm::ivec3 >::allocator_type"""
        return _nvisii.IVec3Vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.IVec3Vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< glm::ivec3 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::ivec3 >::iterator

        erase(self, first, last) -> std::vector< glm::ivec3 >::iterator

        Parameters
        ----------
        first: std::vector< glm::ivec3 >::iterator
        last: std::vector< glm::ivec3 >::iterator

        """
        return _nvisii.IVec3Vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> IVec3Vector
        __init__(self, other) -> IVec3Vector

        Parameters
        ----------
        other: std::vector< glm::ivec3 > const &

        __init__(self, size) -> IVec3Vector

        Parameters
        ----------
        size: std::vector< glm::ivec3 >::size_type

        __init__(self, size, value) -> IVec3Vector

        Parameters
        ----------
        size: std::vector< glm::ivec3 >::size_type
        value: std::vector< glm::ivec3 >::value_type const &

        """
        _nvisii.IVec3Vector_swiginit(self, _nvisii.new_IVec3Vector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< glm::ivec3 >::value_type const &

        """
        return _nvisii.IVec3Vector_push_back(self, x)

    def front(self):
        r"""front(self) -> ivec3"""
        return _nvisii.IVec3Vector_front(self)

    def back(self):
        r"""back(self) -> ivec3"""
        return _nvisii.IVec3Vector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< glm::ivec3 >::size_type
        x: std::vector< glm::ivec3 >::value_type const &

        """
        return _nvisii.IVec3Vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< glm::ivec3 >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< glm::ivec3 >::size_type
        x: std::vector< glm::ivec3 >::value_type const &

        """
        return _nvisii.IVec3Vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< glm::ivec3 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::ivec3 >::iterator
        x: std::vector< glm::ivec3 >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< glm::ivec3 >::iterator
        n: std::vector< glm::ivec3 >::size_type
        x: std::vector< glm::ivec3 >::value_type const &

        """
        return _nvisii.IVec3Vector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< glm::ivec3 >::size_type

        """
        return _nvisii.IVec3Vector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< glm::ivec3 >::size_type"""
        return _nvisii.IVec3Vector_capacity(self)
    __swig_destroy__ = _nvisii.delete_IVec3Vector

# Register IVec3Vector in _nvisii:
_nvisii.IVec3Vector_swigregister(IVec3Vector)

class IVec4Vector(object):
    r"""Proxy of C++ std::vector< glm::ivec4 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.IVec4Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.IVec4Vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.IVec4Vector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< glm::ivec4 >::size_type"""
        return _nvisii.IVec4Vector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> IVec4Vector

        Parameters
        ----------
        i: std::vector< glm::ivec4 >::difference_type
        j: std::vector< glm::ivec4 >::difference_type

        """
        return _nvisii.IVec4Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::ivec4 >::difference_type
        j: std::vector< glm::ivec4 >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< glm::ivec4 >::difference_type
        j: std::vector< glm::ivec4 >::difference_type
        v: std::vector< glm::ivec4,std::allocator< glm::ivec4 > > const &

        """
        return _nvisii.IVec4Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::ivec4 >::difference_type
        j: std::vector< glm::ivec4 >::difference_type

        """
        return _nvisii.IVec4Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< glm::ivec4 >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.IVec4Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> IVec4Vector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> ivec4

        Parameters
        ----------
        i: std::vector< glm::ivec4 >::difference_type

        """
        return _nvisii.IVec4Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< glm::ivec4,std::allocator< glm::ivec4 > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< glm::ivec4 >::difference_type
        x: std::vector< glm::ivec4 >::value_type const &

        """
        return _nvisii.IVec4Vector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> ivec4"""
        return _nvisii.IVec4Vector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< glm::ivec4 >::value_type const &

        """
        return _nvisii.IVec4Vector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.IVec4Vector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< glm::ivec4 >::size_type"""
        return _nvisii.IVec4Vector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< glm::ivec4 > &

        """
        return _nvisii.IVec4Vector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< glm::ivec4 >::iterator"""
        return _nvisii.IVec4Vector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< glm::ivec4 >::iterator"""
        return _nvisii.IVec4Vector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< glm::ivec4 >::reverse_iterator"""
        return _nvisii.IVec4Vector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< glm::ivec4 >::reverse_iterator"""
        return _nvisii.IVec4Vector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.IVec4Vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< glm::ivec4 >::allocator_type"""
        return _nvisii.IVec4Vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.IVec4Vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< glm::ivec4 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::ivec4 >::iterator

        erase(self, first, last) -> std::vector< glm::ivec4 >::iterator

        Parameters
        ----------
        first: std::vector< glm::ivec4 >::iterator
        last: std::vector< glm::ivec4 >::iterator

        """
        return _nvisii.IVec4Vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> IVec4Vector
        __init__(self, other) -> IVec4Vector

        Parameters
        ----------
        other: std::vector< glm::ivec4 > const &

        __init__(self, size) -> IVec4Vector

        Parameters
        ----------
        size: std::vector< glm::ivec4 >::size_type

        __init__(self, size, value) -> IVec4Vector

        Parameters
        ----------
        size: std::vector< glm::ivec4 >::size_type
        value: std::vector< glm::ivec4 >::value_type const &

        """
        _nvisii.IVec4Vector_swiginit(self, _nvisii.new_IVec4Vector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< glm::ivec4 >::value_type const &

        """
        return _nvisii.IVec4Vector_push_back(self, x)

    def front(self):
        r"""front(self) -> ivec4"""
        return _nvisii.IVec4Vector_front(self)

    def back(self):
        r"""back(self) -> ivec4"""
        return _nvisii.IVec4Vector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< glm::ivec4 >::size_type
        x: std::vector< glm::ivec4 >::value_type const &

        """
        return _nvisii.IVec4Vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< glm::ivec4 >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< glm::ivec4 >::size_type
        x: std::vector< glm::ivec4 >::value_type const &

        """
        return _nvisii.IVec4Vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< glm::ivec4 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::ivec4 >::iterator
        x: std::vector< glm::ivec4 >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< glm::ivec4 >::iterator
        n: std::vector< glm::ivec4 >::size_type
        x: std::vector< glm::ivec4 >::value_type const &

        """
        return _nvisii.IVec4Vector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< glm::ivec4 >::size_type

        """
        return _nvisii.IVec4Vector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< glm::ivec4 >::size_type"""
        return _nvisii.IVec4Vector_capacity(self)
    __swig_destroy__ = _nvisii.delete_IVec4Vector

# Register IVec4Vector in _nvisii:
_nvisii.IVec4Vector_swigregister(IVec4Vector)

class U16Vec2Vector(object):
    r"""Proxy of C++ std::vector< glm::u16vec2 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.U16Vec2Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.U16Vec2Vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.U16Vec2Vector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< glm::u16vec2 >::size_type"""
        return _nvisii.U16Vec2Vector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> U16Vec2Vector

        Parameters
        ----------
        i: std::vector< glm::u16vec2 >::difference_type
        j: std::vector< glm::u16vec2 >::difference_type

        """
        return _nvisii.U16Vec2Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::u16vec2 >::difference_type
        j: std::vector< glm::u16vec2 >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< glm::u16vec2 >::difference_type
        j: std::vector< glm::u16vec2 >::difference_type
        v: std::vector< glm::u16vec2,std::allocator< glm::u16vec2 > > const &

        """
        return _nvisii.U16Vec2Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::u16vec2 >::difference_type
        j: std::vector< glm::u16vec2 >::difference_type

        """
        return _nvisii.U16Vec2Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< glm::u16vec2 >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.U16Vec2Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> U16Vec2Vector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> u16vec2

        Parameters
        ----------
        i: std::vector< glm::u16vec2 >::difference_type

        """
        return _nvisii.U16Vec2Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< glm::u16vec2,std::allocator< glm::u16vec2 > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< glm::u16vec2 >::difference_type
        x: std::vector< glm::u16vec2 >::value_type const &

        """
        return _nvisii.U16Vec2Vector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> u16vec2"""
        return _nvisii.U16Vec2Vector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< glm::u16vec2 >::value_type const &

        """
        return _nvisii.U16Vec2Vector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.U16Vec2Vector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< glm::u16vec2 >::size_type"""
        return _nvisii.U16Vec2Vector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< glm::u16vec2 > &

        """
        return _nvisii.U16Vec2Vector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< glm::u16vec2 >::iterator"""
        return _nvisii.U16Vec2Vector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< glm::u16vec2 >::iterator"""
        return _nvisii.U16Vec2Vector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< glm::u16vec2 >::reverse_iterator"""
        return _nvisii.U16Vec2Vector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< glm::u16vec2 >::reverse_iterator"""
        return _nvisii.U16Vec2Vector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.U16Vec2Vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< glm::u16vec2 >::allocator_type"""
        return _nvisii.U16Vec2Vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.U16Vec2Vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< glm::u16vec2 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::u16vec2 >::iterator

        erase(self, first, last) -> std::vector< glm::u16vec2 >::iterator

        Parameters
        ----------
        first: std::vector< glm::u16vec2 >::iterator
        last: std::vector< glm::u16vec2 >::iterator

        """
        return _nvisii.U16Vec2Vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> U16Vec2Vector
        __init__(self, other) -> U16Vec2Vector

        Parameters
        ----------
        other: std::vector< glm::u16vec2 > const &

        __init__(self, size) -> U16Vec2Vector

        Parameters
        ----------
        size: std::vector< glm::u16vec2 >::size_type

        __init__(self, size, value) -> U16Vec2Vector

        Parameters
        ----------
        size: std::vector< glm::u16vec2 >::size_type
        value: std::vector< glm::u16vec2 >::value_type const &

        """
        _nvisii.U16Vec2Vector_swiginit(self, _nvisii.new_U16Vec2Vector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< glm::u16vec2 >::value_type const &

        """
        return _nvisii.U16Vec2Vector_push_back(self, x)

    def front(self):
        r"""front(self) -> u16vec2"""
        return _nvisii.U16Vec2Vector_front(self)

    def back(self):
        r"""back(self) -> u16vec2"""
        return _nvisii.U16Vec2Vector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< glm::u16vec2 >::size_type
        x: std::vector< glm::u16vec2 >::value_type const &

        """
        return _nvisii.U16Vec2Vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< glm::u16vec2 >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< glm::u16vec2 >::size_type
        x: std::vector< glm::u16vec2 >::value_type const &

        """
        return _nvisii.U16Vec2Vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< glm::u16vec2 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::u16vec2 >::iterator
        x: std::vector< glm::u16vec2 >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< glm::u16vec2 >::iterator
        n: std::vector< glm::u16vec2 >::size_type
        x: std::vector< glm::u16vec2 >::value_type const &

        """
        return _nvisii.U16Vec2Vector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< glm::u16vec2 >::size_type

        """
        return _nvisii.U16Vec2Vector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< glm::u16vec2 >::size_type"""
        return _nvisii.U16Vec2Vector_capacity(self)
    __swig_destroy__ = _nvisii.delete_U16Vec2Vector

# Register U16Vec2Vector in _nvisii:
_nvisii.U16Vec2Vector_swigregister(U16Vec2Vector)

class U16Vec3Vector(object):
    r"""Proxy of C++ std::vector< glm::u16vec3 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.U16Vec3Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.U16Vec3Vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.U16Vec3Vector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< glm::u16vec3 >::size_type"""
        return _nvisii.U16Vec3Vector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> U16Vec3Vector

        Parameters
        ----------
        i: std::vector< glm::u16vec3 >::difference_type
        j: std::vector< glm::u16vec3 >::difference_type

        """
        return _nvisii.U16Vec3Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::u16vec3 >::difference_type
        j: std::vector< glm::u16vec3 >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< glm::u16vec3 >::difference_type
        j: std::vector< glm::u16vec3 >::difference_type
        v: std::vector< glm::u16vec3,std::allocator< glm::u16vec3 > > const &

        """
        return _nvisii.U16Vec3Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::u16vec3 >::difference_type
        j: std::vector< glm::u16vec3 >::difference_type

        """
        return _nvisii.U16Vec3Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< glm::u16vec3 >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.U16Vec3Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> U16Vec3Vector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> u16vec3

        Parameters
        ----------
        i: std::vector< glm::u16vec3 >::difference_type

        """
        return _nvisii.U16Vec3Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< glm::u16vec3,std::allocator< glm::u16vec3 > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< glm::u16vec3 >::difference_type
        x: std::vector< glm::u16vec3 >::value_type const &

        """
        return _nvisii.U16Vec3Vector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> u16vec3"""
        return _nvisii.U16Vec3Vector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< glm::u16vec3 >::value_type const &

        """
        return _nvisii.U16Vec3Vector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.U16Vec3Vector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< glm::u16vec3 >::size_type"""
        return _nvisii.U16Vec3Vector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< glm::u16vec3 > &

        """
        return _nvisii.U16Vec3Vector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< glm::u16vec3 >::iterator"""
        return _nvisii.U16Vec3Vector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< glm::u16vec3 >::iterator"""
        return _nvisii.U16Vec3Vector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< glm::u16vec3 >::reverse_iterator"""
        return _nvisii.U16Vec3Vector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< glm::u16vec3 >::reverse_iterator"""
        return _nvisii.U16Vec3Vector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.U16Vec3Vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< glm::u16vec3 >::allocator_type"""
        return _nvisii.U16Vec3Vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.U16Vec3Vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< glm::u16vec3 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::u16vec3 >::iterator

        erase(self, first, last) -> std::vector< glm::u16vec3 >::iterator

        Parameters
        ----------
        first: std::vector< glm::u16vec3 >::iterator
        last: std::vector< glm::u16vec3 >::iterator

        """
        return _nvisii.U16Vec3Vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> U16Vec3Vector
        __init__(self, other) -> U16Vec3Vector

        Parameters
        ----------
        other: std::vector< glm::u16vec3 > const &

        __init__(self, size) -> U16Vec3Vector

        Parameters
        ----------
        size: std::vector< glm::u16vec3 >::size_type

        __init__(self, size, value) -> U16Vec3Vector

        Parameters
        ----------
        size: std::vector< glm::u16vec3 >::size_type
        value: std::vector< glm::u16vec3 >::value_type const &

        """
        _nvisii.U16Vec3Vector_swiginit(self, _nvisii.new_U16Vec3Vector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< glm::u16vec3 >::value_type const &

        """
        return _nvisii.U16Vec3Vector_push_back(self, x)

    def front(self):
        r"""front(self) -> u16vec3"""
        return _nvisii.U16Vec3Vector_front(self)

    def back(self):
        r"""back(self) -> u16vec3"""
        return _nvisii.U16Vec3Vector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< glm::u16vec3 >::size_type
        x: std::vector< glm::u16vec3 >::value_type const &

        """
        return _nvisii.U16Vec3Vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< glm::u16vec3 >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< glm::u16vec3 >::size_type
        x: std::vector< glm::u16vec3 >::value_type const &

        """
        return _nvisii.U16Vec3Vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< glm::u16vec3 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::u16vec3 >::iterator
        x: std::vector< glm::u16vec3 >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< glm::u16vec3 >::iterator
        n: std::vector< glm::u16vec3 >::size_type
        x: std::vector< glm::u16vec3 >::value_type const &

        """
        return _nvisii.U16Vec3Vector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< glm::u16vec3 >::size_type

        """
        return _nvisii.U16Vec3Vector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< glm::u16vec3 >::size_type"""
        return _nvisii.U16Vec3Vector_capacity(self)
    __swig_destroy__ = _nvisii.delete_U16Vec3Vector

# Register U16Vec3Vector in _nvisii:
_nvisii.U16Vec3Vector_swigregister(U16Vec3Vector)

class U16Vec4Vector(object):
    r"""Proxy of C++ std::vector< glm::u16vec4 > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.U16Vec4Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.U16Vec4Vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.U16Vec4Vector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< glm::u16vec4 >::size_type"""
        return _nvisii.U16Vec4Vector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> U16Vec4Vector

        Parameters
        ----------
        i: std::vector< glm::u16vec4 >::difference_type
        j: std::vector< glm::u16vec4 >::difference_type

        """
        return _nvisii.U16Vec4Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::u16vec4 >::difference_type
        j: std::vector< glm::u16vec4 >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< glm::u16vec4 >::difference_type
        j: std::vector< glm::u16vec4 >::difference_type
        v: std::vector< glm::u16vec4,std::allocator< glm::u16vec4 > > const &

        """
        return _nvisii.U16Vec4Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< glm::u16vec4 >::difference_type
        j: std::vector< glm::u16vec4 >::difference_type

        """
        return _nvisii.U16Vec4Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< glm::u16vec4 >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.U16Vec4Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> U16Vec4Vector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> u16vec4

        Parameters
        ----------
        i: std::vector< glm::u16vec4 >::difference_type

        """
        return _nvisii.U16Vec4Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< glm::u16vec4,std::allocator< glm::u16vec4 > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< glm::u16vec4 >::difference_type
        x: std::vector< glm::u16vec4 >::value_type const &

        """
        return _nvisii.U16Vec4Vector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> u16vec4"""
        return _nvisii.U16Vec4Vector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< glm::u16vec4 >::value_type const &

        """
        return _nvisii.U16Vec4Vector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.U16Vec4Vector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< glm::u16vec4 >::size_type"""
        return _nvisii.U16Vec4Vector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< glm::u16vec4 > &

        """
        return _nvisii.U16Vec4Vector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< glm::u16vec4 >::iterator"""
        return _nvisii.U16Vec4Vector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< glm::u16vec4 >::iterator"""
        return _nvisii.U16Vec4Vector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< glm::u16vec4 >::reverse_iterator"""
        return _nvisii.U16Vec4Vector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< glm::u16vec4 >::reverse_iterator"""
        return _nvisii.U16Vec4Vector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.U16Vec4Vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< glm::u16vec4 >::allocator_type"""
        return _nvisii.U16Vec4Vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.U16Vec4Vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< glm::u16vec4 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::u16vec4 >::iterator

        erase(self, first, last) -> std::vector< glm::u16vec4 >::iterator

        Parameters
        ----------
        first: std::vector< glm::u16vec4 >::iterator
        last: std::vector< glm::u16vec4 >::iterator

        """
        return _nvisii.U16Vec4Vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> U16Vec4Vector
        __init__(self, other) -> U16Vec4Vector

        Parameters
        ----------
        other: std::vector< glm::u16vec4 > const &

        __init__(self, size) -> U16Vec4Vector

        Parameters
        ----------
        size: std::vector< glm::u16vec4 >::size_type

        __init__(self, size, value) -> U16Vec4Vector

        Parameters
        ----------
        size: std::vector< glm::u16vec4 >::size_type
        value: std::vector< glm::u16vec4 >::value_type const &

        """
        _nvisii.U16Vec4Vector_swiginit(self, _nvisii.new_U16Vec4Vector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< glm::u16vec4 >::value_type const &

        """
        return _nvisii.U16Vec4Vector_push_back(self, x)

    def front(self):
        r"""front(self) -> u16vec4"""
        return _nvisii.U16Vec4Vector_front(self)

    def back(self):
        r"""back(self) -> u16vec4"""
        return _nvisii.U16Vec4Vector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< glm::u16vec4 >::size_type
        x: std::vector< glm::u16vec4 >::value_type const &

        """
        return _nvisii.U16Vec4Vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< glm::u16vec4 >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< glm::u16vec4 >::size_type
        x: std::vector< glm::u16vec4 >::value_type const &

        """
        return _nvisii.U16Vec4Vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< glm::u16vec4 >::iterator

        Parameters
        ----------
        pos: std::vector< glm::u16vec4 >::iterator
        x: std::vector< glm::u16vec4 >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< glm::u16vec4 >::iterator
        n: std::vector< glm::u16vec4 >::size_type
        x: std::vector< glm::u16vec4 >::value_type const &

        """
        return _nvisii.U16Vec4Vector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< glm::u16vec4 >::size_type

        """
        return _nvisii.U16Vec4Vector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< glm::u16vec4 >::size_type"""
        return _nvisii.U16Vec4Vector_capacity(self)
    __swig_destroy__ = _nvisii.delete_U16Vec4Vector

# Register U16Vec4Vector in _nvisii:
_nvisii.U16Vec4Vector_swigregister(U16Vec4Vector)

class Vec2Vector2D(object):
    r"""Proxy of C++ std::vector< std::vector< glm::vec2 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.Vec2Vector2D_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.Vec2Vector2D___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.Vec2Vector2D___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< glm::vec2 > >::size_type"""
        return _nvisii.Vec2Vector2D___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> Vec2Vector2D

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec2 > >::difference_type
        j: std::vector< std::vector< glm::vec2 > >::difference_type

        """
        return _nvisii.Vec2Vector2D___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec2 > >::difference_type
        j: std::vector< std::vector< glm::vec2 > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec2 > >::difference_type
        j: std::vector< std::vector< glm::vec2 > >::difference_type
        v: std::vector< std::vector< glm::vec2,std::allocator< glm::vec2 > >,std::allocator< std::vector< glm::vec2,std::allocator< glm::vec2 > > > > const &

        """
        return _nvisii.Vec2Vector2D___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec2 > >::difference_type
        j: std::vector< std::vector< glm::vec2 > >::difference_type

        """
        return _nvisii.Vec2Vector2D___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec2 > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.Vec2Vector2D___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> Vec2Vector2D

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> Vec2Vector

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec2 > >::difference_type

        """
        return _nvisii.Vec2Vector2D___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::vector< glm::vec2,std::allocator< glm::vec2 > >,std::allocator< std::vector< glm::vec2,std::allocator< glm::vec2 > > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec2 > >::difference_type
        x: std::vector< std::vector< glm::vec2 > >::value_type const &

        """
        return _nvisii.Vec2Vector2D___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> Vec2Vector"""
        return _nvisii.Vec2Vector2D_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::vec2 > >::value_type const &

        """
        return _nvisii.Vec2Vector2D_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.Vec2Vector2D_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< glm::vec2 > >::size_type"""
        return _nvisii.Vec2Vector2D_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::vector< glm::vec2,std::allocator< glm::vec2 > > > &

        """
        return _nvisii.Vec2Vector2D_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< glm::vec2 > >::iterator"""
        return _nvisii.Vec2Vector2D_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< glm::vec2 > >::iterator"""
        return _nvisii.Vec2Vector2D_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< glm::vec2 > >::reverse_iterator"""
        return _nvisii.Vec2Vector2D_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< glm::vec2 > >::reverse_iterator"""
        return _nvisii.Vec2Vector2D_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.Vec2Vector2D_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< glm::vec2 > >::allocator_type"""
        return _nvisii.Vec2Vector2D_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.Vec2Vector2D_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< glm::vec2 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::vec2 > >::iterator

        erase(self, first, last) -> std::vector< std::vector< glm::vec2 > >::iterator

        Parameters
        ----------
        first: std::vector< std::vector< glm::vec2 > >::iterator
        last: std::vector< std::vector< glm::vec2 > >::iterator

        """
        return _nvisii.Vec2Vector2D_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> Vec2Vector2D
        __init__(self, other) -> Vec2Vector2D

        Parameters
        ----------
        other: std::vector< std::vector< glm::vec2,std::allocator< glm::vec2 > > > const &

        __init__(self, size) -> Vec2Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::vec2 > >::size_type

        __init__(self, size, value) -> Vec2Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::vec2 > >::size_type
        value: std::vector< std::vector< glm::vec2 > >::value_type const &

        """
        _nvisii.Vec2Vector2D_swiginit(self, _nvisii.new_Vec2Vector2D(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::vec2 > >::value_type const &

        """
        return _nvisii.Vec2Vector2D_push_back(self, x)

    def front(self):
        r"""front(self) -> Vec2Vector"""
        return _nvisii.Vec2Vector2D_front(self)

    def back(self):
        r"""back(self) -> Vec2Vector"""
        return _nvisii.Vec2Vector2D_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::vector< glm::vec2 > >::size_type
        x: std::vector< std::vector< glm::vec2 > >::value_type const &

        """
        return _nvisii.Vec2Vector2D_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::vec2 > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::vec2 > >::size_type
        x: std::vector< std::vector< glm::vec2 > >::value_type const &

        """
        return _nvisii.Vec2Vector2D_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< glm::vec2 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::vec2 > >::iterator
        x: std::vector< std::vector< glm::vec2 > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::vector< glm::vec2 > >::iterator
        n: std::vector< std::vector< glm::vec2 > >::size_type
        x: std::vector< std::vector< glm::vec2 > >::value_type const &

        """
        return _nvisii.Vec2Vector2D_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::vector< glm::vec2 > >::size_type

        """
        return _nvisii.Vec2Vector2D_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< glm::vec2 > >::size_type"""
        return _nvisii.Vec2Vector2D_capacity(self)
    __swig_destroy__ = _nvisii.delete_Vec2Vector2D

# Register Vec2Vector2D in _nvisii:
_nvisii.Vec2Vector2D_swigregister(Vec2Vector2D)

class Vec3Vector2D(object):
    r"""Proxy of C++ std::vector< std::vector< glm::vec3 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.Vec3Vector2D_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.Vec3Vector2D___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.Vec3Vector2D___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< glm::vec3 > >::size_type"""
        return _nvisii.Vec3Vector2D___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> Vec3Vector2D

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec3 > >::difference_type
        j: std::vector< std::vector< glm::vec3 > >::difference_type

        """
        return _nvisii.Vec3Vector2D___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec3 > >::difference_type
        j: std::vector< std::vector< glm::vec3 > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec3 > >::difference_type
        j: std::vector< std::vector< glm::vec3 > >::difference_type
        v: std::vector< std::vector< glm::vec3,std::allocator< glm::vec3 > >,std::allocator< std::vector< glm::vec3,std::allocator< glm::vec3 > > > > const &

        """
        return _nvisii.Vec3Vector2D___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec3 > >::difference_type
        j: std::vector< std::vector< glm::vec3 > >::difference_type

        """
        return _nvisii.Vec3Vector2D___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec3 > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.Vec3Vector2D___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> Vec3Vector2D

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> Vec3Vector

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec3 > >::difference_type

        """
        return _nvisii.Vec3Vector2D___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::vector< glm::vec3,std::allocator< glm::vec3 > >,std::allocator< std::vector< glm::vec3,std::allocator< glm::vec3 > > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec3 > >::difference_type
        x: std::vector< std::vector< glm::vec3 > >::value_type const &

        """
        return _nvisii.Vec3Vector2D___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> Vec3Vector"""
        return _nvisii.Vec3Vector2D_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::vec3 > >::value_type const &

        """
        return _nvisii.Vec3Vector2D_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.Vec3Vector2D_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< glm::vec3 > >::size_type"""
        return _nvisii.Vec3Vector2D_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::vector< glm::vec3,std::allocator< glm::vec3 > > > &

        """
        return _nvisii.Vec3Vector2D_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< glm::vec3 > >::iterator"""
        return _nvisii.Vec3Vector2D_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< glm::vec3 > >::iterator"""
        return _nvisii.Vec3Vector2D_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< glm::vec3 > >::reverse_iterator"""
        return _nvisii.Vec3Vector2D_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< glm::vec3 > >::reverse_iterator"""
        return _nvisii.Vec3Vector2D_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.Vec3Vector2D_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< glm::vec3 > >::allocator_type"""
        return _nvisii.Vec3Vector2D_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.Vec3Vector2D_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< glm::vec3 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::vec3 > >::iterator

        erase(self, first, last) -> std::vector< std::vector< glm::vec3 > >::iterator

        Parameters
        ----------
        first: std::vector< std::vector< glm::vec3 > >::iterator
        last: std::vector< std::vector< glm::vec3 > >::iterator

        """
        return _nvisii.Vec3Vector2D_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> Vec3Vector2D
        __init__(self, other) -> Vec3Vector2D

        Parameters
        ----------
        other: std::vector< std::vector< glm::vec3,std::allocator< glm::vec3 > > > const &

        __init__(self, size) -> Vec3Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::vec3 > >::size_type

        __init__(self, size, value) -> Vec3Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::vec3 > >::size_type
        value: std::vector< std::vector< glm::vec3 > >::value_type const &

        """
        _nvisii.Vec3Vector2D_swiginit(self, _nvisii.new_Vec3Vector2D(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::vec3 > >::value_type const &

        """
        return _nvisii.Vec3Vector2D_push_back(self, x)

    def front(self):
        r"""front(self) -> Vec3Vector"""
        return _nvisii.Vec3Vector2D_front(self)

    def back(self):
        r"""back(self) -> Vec3Vector"""
        return _nvisii.Vec3Vector2D_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::vector< glm::vec3 > >::size_type
        x: std::vector< std::vector< glm::vec3 > >::value_type const &

        """
        return _nvisii.Vec3Vector2D_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::vec3 > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::vec3 > >::size_type
        x: std::vector< std::vector< glm::vec3 > >::value_type const &

        """
        return _nvisii.Vec3Vector2D_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< glm::vec3 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::vec3 > >::iterator
        x: std::vector< std::vector< glm::vec3 > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::vector< glm::vec3 > >::iterator
        n: std::vector< std::vector< glm::vec3 > >::size_type
        x: std::vector< std::vector< glm::vec3 > >::value_type const &

        """
        return _nvisii.Vec3Vector2D_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::vector< glm::vec3 > >::size_type

        """
        return _nvisii.Vec3Vector2D_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< glm::vec3 > >::size_type"""
        return _nvisii.Vec3Vector2D_capacity(self)
    __swig_destroy__ = _nvisii.delete_Vec3Vector2D

# Register Vec3Vector2D in _nvisii:
_nvisii.Vec3Vector2D_swigregister(Vec3Vector2D)

class Vec4Vector2D(object):
    r"""Proxy of C++ std::vector< std::vector< glm::vec4 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.Vec4Vector2D_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.Vec4Vector2D___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.Vec4Vector2D___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< glm::vec4 > >::size_type"""
        return _nvisii.Vec4Vector2D___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> Vec4Vector2D

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec4 > >::difference_type
        j: std::vector< std::vector< glm::vec4 > >::difference_type

        """
        return _nvisii.Vec4Vector2D___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec4 > >::difference_type
        j: std::vector< std::vector< glm::vec4 > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec4 > >::difference_type
        j: std::vector< std::vector< glm::vec4 > >::difference_type
        v: std::vector< std::vector< glm::vec4,std::allocator< glm::vec4 > >,std::allocator< std::vector< glm::vec4,std::allocator< glm::vec4 > > > > const &

        """
        return _nvisii.Vec4Vector2D___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec4 > >::difference_type
        j: std::vector< std::vector< glm::vec4 > >::difference_type

        """
        return _nvisii.Vec4Vector2D___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec4 > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.Vec4Vector2D___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> Vec4Vector2D

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> Vec4Vector

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec4 > >::difference_type

        """
        return _nvisii.Vec4Vector2D___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::vector< glm::vec4,std::allocator< glm::vec4 > >,std::allocator< std::vector< glm::vec4,std::allocator< glm::vec4 > > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::vector< glm::vec4 > >::difference_type
        x: std::vector< std::vector< glm::vec4 > >::value_type const &

        """
        return _nvisii.Vec4Vector2D___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> Vec4Vector"""
        return _nvisii.Vec4Vector2D_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::vec4 > >::value_type const &

        """
        return _nvisii.Vec4Vector2D_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.Vec4Vector2D_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< glm::vec4 > >::size_type"""
        return _nvisii.Vec4Vector2D_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::vector< glm::vec4,std::allocator< glm::vec4 > > > &

        """
        return _nvisii.Vec4Vector2D_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< glm::vec4 > >::iterator"""
        return _nvisii.Vec4Vector2D_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< glm::vec4 > >::iterator"""
        return _nvisii.Vec4Vector2D_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< glm::vec4 > >::reverse_iterator"""
        return _nvisii.Vec4Vector2D_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< glm::vec4 > >::reverse_iterator"""
        return _nvisii.Vec4Vector2D_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.Vec4Vector2D_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< glm::vec4 > >::allocator_type"""
        return _nvisii.Vec4Vector2D_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.Vec4Vector2D_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< glm::vec4 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::vec4 > >::iterator

        erase(self, first, last) -> std::vector< std::vector< glm::vec4 > >::iterator

        Parameters
        ----------
        first: std::vector< std::vector< glm::vec4 > >::iterator
        last: std::vector< std::vector< glm::vec4 > >::iterator

        """
        return _nvisii.Vec4Vector2D_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> Vec4Vector2D
        __init__(self, other) -> Vec4Vector2D

        Parameters
        ----------
        other: std::vector< std::vector< glm::vec4,std::allocator< glm::vec4 > > > const &

        __init__(self, size) -> Vec4Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::vec4 > >::size_type

        __init__(self, size, value) -> Vec4Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::vec4 > >::size_type
        value: std::vector< std::vector< glm::vec4 > >::value_type const &

        """
        _nvisii.Vec4Vector2D_swiginit(self, _nvisii.new_Vec4Vector2D(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::vec4 > >::value_type const &

        """
        return _nvisii.Vec4Vector2D_push_back(self, x)

    def front(self):
        r"""front(self) -> Vec4Vector"""
        return _nvisii.Vec4Vector2D_front(self)

    def back(self):
        r"""back(self) -> Vec4Vector"""
        return _nvisii.Vec4Vector2D_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::vector< glm::vec4 > >::size_type
        x: std::vector< std::vector< glm::vec4 > >::value_type const &

        """
        return _nvisii.Vec4Vector2D_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::vec4 > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::vec4 > >::size_type
        x: std::vector< std::vector< glm::vec4 > >::value_type const &

        """
        return _nvisii.Vec4Vector2D_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< glm::vec4 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::vec4 > >::iterator
        x: std::vector< std::vector< glm::vec4 > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::vector< glm::vec4 > >::iterator
        n: std::vector< std::vector< glm::vec4 > >::size_type
        x: std::vector< std::vector< glm::vec4 > >::value_type const &

        """
        return _nvisii.Vec4Vector2D_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::vector< glm::vec4 > >::size_type

        """
        return _nvisii.Vec4Vector2D_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< glm::vec4 > >::size_type"""
        return _nvisii.Vec4Vector2D_capacity(self)
    __swig_destroy__ = _nvisii.delete_Vec4Vector2D

# Register Vec4Vector2D in _nvisii:
_nvisii.Vec4Vector2D_swigregister(Vec4Vector2D)

class IVec2Vector2D(object):
    r"""Proxy of C++ std::vector< std::vector< glm::ivec2 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.IVec2Vector2D_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.IVec2Vector2D___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.IVec2Vector2D___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< glm::ivec2 > >::size_type"""
        return _nvisii.IVec2Vector2D___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> IVec2Vector2D

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec2 > >::difference_type
        j: std::vector< std::vector< glm::ivec2 > >::difference_type

        """
        return _nvisii.IVec2Vector2D___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec2 > >::difference_type
        j: std::vector< std::vector< glm::ivec2 > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec2 > >::difference_type
        j: std::vector< std::vector< glm::ivec2 > >::difference_type
        v: std::vector< std::vector< glm::ivec2,std::allocator< glm::ivec2 > >,std::allocator< std::vector< glm::ivec2,std::allocator< glm::ivec2 > > > > const &

        """
        return _nvisii.IVec2Vector2D___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec2 > >::difference_type
        j: std::vector< std::vector< glm::ivec2 > >::difference_type

        """
        return _nvisii.IVec2Vector2D___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec2 > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.IVec2Vector2D___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> IVec2Vector2D

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> IVec2Vector

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec2 > >::difference_type

        """
        return _nvisii.IVec2Vector2D___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::vector< glm::ivec2,std::allocator< glm::ivec2 > >,std::allocator< std::vector< glm::ivec2,std::allocator< glm::ivec2 > > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec2 > >::difference_type
        x: std::vector< std::vector< glm::ivec2 > >::value_type const &

        """
        return _nvisii.IVec2Vector2D___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> IVec2Vector"""
        return _nvisii.IVec2Vector2D_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::ivec2 > >::value_type const &

        """
        return _nvisii.IVec2Vector2D_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.IVec2Vector2D_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< glm::ivec2 > >::size_type"""
        return _nvisii.IVec2Vector2D_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::vector< glm::ivec2,std::allocator< glm::ivec2 > > > &

        """
        return _nvisii.IVec2Vector2D_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< glm::ivec2 > >::iterator"""
        return _nvisii.IVec2Vector2D_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< glm::ivec2 > >::iterator"""
        return _nvisii.IVec2Vector2D_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< glm::ivec2 > >::reverse_iterator"""
        return _nvisii.IVec2Vector2D_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< glm::ivec2 > >::reverse_iterator"""
        return _nvisii.IVec2Vector2D_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.IVec2Vector2D_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< glm::ivec2 > >::allocator_type"""
        return _nvisii.IVec2Vector2D_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.IVec2Vector2D_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< glm::ivec2 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::ivec2 > >::iterator

        erase(self, first, last) -> std::vector< std::vector< glm::ivec2 > >::iterator

        Parameters
        ----------
        first: std::vector< std::vector< glm::ivec2 > >::iterator
        last: std::vector< std::vector< glm::ivec2 > >::iterator

        """
        return _nvisii.IVec2Vector2D_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> IVec2Vector2D
        __init__(self, other) -> IVec2Vector2D

        Parameters
        ----------
        other: std::vector< std::vector< glm::ivec2,std::allocator< glm::ivec2 > > > const &

        __init__(self, size) -> IVec2Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::ivec2 > >::size_type

        __init__(self, size, value) -> IVec2Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::ivec2 > >::size_type
        value: std::vector< std::vector< glm::ivec2 > >::value_type const &

        """
        _nvisii.IVec2Vector2D_swiginit(self, _nvisii.new_IVec2Vector2D(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::ivec2 > >::value_type const &

        """
        return _nvisii.IVec2Vector2D_push_back(self, x)

    def front(self):
        r"""front(self) -> IVec2Vector"""
        return _nvisii.IVec2Vector2D_front(self)

    def back(self):
        r"""back(self) -> IVec2Vector"""
        return _nvisii.IVec2Vector2D_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::vector< glm::ivec2 > >::size_type
        x: std::vector< std::vector< glm::ivec2 > >::value_type const &

        """
        return _nvisii.IVec2Vector2D_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::ivec2 > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::ivec2 > >::size_type
        x: std::vector< std::vector< glm::ivec2 > >::value_type const &

        """
        return _nvisii.IVec2Vector2D_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< glm::ivec2 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::ivec2 > >::iterator
        x: std::vector< std::vector< glm::ivec2 > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::vector< glm::ivec2 > >::iterator
        n: std::vector< std::vector< glm::ivec2 > >::size_type
        x: std::vector< std::vector< glm::ivec2 > >::value_type const &

        """
        return _nvisii.IVec2Vector2D_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::vector< glm::ivec2 > >::size_type

        """
        return _nvisii.IVec2Vector2D_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< glm::ivec2 > >::size_type"""
        return _nvisii.IVec2Vector2D_capacity(self)
    __swig_destroy__ = _nvisii.delete_IVec2Vector2D

# Register IVec2Vector2D in _nvisii:
_nvisii.IVec2Vector2D_swigregister(IVec2Vector2D)

class IVec3Vector2D(object):
    r"""Proxy of C++ std::vector< std::vector< glm::ivec3 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.IVec3Vector2D_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.IVec3Vector2D___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.IVec3Vector2D___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< glm::ivec3 > >::size_type"""
        return _nvisii.IVec3Vector2D___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> IVec3Vector2D

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec3 > >::difference_type
        j: std::vector< std::vector< glm::ivec3 > >::difference_type

        """
        return _nvisii.IVec3Vector2D___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec3 > >::difference_type
        j: std::vector< std::vector< glm::ivec3 > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec3 > >::difference_type
        j: std::vector< std::vector< glm::ivec3 > >::difference_type
        v: std::vector< std::vector< glm::ivec3,std::allocator< glm::ivec3 > >,std::allocator< std::vector< glm::ivec3,std::allocator< glm::ivec3 > > > > const &

        """
        return _nvisii.IVec3Vector2D___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec3 > >::difference_type
        j: std::vector< std::vector< glm::ivec3 > >::difference_type

        """
        return _nvisii.IVec3Vector2D___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec3 > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.IVec3Vector2D___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> IVec3Vector2D

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> IVec3Vector

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec3 > >::difference_type

        """
        return _nvisii.IVec3Vector2D___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::vector< glm::ivec3,std::allocator< glm::ivec3 > >,std::allocator< std::vector< glm::ivec3,std::allocator< glm::ivec3 > > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec3 > >::difference_type
        x: std::vector< std::vector< glm::ivec3 > >::value_type const &

        """
        return _nvisii.IVec3Vector2D___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> IVec3Vector"""
        return _nvisii.IVec3Vector2D_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::ivec3 > >::value_type const &

        """
        return _nvisii.IVec3Vector2D_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.IVec3Vector2D_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< glm::ivec3 > >::size_type"""
        return _nvisii.IVec3Vector2D_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::vector< glm::ivec3,std::allocator< glm::ivec3 > > > &

        """
        return _nvisii.IVec3Vector2D_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< glm::ivec3 > >::iterator"""
        return _nvisii.IVec3Vector2D_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< glm::ivec3 > >::iterator"""
        return _nvisii.IVec3Vector2D_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< glm::ivec3 > >::reverse_iterator"""
        return _nvisii.IVec3Vector2D_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< glm::ivec3 > >::reverse_iterator"""
        return _nvisii.IVec3Vector2D_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.IVec3Vector2D_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< glm::ivec3 > >::allocator_type"""
        return _nvisii.IVec3Vector2D_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.IVec3Vector2D_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< glm::ivec3 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::ivec3 > >::iterator

        erase(self, first, last) -> std::vector< std::vector< glm::ivec3 > >::iterator

        Parameters
        ----------
        first: std::vector< std::vector< glm::ivec3 > >::iterator
        last: std::vector< std::vector< glm::ivec3 > >::iterator

        """
        return _nvisii.IVec3Vector2D_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> IVec3Vector2D
        __init__(self, other) -> IVec3Vector2D

        Parameters
        ----------
        other: std::vector< std::vector< glm::ivec3,std::allocator< glm::ivec3 > > > const &

        __init__(self, size) -> IVec3Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::ivec3 > >::size_type

        __init__(self, size, value) -> IVec3Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::ivec3 > >::size_type
        value: std::vector< std::vector< glm::ivec3 > >::value_type const &

        """
        _nvisii.IVec3Vector2D_swiginit(self, _nvisii.new_IVec3Vector2D(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::ivec3 > >::value_type const &

        """
        return _nvisii.IVec3Vector2D_push_back(self, x)

    def front(self):
        r"""front(self) -> IVec3Vector"""
        return _nvisii.IVec3Vector2D_front(self)

    def back(self):
        r"""back(self) -> IVec3Vector"""
        return _nvisii.IVec3Vector2D_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::vector< glm::ivec3 > >::size_type
        x: std::vector< std::vector< glm::ivec3 > >::value_type const &

        """
        return _nvisii.IVec3Vector2D_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::ivec3 > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::ivec3 > >::size_type
        x: std::vector< std::vector< glm::ivec3 > >::value_type const &

        """
        return _nvisii.IVec3Vector2D_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< glm::ivec3 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::ivec3 > >::iterator
        x: std::vector< std::vector< glm::ivec3 > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::vector< glm::ivec3 > >::iterator
        n: std::vector< std::vector< glm::ivec3 > >::size_type
        x: std::vector< std::vector< glm::ivec3 > >::value_type const &

        """
        return _nvisii.IVec3Vector2D_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::vector< glm::ivec3 > >::size_type

        """
        return _nvisii.IVec3Vector2D_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< glm::ivec3 > >::size_type"""
        return _nvisii.IVec3Vector2D_capacity(self)
    __swig_destroy__ = _nvisii.delete_IVec3Vector2D

# Register IVec3Vector2D in _nvisii:
_nvisii.IVec3Vector2D_swigregister(IVec3Vector2D)

class IVec4Vector2D(object):
    r"""Proxy of C++ std::vector< std::vector< glm::ivec4 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.IVec4Vector2D_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.IVec4Vector2D___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.IVec4Vector2D___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< glm::ivec4 > >::size_type"""
        return _nvisii.IVec4Vector2D___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> IVec4Vector2D

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec4 > >::difference_type
        j: std::vector< std::vector< glm::ivec4 > >::difference_type

        """
        return _nvisii.IVec4Vector2D___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec4 > >::difference_type
        j: std::vector< std::vector< glm::ivec4 > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec4 > >::difference_type
        j: std::vector< std::vector< glm::ivec4 > >::difference_type
        v: std::vector< std::vector< glm::ivec4,std::allocator< glm::ivec4 > >,std::allocator< std::vector< glm::ivec4,std::allocator< glm::ivec4 > > > > const &

        """
        return _nvisii.IVec4Vector2D___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec4 > >::difference_type
        j: std::vector< std::vector< glm::ivec4 > >::difference_type

        """
        return _nvisii.IVec4Vector2D___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec4 > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.IVec4Vector2D___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> IVec4Vector2D

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> IVec4Vector

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec4 > >::difference_type

        """
        return _nvisii.IVec4Vector2D___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::vector< glm::ivec4,std::allocator< glm::ivec4 > >,std::allocator< std::vector< glm::ivec4,std::allocator< glm::ivec4 > > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::vector< glm::ivec4 > >::difference_type
        x: std::vector< std::vector< glm::ivec4 > >::value_type const &

        """
        return _nvisii.IVec4Vector2D___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> IVec4Vector"""
        return _nvisii.IVec4Vector2D_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::ivec4 > >::value_type const &

        """
        return _nvisii.IVec4Vector2D_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.IVec4Vector2D_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< glm::ivec4 > >::size_type"""
        return _nvisii.IVec4Vector2D_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::vector< glm::ivec4,std::allocator< glm::ivec4 > > > &

        """
        return _nvisii.IVec4Vector2D_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< glm::ivec4 > >::iterator"""
        return _nvisii.IVec4Vector2D_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< glm::ivec4 > >::iterator"""
        return _nvisii.IVec4Vector2D_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< glm::ivec4 > >::reverse_iterator"""
        return _nvisii.IVec4Vector2D_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< glm::ivec4 > >::reverse_iterator"""
        return _nvisii.IVec4Vector2D_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.IVec4Vector2D_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< glm::ivec4 > >::allocator_type"""
        return _nvisii.IVec4Vector2D_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.IVec4Vector2D_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< glm::ivec4 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::ivec4 > >::iterator

        erase(self, first, last) -> std::vector< std::vector< glm::ivec4 > >::iterator

        Parameters
        ----------
        first: std::vector< std::vector< glm::ivec4 > >::iterator
        last: std::vector< std::vector< glm::ivec4 > >::iterator

        """
        return _nvisii.IVec4Vector2D_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> IVec4Vector2D
        __init__(self, other) -> IVec4Vector2D

        Parameters
        ----------
        other: std::vector< std::vector< glm::ivec4,std::allocator< glm::ivec4 > > > const &

        __init__(self, size) -> IVec4Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::ivec4 > >::size_type

        __init__(self, size, value) -> IVec4Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::ivec4 > >::size_type
        value: std::vector< std::vector< glm::ivec4 > >::value_type const &

        """
        _nvisii.IVec4Vector2D_swiginit(self, _nvisii.new_IVec4Vector2D(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::ivec4 > >::value_type const &

        """
        return _nvisii.IVec4Vector2D_push_back(self, x)

    def front(self):
        r"""front(self) -> IVec4Vector"""
        return _nvisii.IVec4Vector2D_front(self)

    def back(self):
        r"""back(self) -> IVec4Vector"""
        return _nvisii.IVec4Vector2D_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::vector< glm::ivec4 > >::size_type
        x: std::vector< std::vector< glm::ivec4 > >::value_type const &

        """
        return _nvisii.IVec4Vector2D_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::ivec4 > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::ivec4 > >::size_type
        x: std::vector< std::vector< glm::ivec4 > >::value_type const &

        """
        return _nvisii.IVec4Vector2D_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< glm::ivec4 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::ivec4 > >::iterator
        x: std::vector< std::vector< glm::ivec4 > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::vector< glm::ivec4 > >::iterator
        n: std::vector< std::vector< glm::ivec4 > >::size_type
        x: std::vector< std::vector< glm::ivec4 > >::value_type const &

        """
        return _nvisii.IVec4Vector2D_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::vector< glm::ivec4 > >::size_type

        """
        return _nvisii.IVec4Vector2D_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< glm::ivec4 > >::size_type"""
        return _nvisii.IVec4Vector2D_capacity(self)
    __swig_destroy__ = _nvisii.delete_IVec4Vector2D

# Register IVec4Vector2D in _nvisii:
_nvisii.IVec4Vector2D_swigregister(IVec4Vector2D)

class U16Vec2Vector2D(object):
    r"""Proxy of C++ std::vector< std::vector< glm::u16vec2 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.U16Vec2Vector2D_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.U16Vec2Vector2D___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.U16Vec2Vector2D___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< glm::u16vec2 > >::size_type"""
        return _nvisii.U16Vec2Vector2D___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> U16Vec2Vector2D

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec2 > >::difference_type
        j: std::vector< std::vector< glm::u16vec2 > >::difference_type

        """
        return _nvisii.U16Vec2Vector2D___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec2 > >::difference_type
        j: std::vector< std::vector< glm::u16vec2 > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec2 > >::difference_type
        j: std::vector< std::vector< glm::u16vec2 > >::difference_type
        v: std::vector< std::vector< glm::u16vec2,std::allocator< glm::u16vec2 > >,std::allocator< std::vector< glm::u16vec2,std::allocator< glm::u16vec2 > > > > const &

        """
        return _nvisii.U16Vec2Vector2D___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec2 > >::difference_type
        j: std::vector< std::vector< glm::u16vec2 > >::difference_type

        """
        return _nvisii.U16Vec2Vector2D___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec2 > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.U16Vec2Vector2D___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> U16Vec2Vector2D

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> U16Vec2Vector

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec2 > >::difference_type

        """
        return _nvisii.U16Vec2Vector2D___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::vector< glm::u16vec2,std::allocator< glm::u16vec2 > >,std::allocator< std::vector< glm::u16vec2,std::allocator< glm::u16vec2 > > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec2 > >::difference_type
        x: std::vector< std::vector< glm::u16vec2 > >::value_type const &

        """
        return _nvisii.U16Vec2Vector2D___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> U16Vec2Vector"""
        return _nvisii.U16Vec2Vector2D_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::u16vec2 > >::value_type const &

        """
        return _nvisii.U16Vec2Vector2D_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.U16Vec2Vector2D_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< glm::u16vec2 > >::size_type"""
        return _nvisii.U16Vec2Vector2D_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::vector< glm::u16vec2,std::allocator< glm::u16vec2 > > > &

        """
        return _nvisii.U16Vec2Vector2D_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< glm::u16vec2 > >::iterator"""
        return _nvisii.U16Vec2Vector2D_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< glm::u16vec2 > >::iterator"""
        return _nvisii.U16Vec2Vector2D_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< glm::u16vec2 > >::reverse_iterator"""
        return _nvisii.U16Vec2Vector2D_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< glm::u16vec2 > >::reverse_iterator"""
        return _nvisii.U16Vec2Vector2D_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.U16Vec2Vector2D_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< glm::u16vec2 > >::allocator_type"""
        return _nvisii.U16Vec2Vector2D_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.U16Vec2Vector2D_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< glm::u16vec2 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::u16vec2 > >::iterator

        erase(self, first, last) -> std::vector< std::vector< glm::u16vec2 > >::iterator

        Parameters
        ----------
        first: std::vector< std::vector< glm::u16vec2 > >::iterator
        last: std::vector< std::vector< glm::u16vec2 > >::iterator

        """
        return _nvisii.U16Vec2Vector2D_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> U16Vec2Vector2D
        __init__(self, other) -> U16Vec2Vector2D

        Parameters
        ----------
        other: std::vector< std::vector< glm::u16vec2,std::allocator< glm::u16vec2 > > > const &

        __init__(self, size) -> U16Vec2Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::u16vec2 > >::size_type

        __init__(self, size, value) -> U16Vec2Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::u16vec2 > >::size_type
        value: std::vector< std::vector< glm::u16vec2 > >::value_type const &

        """
        _nvisii.U16Vec2Vector2D_swiginit(self, _nvisii.new_U16Vec2Vector2D(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::u16vec2 > >::value_type const &

        """
        return _nvisii.U16Vec2Vector2D_push_back(self, x)

    def front(self):
        r"""front(self) -> U16Vec2Vector"""
        return _nvisii.U16Vec2Vector2D_front(self)

    def back(self):
        r"""back(self) -> U16Vec2Vector"""
        return _nvisii.U16Vec2Vector2D_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::vector< glm::u16vec2 > >::size_type
        x: std::vector< std::vector< glm::u16vec2 > >::value_type const &

        """
        return _nvisii.U16Vec2Vector2D_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::u16vec2 > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::u16vec2 > >::size_type
        x: std::vector< std::vector< glm::u16vec2 > >::value_type const &

        """
        return _nvisii.U16Vec2Vector2D_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< glm::u16vec2 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::u16vec2 > >::iterator
        x: std::vector< std::vector< glm::u16vec2 > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::vector< glm::u16vec2 > >::iterator
        n: std::vector< std::vector< glm::u16vec2 > >::size_type
        x: std::vector< std::vector< glm::u16vec2 > >::value_type const &

        """
        return _nvisii.U16Vec2Vector2D_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::vector< glm::u16vec2 > >::size_type

        """
        return _nvisii.U16Vec2Vector2D_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< glm::u16vec2 > >::size_type"""
        return _nvisii.U16Vec2Vector2D_capacity(self)
    __swig_destroy__ = _nvisii.delete_U16Vec2Vector2D

# Register U16Vec2Vector2D in _nvisii:
_nvisii.U16Vec2Vector2D_swigregister(U16Vec2Vector2D)

class U16Vec3Vector2D(object):
    r"""Proxy of C++ std::vector< std::vector< glm::u16vec3 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.U16Vec3Vector2D_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.U16Vec3Vector2D___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.U16Vec3Vector2D___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< glm::u16vec3 > >::size_type"""
        return _nvisii.U16Vec3Vector2D___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> U16Vec3Vector2D

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec3 > >::difference_type
        j: std::vector< std::vector< glm::u16vec3 > >::difference_type

        """
        return _nvisii.U16Vec3Vector2D___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec3 > >::difference_type
        j: std::vector< std::vector< glm::u16vec3 > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec3 > >::difference_type
        j: std::vector< std::vector< glm::u16vec3 > >::difference_type
        v: std::vector< std::vector< glm::u16vec3,std::allocator< glm::u16vec3 > >,std::allocator< std::vector< glm::u16vec3,std::allocator< glm::u16vec3 > > > > const &

        """
        return _nvisii.U16Vec3Vector2D___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec3 > >::difference_type
        j: std::vector< std::vector< glm::u16vec3 > >::difference_type

        """
        return _nvisii.U16Vec3Vector2D___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec3 > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.U16Vec3Vector2D___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> U16Vec3Vector2D

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> U16Vec3Vector

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec3 > >::difference_type

        """
        return _nvisii.U16Vec3Vector2D___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::vector< glm::u16vec3,std::allocator< glm::u16vec3 > >,std::allocator< std::vector< glm::u16vec3,std::allocator< glm::u16vec3 > > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec3 > >::difference_type
        x: std::vector< std::vector< glm::u16vec3 > >::value_type const &

        """
        return _nvisii.U16Vec3Vector2D___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> U16Vec3Vector"""
        return _nvisii.U16Vec3Vector2D_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::u16vec3 > >::value_type const &

        """
        return _nvisii.U16Vec3Vector2D_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.U16Vec3Vector2D_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< glm::u16vec3 > >::size_type"""
        return _nvisii.U16Vec3Vector2D_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::vector< glm::u16vec3,std::allocator< glm::u16vec3 > > > &

        """
        return _nvisii.U16Vec3Vector2D_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< glm::u16vec3 > >::iterator"""
        return _nvisii.U16Vec3Vector2D_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< glm::u16vec3 > >::iterator"""
        return _nvisii.U16Vec3Vector2D_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< glm::u16vec3 > >::reverse_iterator"""
        return _nvisii.U16Vec3Vector2D_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< glm::u16vec3 > >::reverse_iterator"""
        return _nvisii.U16Vec3Vector2D_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.U16Vec3Vector2D_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< glm::u16vec3 > >::allocator_type"""
        return _nvisii.U16Vec3Vector2D_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.U16Vec3Vector2D_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< glm::u16vec3 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::u16vec3 > >::iterator

        erase(self, first, last) -> std::vector< std::vector< glm::u16vec3 > >::iterator

        Parameters
        ----------
        first: std::vector< std::vector< glm::u16vec3 > >::iterator
        last: std::vector< std::vector< glm::u16vec3 > >::iterator

        """
        return _nvisii.U16Vec3Vector2D_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> U16Vec3Vector2D
        __init__(self, other) -> U16Vec3Vector2D

        Parameters
        ----------
        other: std::vector< std::vector< glm::u16vec3,std::allocator< glm::u16vec3 > > > const &

        __init__(self, size) -> U16Vec3Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::u16vec3 > >::size_type

        __init__(self, size, value) -> U16Vec3Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::u16vec3 > >::size_type
        value: std::vector< std::vector< glm::u16vec3 > >::value_type const &

        """
        _nvisii.U16Vec3Vector2D_swiginit(self, _nvisii.new_U16Vec3Vector2D(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::u16vec3 > >::value_type const &

        """
        return _nvisii.U16Vec3Vector2D_push_back(self, x)

    def front(self):
        r"""front(self) -> U16Vec3Vector"""
        return _nvisii.U16Vec3Vector2D_front(self)

    def back(self):
        r"""back(self) -> U16Vec3Vector"""
        return _nvisii.U16Vec3Vector2D_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::vector< glm::u16vec3 > >::size_type
        x: std::vector< std::vector< glm::u16vec3 > >::value_type const &

        """
        return _nvisii.U16Vec3Vector2D_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::u16vec3 > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::u16vec3 > >::size_type
        x: std::vector< std::vector< glm::u16vec3 > >::value_type const &

        """
        return _nvisii.U16Vec3Vector2D_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< glm::u16vec3 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::u16vec3 > >::iterator
        x: std::vector< std::vector< glm::u16vec3 > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::vector< glm::u16vec3 > >::iterator
        n: std::vector< std::vector< glm::u16vec3 > >::size_type
        x: std::vector< std::vector< glm::u16vec3 > >::value_type const &

        """
        return _nvisii.U16Vec3Vector2D_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::vector< glm::u16vec3 > >::size_type

        """
        return _nvisii.U16Vec3Vector2D_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< glm::u16vec3 > >::size_type"""
        return _nvisii.U16Vec3Vector2D_capacity(self)
    __swig_destroy__ = _nvisii.delete_U16Vec3Vector2D

# Register U16Vec3Vector2D in _nvisii:
_nvisii.U16Vec3Vector2D_swigregister(U16Vec3Vector2D)

class U16Vec4Vector2D(object):
    r"""Proxy of C++ std::vector< std::vector< glm::u16vec4 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.U16Vec4Vector2D_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.U16Vec4Vector2D___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.U16Vec4Vector2D___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< glm::u16vec4 > >::size_type"""
        return _nvisii.U16Vec4Vector2D___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> U16Vec4Vector2D

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec4 > >::difference_type
        j: std::vector< std::vector< glm::u16vec4 > >::difference_type

        """
        return _nvisii.U16Vec4Vector2D___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec4 > >::difference_type
        j: std::vector< std::vector< glm::u16vec4 > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec4 > >::difference_type
        j: std::vector< std::vector< glm::u16vec4 > >::difference_type
        v: std::vector< std::vector< glm::u16vec4,std::allocator< glm::u16vec4 > >,std::allocator< std::vector< glm::u16vec4,std::allocator< glm::u16vec4 > > > > const &

        """
        return _nvisii.U16Vec4Vector2D___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec4 > >::difference_type
        j: std::vector< std::vector< glm::u16vec4 > >::difference_type

        """
        return _nvisii.U16Vec4Vector2D___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec4 > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.U16Vec4Vector2D___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> U16Vec4Vector2D

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> U16Vec4Vector

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec4 > >::difference_type

        """
        return _nvisii.U16Vec4Vector2D___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::vector< glm::u16vec4,std::allocator< glm::u16vec4 > >,std::allocator< std::vector< glm::u16vec4,std::allocator< glm::u16vec4 > > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::vector< glm::u16vec4 > >::difference_type
        x: std::vector< std::vector< glm::u16vec4 > >::value_type const &

        """
        return _nvisii.U16Vec4Vector2D___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> U16Vec4Vector"""
        return _nvisii.U16Vec4Vector2D_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::u16vec4 > >::value_type const &

        """
        return _nvisii.U16Vec4Vector2D_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.U16Vec4Vector2D_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< glm::u16vec4 > >::size_type"""
        return _nvisii.U16Vec4Vector2D_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::vector< glm::u16vec4,std::allocator< glm::u16vec4 > > > &

        """
        return _nvisii.U16Vec4Vector2D_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< glm::u16vec4 > >::iterator"""
        return _nvisii.U16Vec4Vector2D_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< glm::u16vec4 > >::iterator"""
        return _nvisii.U16Vec4Vector2D_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< glm::u16vec4 > >::reverse_iterator"""
        return _nvisii.U16Vec4Vector2D_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< glm::u16vec4 > >::reverse_iterator"""
        return _nvisii.U16Vec4Vector2D_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.U16Vec4Vector2D_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< glm::u16vec4 > >::allocator_type"""
        return _nvisii.U16Vec4Vector2D_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.U16Vec4Vector2D_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< glm::u16vec4 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::u16vec4 > >::iterator

        erase(self, first, last) -> std::vector< std::vector< glm::u16vec4 > >::iterator

        Parameters
        ----------
        first: std::vector< std::vector< glm::u16vec4 > >::iterator
        last: std::vector< std::vector< glm::u16vec4 > >::iterator

        """
        return _nvisii.U16Vec4Vector2D_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> U16Vec4Vector2D
        __init__(self, other) -> U16Vec4Vector2D

        Parameters
        ----------
        other: std::vector< std::vector< glm::u16vec4,std::allocator< glm::u16vec4 > > > const &

        __init__(self, size) -> U16Vec4Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::u16vec4 > >::size_type

        __init__(self, size, value) -> U16Vec4Vector2D

        Parameters
        ----------
        size: std::vector< std::vector< glm::u16vec4 > >::size_type
        value: std::vector< std::vector< glm::u16vec4 > >::value_type const &

        """
        _nvisii.U16Vec4Vector2D_swiginit(self, _nvisii.new_U16Vec4Vector2D(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< glm::u16vec4 > >::value_type const &

        """
        return _nvisii.U16Vec4Vector2D_push_back(self, x)

    def front(self):
        r"""front(self) -> U16Vec4Vector"""
        return _nvisii.U16Vec4Vector2D_front(self)

    def back(self):
        r"""back(self) -> U16Vec4Vector"""
        return _nvisii.U16Vec4Vector2D_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::vector< glm::u16vec4 > >::size_type
        x: std::vector< std::vector< glm::u16vec4 > >::value_type const &

        """
        return _nvisii.U16Vec4Vector2D_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::u16vec4 > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::vector< glm::u16vec4 > >::size_type
        x: std::vector< std::vector< glm::u16vec4 > >::value_type const &

        """
        return _nvisii.U16Vec4Vector2D_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< glm::u16vec4 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< glm::u16vec4 > >::iterator
        x: std::vector< std::vector< glm::u16vec4 > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::vector< glm::u16vec4 > >::iterator
        n: std::vector< std::vector< glm::u16vec4 > >::size_type
        x: std::vector< std::vector< glm::u16vec4 > >::value_type const &

        """
        return _nvisii.U16Vec4Vector2D_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::vector< glm::u16vec4 > >::size_type

        """
        return _nvisii.U16Vec4Vector2D_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< glm::u16vec4 > >::size_type"""
        return _nvisii.U16Vec4Vector2D_capacity(self)
    __swig_destroy__ = _nvisii.delete_U16Vec4Vector2D

# Register U16Vec4Vector2D in _nvisii:
_nvisii.U16Vec4Vector2D_swigregister(U16Vec4Vector2D)

class Float3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _nvisii.Float3_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _nvisii.Float3___nonzero__(self)

    def __bool__(self):
        return _nvisii.Float3___bool__(self)

    def __len__(self):
        return _nvisii.Float3___len__(self)

    def __getslice__(self, i, j):
        return _nvisii.Float3___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _nvisii.Float3___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _nvisii.Float3___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _nvisii.Float3___delitem__(self, *args)

    def __getitem__(self, *args):
        return _nvisii.Float3___getitem__(self, *args)

    def __setitem__(self, *args):
        return _nvisii.Float3___setitem__(self, *args)

    def __init__(self, *args):
        _nvisii.Float3_swiginit(self, _nvisii.new_Float3(*args))

    def empty(self):
        return _nvisii.Float3_empty(self)

    def size(self):
        return _nvisii.Float3_size(self)

    def swap(self, v):
        return _nvisii.Float3_swap(self, v)

    def begin(self):
        return _nvisii.Float3_begin(self)

    def end(self):
        return _nvisii.Float3_end(self)

    def rbegin(self):
        return _nvisii.Float3_rbegin(self)

    def rend(self):
        return _nvisii.Float3_rend(self)

    def front(self):
        return _nvisii.Float3_front(self)

    def back(self):
        return _nvisii.Float3_back(self)

    def fill(self, u):
        return _nvisii.Float3_fill(self, u)
    __swig_destroy__ = _nvisii.delete_Float3

# Register Float3 in _nvisii:
_nvisii.Float3_swigregister(Float3)

class Float4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _nvisii.Float4_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _nvisii.Float4___nonzero__(self)

    def __bool__(self):
        return _nvisii.Float4___bool__(self)

    def __len__(self):
        return _nvisii.Float4___len__(self)

    def __getslice__(self, i, j):
        return _nvisii.Float4___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _nvisii.Float4___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _nvisii.Float4___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _nvisii.Float4___delitem__(self, *args)

    def __getitem__(self, *args):
        return _nvisii.Float4___getitem__(self, *args)

    def __setitem__(self, *args):
        return _nvisii.Float4___setitem__(self, *args)

    def __init__(self, *args):
        _nvisii.Float4_swiginit(self, _nvisii.new_Float4(*args))

    def empty(self):
        return _nvisii.Float4_empty(self)

    def size(self):
        return _nvisii.Float4_size(self)

    def swap(self, v):
        return _nvisii.Float4_swap(self, v)

    def begin(self):
        return _nvisii.Float4_begin(self)

    def end(self):
        return _nvisii.Float4_end(self)

    def rbegin(self):
        return _nvisii.Float4_rbegin(self)

    def rend(self):
        return _nvisii.Float4_rend(self)

    def front(self):
        return _nvisii.Float4_front(self)

    def back(self):
        return _nvisii.Float4_back(self)

    def fill(self, u):
        return _nvisii.Float4_fill(self, u)
    __swig_destroy__ = _nvisii.delete_Float4

# Register Float4 in _nvisii:
_nvisii.Float4_swigregister(Float4)

class FloatVector(object):
    r"""Proxy of C++ std::vector< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.FloatVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.FloatVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< float >::size_type"""
        return _nvisii.FloatVector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> FloatVector

        Parameters
        ----------
        i: std::vector< float >::difference_type
        j: std::vector< float >::difference_type

        """
        return _nvisii.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< float >::difference_type
        j: std::vector< float >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< float >::difference_type
        j: std::vector< float >::difference_type
        v: std::vector< float,std::allocator< float > > const &

        """
        return _nvisii.FloatVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< float >::difference_type
        j: std::vector< float >::difference_type

        """
        return _nvisii.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< float >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> FloatVector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> std::vector< float >::value_type const &

        Parameters
        ----------
        i: std::vector< float >::difference_type

        """
        return _nvisii.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< float,std::allocator< float > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< float >::difference_type
        x: std::vector< float >::value_type const &

        """
        return _nvisii.FloatVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< float >::value_type"""
        return _nvisii.FloatVector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< float >::value_type const &

        """
        return _nvisii.FloatVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.FloatVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< float >::size_type"""
        return _nvisii.FloatVector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< float > &

        """
        return _nvisii.FloatVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< float >::iterator"""
        return _nvisii.FloatVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< float >::iterator"""
        return _nvisii.FloatVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< float >::reverse_iterator"""
        return _nvisii.FloatVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< float >::reverse_iterator"""
        return _nvisii.FloatVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.FloatVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< float >::allocator_type"""
        return _nvisii.FloatVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.FloatVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< float >::iterator

        Parameters
        ----------
        pos: std::vector< float >::iterator

        erase(self, first, last) -> std::vector< float >::iterator

        Parameters
        ----------
        first: std::vector< float >::iterator
        last: std::vector< float >::iterator

        """
        return _nvisii.FloatVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> FloatVector
        __init__(self, other) -> FloatVector

        Parameters
        ----------
        other: std::vector< float > const &

        __init__(self, size) -> FloatVector

        Parameters
        ----------
        size: std::vector< float >::size_type

        __init__(self, size, value) -> FloatVector

        Parameters
        ----------
        size: std::vector< float >::size_type
        value: std::vector< float >::value_type const &

        """
        _nvisii.FloatVector_swiginit(self, _nvisii.new_FloatVector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< float >::value_type const &

        """
        return _nvisii.FloatVector_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< float >::value_type const &"""
        return _nvisii.FloatVector_front(self)

    def back(self):
        r"""back(self) -> std::vector< float >::value_type const &"""
        return _nvisii.FloatVector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< float >::size_type
        x: std::vector< float >::value_type const &

        """
        return _nvisii.FloatVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< float >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< float >::size_type
        x: std::vector< float >::value_type const &

        """
        return _nvisii.FloatVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< float >::iterator

        Parameters
        ----------
        pos: std::vector< float >::iterator
        x: std::vector< float >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< float >::iterator
        n: std::vector< float >::size_type
        x: std::vector< float >::value_type const &

        """
        return _nvisii.FloatVector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< float >::size_type

        """
        return _nvisii.FloatVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< float >::size_type"""
        return _nvisii.FloatVector_capacity(self)
    __swig_destroy__ = _nvisii.delete_FloatVector

# Register FloatVector in _nvisii:
_nvisii.FloatVector_swigregister(FloatVector)

class Float3Vector(object):
    r"""Proxy of C++ std::vector< std::array< float,3 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.Float3Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.Float3Vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.Float3Vector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::array< float,3 > >::size_type"""
        return _nvisii.Float3Vector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> Float3Vector

        Parameters
        ----------
        i: std::vector< std::array< float,3 > >::difference_type
        j: std::vector< std::array< float,3 > >::difference_type

        """
        return _nvisii.Float3Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::array< float,3 > >::difference_type
        j: std::vector< std::array< float,3 > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::array< float,3 > >::difference_type
        j: std::vector< std::array< float,3 > >::difference_type
        v: std::vector< std::array< float,3 >,std::allocator< std::array< float,3 > > > const &

        """
        return _nvisii.Float3Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::array< float,3 > >::difference_type
        j: std::vector< std::array< float,3 > >::difference_type

        """
        return _nvisii.Float3Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::array< float,3 > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.Float3Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> Float3Vector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> Float3

        Parameters
        ----------
        i: std::vector< std::array< float,3 > >::difference_type

        """
        return _nvisii.Float3Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::array< float,3 >,std::allocator< std::array< float,3 > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::array< float,3 > >::difference_type
        x: std::vector< std::array< float,3 > >::value_type const &

        """
        return _nvisii.Float3Vector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> Float3"""
        return _nvisii.Float3Vector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::array< float,3 > >::value_type const &

        """
        return _nvisii.Float3Vector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.Float3Vector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::array< float,3 > >::size_type"""
        return _nvisii.Float3Vector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::array< float,3 > > &

        """
        return _nvisii.Float3Vector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::array< float,3 > >::iterator"""
        return _nvisii.Float3Vector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::array< float,3 > >::iterator"""
        return _nvisii.Float3Vector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::array< float,3 > >::reverse_iterator"""
        return _nvisii.Float3Vector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::array< float,3 > >::reverse_iterator"""
        return _nvisii.Float3Vector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.Float3Vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::array< float,3 > >::allocator_type"""
        return _nvisii.Float3Vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.Float3Vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::array< float,3 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::array< float,3 > >::iterator

        erase(self, first, last) -> std::vector< std::array< float,3 > >::iterator

        Parameters
        ----------
        first: std::vector< std::array< float,3 > >::iterator
        last: std::vector< std::array< float,3 > >::iterator

        """
        return _nvisii.Float3Vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> Float3Vector
        __init__(self, other) -> Float3Vector

        Parameters
        ----------
        other: std::vector< std::array< float,3 > > const &

        __init__(self, size) -> Float3Vector

        Parameters
        ----------
        size: std::vector< std::array< float,3 > >::size_type

        __init__(self, size, value) -> Float3Vector

        Parameters
        ----------
        size: std::vector< std::array< float,3 > >::size_type
        value: std::vector< std::array< float,3 > >::value_type const &

        """
        _nvisii.Float3Vector_swiginit(self, _nvisii.new_Float3Vector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::array< float,3 > >::value_type const &

        """
        return _nvisii.Float3Vector_push_back(self, x)

    def front(self):
        r"""front(self) -> Float3"""
        return _nvisii.Float3Vector_front(self)

    def back(self):
        r"""back(self) -> Float3"""
        return _nvisii.Float3Vector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::array< float,3 > >::size_type
        x: std::vector< std::array< float,3 > >::value_type const &

        """
        return _nvisii.Float3Vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::array< float,3 > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::array< float,3 > >::size_type
        x: std::vector< std::array< float,3 > >::value_type const &

        """
        return _nvisii.Float3Vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::array< float,3 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::array< float,3 > >::iterator
        x: std::vector< std::array< float,3 > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::array< float,3 > >::iterator
        n: std::vector< std::array< float,3 > >::size_type
        x: std::vector< std::array< float,3 > >::value_type const &

        """
        return _nvisii.Float3Vector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::array< float,3 > >::size_type

        """
        return _nvisii.Float3Vector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::array< float,3 > >::size_type"""
        return _nvisii.Float3Vector_capacity(self)
    __swig_destroy__ = _nvisii.delete_Float3Vector

# Register Float3Vector in _nvisii:
_nvisii.Float3Vector_swigregister(Float3Vector)

class Float4Vector(object):
    r"""Proxy of C++ std::vector< std::array< float,4 > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.Float4Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.Float4Vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.Float4Vector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::array< float,4 > >::size_type"""
        return _nvisii.Float4Vector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> Float4Vector

        Parameters
        ----------
        i: std::vector< std::array< float,4 > >::difference_type
        j: std::vector< std::array< float,4 > >::difference_type

        """
        return _nvisii.Float4Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::array< float,4 > >::difference_type
        j: std::vector< std::array< float,4 > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::array< float,4 > >::difference_type
        j: std::vector< std::array< float,4 > >::difference_type
        v: std::vector< std::array< float,4 >,std::allocator< std::array< float,4 > > > const &

        """
        return _nvisii.Float4Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::array< float,4 > >::difference_type
        j: std::vector< std::array< float,4 > >::difference_type

        """
        return _nvisii.Float4Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::array< float,4 > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.Float4Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> Float4Vector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> Float4

        Parameters
        ----------
        i: std::vector< std::array< float,4 > >::difference_type

        """
        return _nvisii.Float4Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::array< float,4 >,std::allocator< std::array< float,4 > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::array< float,4 > >::difference_type
        x: std::vector< std::array< float,4 > >::value_type const &

        """
        return _nvisii.Float4Vector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> Float4"""
        return _nvisii.Float4Vector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::array< float,4 > >::value_type const &

        """
        return _nvisii.Float4Vector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.Float4Vector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::array< float,4 > >::size_type"""
        return _nvisii.Float4Vector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::array< float,4 > > &

        """
        return _nvisii.Float4Vector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::array< float,4 > >::iterator"""
        return _nvisii.Float4Vector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::array< float,4 > >::iterator"""
        return _nvisii.Float4Vector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::array< float,4 > >::reverse_iterator"""
        return _nvisii.Float4Vector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::array< float,4 > >::reverse_iterator"""
        return _nvisii.Float4Vector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.Float4Vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::array< float,4 > >::allocator_type"""
        return _nvisii.Float4Vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.Float4Vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::array< float,4 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::array< float,4 > >::iterator

        erase(self, first, last) -> std::vector< std::array< float,4 > >::iterator

        Parameters
        ----------
        first: std::vector< std::array< float,4 > >::iterator
        last: std::vector< std::array< float,4 > >::iterator

        """
        return _nvisii.Float4Vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> Float4Vector
        __init__(self, other) -> Float4Vector

        Parameters
        ----------
        other: std::vector< std::array< float,4 > > const &

        __init__(self, size) -> Float4Vector

        Parameters
        ----------
        size: std::vector< std::array< float,4 > >::size_type

        __init__(self, size, value) -> Float4Vector

        Parameters
        ----------
        size: std::vector< std::array< float,4 > >::size_type
        value: std::vector< std::array< float,4 > >::value_type const &

        """
        _nvisii.Float4Vector_swiginit(self, _nvisii.new_Float4Vector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::array< float,4 > >::value_type const &

        """
        return _nvisii.Float4Vector_push_back(self, x)

    def front(self):
        r"""front(self) -> Float4"""
        return _nvisii.Float4Vector_front(self)

    def back(self):
        r"""back(self) -> Float4"""
        return _nvisii.Float4Vector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::array< float,4 > >::size_type
        x: std::vector< std::array< float,4 > >::value_type const &

        """
        return _nvisii.Float4Vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::array< float,4 > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::array< float,4 > >::size_type
        x: std::vector< std::array< float,4 > >::value_type const &

        """
        return _nvisii.Float4Vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::array< float,4 > >::iterator

        Parameters
        ----------
        pos: std::vector< std::array< float,4 > >::iterator
        x: std::vector< std::array< float,4 > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::array< float,4 > >::iterator
        n: std::vector< std::array< float,4 > >::size_type
        x: std::vector< std::array< float,4 > >::value_type const &

        """
        return _nvisii.Float4Vector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::array< float,4 > >::size_type

        """
        return _nvisii.Float4Vector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::array< float,4 > >::size_type"""
        return _nvisii.Float4Vector_capacity(self)
    __swig_destroy__ = _nvisii.delete_Float4Vector

# Register Float4Vector in _nvisii:
_nvisii.Float4Vector_swigregister(Float4Vector)

class UINT32Vector(object):
    r"""Proxy of C++ std::vector< uint32_t > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.UINT32Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.UINT32Vector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.UINT32Vector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< unsigned int >::size_type"""
        return _nvisii.UINT32Vector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> UINT32Vector

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        j: std::vector< unsigned int >::difference_type

        """
        return _nvisii.UINT32Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        j: std::vector< unsigned int >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        j: std::vector< unsigned int >::difference_type
        v: std::vector< unsigned int,std::allocator< unsigned int > > const &

        """
        return _nvisii.UINT32Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        j: std::vector< unsigned int >::difference_type

        """
        return _nvisii.UINT32Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.UINT32Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> UINT32Vector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> std::vector< unsigned int >::value_type const &

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type

        """
        return _nvisii.UINT32Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< unsigned int,std::allocator< unsigned int > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        x: std::vector< unsigned int >::value_type const &

        """
        return _nvisii.UINT32Vector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< unsigned int >::value_type"""
        return _nvisii.UINT32Vector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< unsigned int >::value_type const &

        """
        return _nvisii.UINT32Vector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.UINT32Vector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< unsigned int >::size_type"""
        return _nvisii.UINT32Vector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< uint32_t > &

        """
        return _nvisii.UINT32Vector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< unsigned int >::iterator"""
        return _nvisii.UINT32Vector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< unsigned int >::iterator"""
        return _nvisii.UINT32Vector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< unsigned int >::reverse_iterator"""
        return _nvisii.UINT32Vector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< unsigned int >::reverse_iterator"""
        return _nvisii.UINT32Vector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.UINT32Vector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< unsigned int >::allocator_type"""
        return _nvisii.UINT32Vector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.UINT32Vector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< unsigned int >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned int >::iterator

        erase(self, first, last) -> std::vector< unsigned int >::iterator

        Parameters
        ----------
        first: std::vector< unsigned int >::iterator
        last: std::vector< unsigned int >::iterator

        """
        return _nvisii.UINT32Vector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> UINT32Vector
        __init__(self, other) -> UINT32Vector

        Parameters
        ----------
        other: std::vector< uint32_t > const &

        __init__(self, size) -> UINT32Vector

        Parameters
        ----------
        size: std::vector< unsigned int >::size_type

        __init__(self, size, value) -> UINT32Vector

        Parameters
        ----------
        size: std::vector< unsigned int >::size_type
        value: std::vector< unsigned int >::value_type const &

        """
        _nvisii.UINT32Vector_swiginit(self, _nvisii.new_UINT32Vector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< unsigned int >::value_type const &

        """
        return _nvisii.UINT32Vector_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< unsigned int >::value_type const &"""
        return _nvisii.UINT32Vector_front(self)

    def back(self):
        r"""back(self) -> std::vector< unsigned int >::value_type const &"""
        return _nvisii.UINT32Vector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< unsigned int >::size_type
        x: std::vector< unsigned int >::value_type const &

        """
        return _nvisii.UINT32Vector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< unsigned int >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< unsigned int >::size_type
        x: std::vector< unsigned int >::value_type const &

        """
        return _nvisii.UINT32Vector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< unsigned int >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned int >::iterator
        x: std::vector< unsigned int >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< unsigned int >::iterator
        n: std::vector< unsigned int >::size_type
        x: std::vector< unsigned int >::value_type const &

        """
        return _nvisii.UINT32Vector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< unsigned int >::size_type

        """
        return _nvisii.UINT32Vector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< unsigned int >::size_type"""
        return _nvisii.UINT32Vector_capacity(self)
    __swig_destroy__ = _nvisii.delete_UINT32Vector

# Register UINT32Vector in _nvisii:
_nvisii.UINT32Vector_swigregister(UINT32Vector)

class StringVector(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.StringVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.StringVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::string >::size_type"""
        return _nvisii.StringVector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> StringVector

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        """
        return _nvisii.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type
        v: std::vector< std::string,std::allocator< std::string > > const &

        """
        return _nvisii.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        """
        return _nvisii.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> StringVector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> std::vector< std::string >::value_type const &

        Parameters
        ----------
        i: std::vector< std::string >::difference_type

        """
        return _nvisii.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::string,std::allocator< std::string > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        x: std::vector< std::string >::value_type const &

        """
        return _nvisii.StringVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< std::string >::value_type"""
        return _nvisii.StringVector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::string >::value_type const &

        """
        return _nvisii.StringVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.StringVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::string >::size_type"""
        return _nvisii.StringVector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::string > &

        """
        return _nvisii.StringVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::string >::iterator"""
        return _nvisii.StringVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::string >::iterator"""
        return _nvisii.StringVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::string >::reverse_iterator"""
        return _nvisii.StringVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::string >::reverse_iterator"""
        return _nvisii.StringVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.StringVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::string >::allocator_type"""
        return _nvisii.StringVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.StringVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::string >::iterator

        Parameters
        ----------
        pos: std::vector< std::string >::iterator

        erase(self, first, last) -> std::vector< std::string >::iterator

        Parameters
        ----------
        first: std::vector< std::string >::iterator
        last: std::vector< std::string >::iterator

        """
        return _nvisii.StringVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> StringVector
        __init__(self, other) -> StringVector

        Parameters
        ----------
        other: std::vector< std::string > const &

        __init__(self, size) -> StringVector

        Parameters
        ----------
        size: std::vector< std::string >::size_type

        __init__(self, size, value) -> StringVector

        Parameters
        ----------
        size: std::vector< std::string >::size_type
        value: std::vector< std::string >::value_type const &

        """
        _nvisii.StringVector_swiginit(self, _nvisii.new_StringVector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::string >::value_type const &

        """
        return _nvisii.StringVector_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< std::string >::value_type const &"""
        return _nvisii.StringVector_front(self)

    def back(self):
        r"""back(self) -> std::vector< std::string >::value_type const &"""
        return _nvisii.StringVector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _nvisii.StringVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::string >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _nvisii.StringVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::string >::iterator

        Parameters
        ----------
        pos: std::vector< std::string >::iterator
        x: std::vector< std::string >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::string >::iterator
        n: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _nvisii.StringVector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::string >::size_type

        """
        return _nvisii.StringVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::string >::size_type"""
        return _nvisii.StringVector_capacity(self)
    __swig_destroy__ = _nvisii.delete_StringVector

# Register StringVector in _nvisii:
_nvisii.StringVector_swigregister(StringVector)

class EntityVector(object):
    r"""Proxy of C++ std::vector< nvisii::Entity * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.EntityVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.EntityVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.EntityVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< nvisii::Entity * >::size_type"""
        return _nvisii.EntityVector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> EntityVector

        Parameters
        ----------
        i: std::vector< nvisii::Entity * >::difference_type
        j: std::vector< nvisii::Entity * >::difference_type

        """
        return _nvisii.EntityVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Entity * >::difference_type
        j: std::vector< nvisii::Entity * >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< nvisii::Entity * >::difference_type
        j: std::vector< nvisii::Entity * >::difference_type
        v: std::vector< nvisii::Entity *,std::allocator< nvisii::Entity * > > const &

        """
        return _nvisii.EntityVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Entity * >::difference_type
        j: std::vector< nvisii::Entity * >::difference_type

        """
        return _nvisii.EntityVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< nvisii::Entity * >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.EntityVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> EntityVector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> entity

        Parameters
        ----------
        i: std::vector< nvisii::Entity * >::difference_type

        """
        return _nvisii.EntityVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< nvisii::Entity *,std::allocator< nvisii::Entity * > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< nvisii::Entity * >::difference_type
        x: std::vector< nvisii::Entity * >::value_type

        """
        return _nvisii.EntityVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> entity"""
        return _nvisii.EntityVector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Entity * >::value_type

        """
        return _nvisii.EntityVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.EntityVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< nvisii::Entity * >::size_type"""
        return _nvisii.EntityVector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< nvisii::Entity * > &

        """
        return _nvisii.EntityVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< nvisii::Entity * >::iterator"""
        return _nvisii.EntityVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< nvisii::Entity * >::iterator"""
        return _nvisii.EntityVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< nvisii::Entity * >::reverse_iterator"""
        return _nvisii.EntityVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< nvisii::Entity * >::reverse_iterator"""
        return _nvisii.EntityVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.EntityVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< nvisii::Entity * >::allocator_type"""
        return _nvisii.EntityVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.EntityVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< nvisii::Entity * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Entity * >::iterator

        erase(self, first, last) -> std::vector< nvisii::Entity * >::iterator

        Parameters
        ----------
        first: std::vector< nvisii::Entity * >::iterator
        last: std::vector< nvisii::Entity * >::iterator

        """
        return _nvisii.EntityVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> EntityVector
        __init__(self, other) -> EntityVector

        Parameters
        ----------
        other: std::vector< nvisii::Entity * > const &

        __init__(self, size) -> EntityVector

        Parameters
        ----------
        size: std::vector< nvisii::Entity * >::size_type

        __init__(self, size, value) -> EntityVector

        Parameters
        ----------
        size: std::vector< nvisii::Entity * >::size_type
        value: std::vector< nvisii::Entity * >::value_type

        """
        _nvisii.EntityVector_swiginit(self, _nvisii.new_EntityVector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Entity * >::value_type

        """
        return _nvisii.EntityVector_push_back(self, x)

    def front(self):
        r"""front(self) -> entity"""
        return _nvisii.EntityVector_front(self)

    def back(self):
        r"""back(self) -> entity"""
        return _nvisii.EntityVector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< nvisii::Entity * >::size_type
        x: std::vector< nvisii::Entity * >::value_type

        """
        return _nvisii.EntityVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< nvisii::Entity * >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< nvisii::Entity * >::size_type
        x: std::vector< nvisii::Entity * >::value_type

        """
        return _nvisii.EntityVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< nvisii::Entity * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Entity * >::iterator
        x: std::vector< nvisii::Entity * >::value_type

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< nvisii::Entity * >::iterator
        n: std::vector< nvisii::Entity * >::size_type
        x: std::vector< nvisii::Entity * >::value_type

        """
        return _nvisii.EntityVector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< nvisii::Entity * >::size_type

        """
        return _nvisii.EntityVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< nvisii::Entity * >::size_type"""
        return _nvisii.EntityVector_capacity(self)
    __swig_destroy__ = _nvisii.delete_EntityVector

# Register EntityVector in _nvisii:
_nvisii.EntityVector_swigregister(EntityVector)

class TransformVector(object):
    r"""Proxy of C++ std::vector< nvisii::Transform * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.TransformVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.TransformVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.TransformVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< nvisii::Transform * >::size_type"""
        return _nvisii.TransformVector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> TransformVector

        Parameters
        ----------
        i: std::vector< nvisii::Transform * >::difference_type
        j: std::vector< nvisii::Transform * >::difference_type

        """
        return _nvisii.TransformVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Transform * >::difference_type
        j: std::vector< nvisii::Transform * >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< nvisii::Transform * >::difference_type
        j: std::vector< nvisii::Transform * >::difference_type
        v: std::vector< nvisii::Transform *,std::allocator< nvisii::Transform * > > const &

        """
        return _nvisii.TransformVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Transform * >::difference_type
        j: std::vector< nvisii::Transform * >::difference_type

        """
        return _nvisii.TransformVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< nvisii::Transform * >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.TransformVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> TransformVector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> transform

        Parameters
        ----------
        i: std::vector< nvisii::Transform * >::difference_type

        """
        return _nvisii.TransformVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< nvisii::Transform *,std::allocator< nvisii::Transform * > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< nvisii::Transform * >::difference_type
        x: std::vector< nvisii::Transform * >::value_type

        """
        return _nvisii.TransformVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> transform"""
        return _nvisii.TransformVector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Transform * >::value_type

        """
        return _nvisii.TransformVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.TransformVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< nvisii::Transform * >::size_type"""
        return _nvisii.TransformVector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< nvisii::Transform * > &

        """
        return _nvisii.TransformVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< nvisii::Transform * >::iterator"""
        return _nvisii.TransformVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< nvisii::Transform * >::iterator"""
        return _nvisii.TransformVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< nvisii::Transform * >::reverse_iterator"""
        return _nvisii.TransformVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< nvisii::Transform * >::reverse_iterator"""
        return _nvisii.TransformVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.TransformVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< nvisii::Transform * >::allocator_type"""
        return _nvisii.TransformVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.TransformVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< nvisii::Transform * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Transform * >::iterator

        erase(self, first, last) -> std::vector< nvisii::Transform * >::iterator

        Parameters
        ----------
        first: std::vector< nvisii::Transform * >::iterator
        last: std::vector< nvisii::Transform * >::iterator

        """
        return _nvisii.TransformVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> TransformVector
        __init__(self, other) -> TransformVector

        Parameters
        ----------
        other: std::vector< nvisii::Transform * > const &

        __init__(self, size) -> TransformVector

        Parameters
        ----------
        size: std::vector< nvisii::Transform * >::size_type

        __init__(self, size, value) -> TransformVector

        Parameters
        ----------
        size: std::vector< nvisii::Transform * >::size_type
        value: std::vector< nvisii::Transform * >::value_type

        """
        _nvisii.TransformVector_swiginit(self, _nvisii.new_TransformVector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Transform * >::value_type

        """
        return _nvisii.TransformVector_push_back(self, x)

    def front(self):
        r"""front(self) -> transform"""
        return _nvisii.TransformVector_front(self)

    def back(self):
        r"""back(self) -> transform"""
        return _nvisii.TransformVector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< nvisii::Transform * >::size_type
        x: std::vector< nvisii::Transform * >::value_type

        """
        return _nvisii.TransformVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< nvisii::Transform * >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< nvisii::Transform * >::size_type
        x: std::vector< nvisii::Transform * >::value_type

        """
        return _nvisii.TransformVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< nvisii::Transform * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Transform * >::iterator
        x: std::vector< nvisii::Transform * >::value_type

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< nvisii::Transform * >::iterator
        n: std::vector< nvisii::Transform * >::size_type
        x: std::vector< nvisii::Transform * >::value_type

        """
        return _nvisii.TransformVector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< nvisii::Transform * >::size_type

        """
        return _nvisii.TransformVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< nvisii::Transform * >::size_type"""
        return _nvisii.TransformVector_capacity(self)
    __swig_destroy__ = _nvisii.delete_TransformVector

# Register TransformVector in _nvisii:
_nvisii.TransformVector_swigregister(TransformVector)

class MeshVector(object):
    r"""Proxy of C++ std::vector< nvisii::Mesh * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.MeshVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.MeshVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.MeshVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< nvisii::Mesh * >::size_type"""
        return _nvisii.MeshVector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> MeshVector

        Parameters
        ----------
        i: std::vector< nvisii::Mesh * >::difference_type
        j: std::vector< nvisii::Mesh * >::difference_type

        """
        return _nvisii.MeshVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Mesh * >::difference_type
        j: std::vector< nvisii::Mesh * >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< nvisii::Mesh * >::difference_type
        j: std::vector< nvisii::Mesh * >::difference_type
        v: std::vector< nvisii::Mesh *,std::allocator< nvisii::Mesh * > > const &

        """
        return _nvisii.MeshVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Mesh * >::difference_type
        j: std::vector< nvisii::Mesh * >::difference_type

        """
        return _nvisii.MeshVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< nvisii::Mesh * >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.MeshVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> MeshVector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> mesh

        Parameters
        ----------
        i: std::vector< nvisii::Mesh * >::difference_type

        """
        return _nvisii.MeshVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< nvisii::Mesh *,std::allocator< nvisii::Mesh * > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< nvisii::Mesh * >::difference_type
        x: std::vector< nvisii::Mesh * >::value_type

        """
        return _nvisii.MeshVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> mesh"""
        return _nvisii.MeshVector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Mesh * >::value_type

        """
        return _nvisii.MeshVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.MeshVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< nvisii::Mesh * >::size_type"""
        return _nvisii.MeshVector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< nvisii::Mesh * > &

        """
        return _nvisii.MeshVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< nvisii::Mesh * >::iterator"""
        return _nvisii.MeshVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< nvisii::Mesh * >::iterator"""
        return _nvisii.MeshVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< nvisii::Mesh * >::reverse_iterator"""
        return _nvisii.MeshVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< nvisii::Mesh * >::reverse_iterator"""
        return _nvisii.MeshVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.MeshVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< nvisii::Mesh * >::allocator_type"""
        return _nvisii.MeshVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.MeshVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< nvisii::Mesh * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Mesh * >::iterator

        erase(self, first, last) -> std::vector< nvisii::Mesh * >::iterator

        Parameters
        ----------
        first: std::vector< nvisii::Mesh * >::iterator
        last: std::vector< nvisii::Mesh * >::iterator

        """
        return _nvisii.MeshVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> MeshVector
        __init__(self, other) -> MeshVector

        Parameters
        ----------
        other: std::vector< nvisii::Mesh * > const &

        __init__(self, size) -> MeshVector

        Parameters
        ----------
        size: std::vector< nvisii::Mesh * >::size_type

        __init__(self, size, value) -> MeshVector

        Parameters
        ----------
        size: std::vector< nvisii::Mesh * >::size_type
        value: std::vector< nvisii::Mesh * >::value_type

        """
        _nvisii.MeshVector_swiginit(self, _nvisii.new_MeshVector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Mesh * >::value_type

        """
        return _nvisii.MeshVector_push_back(self, x)

    def front(self):
        r"""front(self) -> mesh"""
        return _nvisii.MeshVector_front(self)

    def back(self):
        r"""back(self) -> mesh"""
        return _nvisii.MeshVector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< nvisii::Mesh * >::size_type
        x: std::vector< nvisii::Mesh * >::value_type

        """
        return _nvisii.MeshVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< nvisii::Mesh * >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< nvisii::Mesh * >::size_type
        x: std::vector< nvisii::Mesh * >::value_type

        """
        return _nvisii.MeshVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< nvisii::Mesh * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Mesh * >::iterator
        x: std::vector< nvisii::Mesh * >::value_type

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< nvisii::Mesh * >::iterator
        n: std::vector< nvisii::Mesh * >::size_type
        x: std::vector< nvisii::Mesh * >::value_type

        """
        return _nvisii.MeshVector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< nvisii::Mesh * >::size_type

        """
        return _nvisii.MeshVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< nvisii::Mesh * >::size_type"""
        return _nvisii.MeshVector_capacity(self)
    __swig_destroy__ = _nvisii.delete_MeshVector

# Register MeshVector in _nvisii:
_nvisii.MeshVector_swigregister(MeshVector)

class CameraVector(object):
    r"""Proxy of C++ std::vector< nvisii::Camera * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.CameraVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.CameraVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.CameraVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< nvisii::Camera * >::size_type"""
        return _nvisii.CameraVector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> CameraVector

        Parameters
        ----------
        i: std::vector< nvisii::Camera * >::difference_type
        j: std::vector< nvisii::Camera * >::difference_type

        """
        return _nvisii.CameraVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Camera * >::difference_type
        j: std::vector< nvisii::Camera * >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< nvisii::Camera * >::difference_type
        j: std::vector< nvisii::Camera * >::difference_type
        v: std::vector< nvisii::Camera *,std::allocator< nvisii::Camera * > > const &

        """
        return _nvisii.CameraVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Camera * >::difference_type
        j: std::vector< nvisii::Camera * >::difference_type

        """
        return _nvisii.CameraVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< nvisii::Camera * >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.CameraVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> CameraVector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> camera

        Parameters
        ----------
        i: std::vector< nvisii::Camera * >::difference_type

        """
        return _nvisii.CameraVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< nvisii::Camera *,std::allocator< nvisii::Camera * > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< nvisii::Camera * >::difference_type
        x: std::vector< nvisii::Camera * >::value_type

        """
        return _nvisii.CameraVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> camera"""
        return _nvisii.CameraVector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Camera * >::value_type

        """
        return _nvisii.CameraVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.CameraVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< nvisii::Camera * >::size_type"""
        return _nvisii.CameraVector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< nvisii::Camera * > &

        """
        return _nvisii.CameraVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< nvisii::Camera * >::iterator"""
        return _nvisii.CameraVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< nvisii::Camera * >::iterator"""
        return _nvisii.CameraVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< nvisii::Camera * >::reverse_iterator"""
        return _nvisii.CameraVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< nvisii::Camera * >::reverse_iterator"""
        return _nvisii.CameraVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.CameraVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< nvisii::Camera * >::allocator_type"""
        return _nvisii.CameraVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.CameraVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< nvisii::Camera * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Camera * >::iterator

        erase(self, first, last) -> std::vector< nvisii::Camera * >::iterator

        Parameters
        ----------
        first: std::vector< nvisii::Camera * >::iterator
        last: std::vector< nvisii::Camera * >::iterator

        """
        return _nvisii.CameraVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> CameraVector
        __init__(self, other) -> CameraVector

        Parameters
        ----------
        other: std::vector< nvisii::Camera * > const &

        __init__(self, size) -> CameraVector

        Parameters
        ----------
        size: std::vector< nvisii::Camera * >::size_type

        __init__(self, size, value) -> CameraVector

        Parameters
        ----------
        size: std::vector< nvisii::Camera * >::size_type
        value: std::vector< nvisii::Camera * >::value_type

        """
        _nvisii.CameraVector_swiginit(self, _nvisii.new_CameraVector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Camera * >::value_type

        """
        return _nvisii.CameraVector_push_back(self, x)

    def front(self):
        r"""front(self) -> camera"""
        return _nvisii.CameraVector_front(self)

    def back(self):
        r"""back(self) -> camera"""
        return _nvisii.CameraVector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< nvisii::Camera * >::size_type
        x: std::vector< nvisii::Camera * >::value_type

        """
        return _nvisii.CameraVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< nvisii::Camera * >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< nvisii::Camera * >::size_type
        x: std::vector< nvisii::Camera * >::value_type

        """
        return _nvisii.CameraVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< nvisii::Camera * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Camera * >::iterator
        x: std::vector< nvisii::Camera * >::value_type

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< nvisii::Camera * >::iterator
        n: std::vector< nvisii::Camera * >::size_type
        x: std::vector< nvisii::Camera * >::value_type

        """
        return _nvisii.CameraVector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< nvisii::Camera * >::size_type

        """
        return _nvisii.CameraVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< nvisii::Camera * >::size_type"""
        return _nvisii.CameraVector_capacity(self)
    __swig_destroy__ = _nvisii.delete_CameraVector

# Register CameraVector in _nvisii:
_nvisii.CameraVector_swigregister(CameraVector)

class TextureVector(object):
    r"""Proxy of C++ std::vector< nvisii::Texture * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.TextureVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.TextureVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.TextureVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< nvisii::Texture * >::size_type"""
        return _nvisii.TextureVector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> TextureVector

        Parameters
        ----------
        i: std::vector< nvisii::Texture * >::difference_type
        j: std::vector< nvisii::Texture * >::difference_type

        """
        return _nvisii.TextureVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Texture * >::difference_type
        j: std::vector< nvisii::Texture * >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< nvisii::Texture * >::difference_type
        j: std::vector< nvisii::Texture * >::difference_type
        v: std::vector< nvisii::Texture *,std::allocator< nvisii::Texture * > > const &

        """
        return _nvisii.TextureVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Texture * >::difference_type
        j: std::vector< nvisii::Texture * >::difference_type

        """
        return _nvisii.TextureVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< nvisii::Texture * >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.TextureVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> TextureVector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> texture

        Parameters
        ----------
        i: std::vector< nvisii::Texture * >::difference_type

        """
        return _nvisii.TextureVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< nvisii::Texture *,std::allocator< nvisii::Texture * > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< nvisii::Texture * >::difference_type
        x: std::vector< nvisii::Texture * >::value_type

        """
        return _nvisii.TextureVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> texture"""
        return _nvisii.TextureVector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Texture * >::value_type

        """
        return _nvisii.TextureVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.TextureVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< nvisii::Texture * >::size_type"""
        return _nvisii.TextureVector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< nvisii::Texture * > &

        """
        return _nvisii.TextureVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< nvisii::Texture * >::iterator"""
        return _nvisii.TextureVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< nvisii::Texture * >::iterator"""
        return _nvisii.TextureVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< nvisii::Texture * >::reverse_iterator"""
        return _nvisii.TextureVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< nvisii::Texture * >::reverse_iterator"""
        return _nvisii.TextureVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.TextureVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< nvisii::Texture * >::allocator_type"""
        return _nvisii.TextureVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.TextureVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< nvisii::Texture * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Texture * >::iterator

        erase(self, first, last) -> std::vector< nvisii::Texture * >::iterator

        Parameters
        ----------
        first: std::vector< nvisii::Texture * >::iterator
        last: std::vector< nvisii::Texture * >::iterator

        """
        return _nvisii.TextureVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> TextureVector
        __init__(self, other) -> TextureVector

        Parameters
        ----------
        other: std::vector< nvisii::Texture * > const &

        __init__(self, size) -> TextureVector

        Parameters
        ----------
        size: std::vector< nvisii::Texture * >::size_type

        __init__(self, size, value) -> TextureVector

        Parameters
        ----------
        size: std::vector< nvisii::Texture * >::size_type
        value: std::vector< nvisii::Texture * >::value_type

        """
        _nvisii.TextureVector_swiginit(self, _nvisii.new_TextureVector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Texture * >::value_type

        """
        return _nvisii.TextureVector_push_back(self, x)

    def front(self):
        r"""front(self) -> texture"""
        return _nvisii.TextureVector_front(self)

    def back(self):
        r"""back(self) -> texture"""
        return _nvisii.TextureVector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< nvisii::Texture * >::size_type
        x: std::vector< nvisii::Texture * >::value_type

        """
        return _nvisii.TextureVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< nvisii::Texture * >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< nvisii::Texture * >::size_type
        x: std::vector< nvisii::Texture * >::value_type

        """
        return _nvisii.TextureVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< nvisii::Texture * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Texture * >::iterator
        x: std::vector< nvisii::Texture * >::value_type

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< nvisii::Texture * >::iterator
        n: std::vector< nvisii::Texture * >::size_type
        x: std::vector< nvisii::Texture * >::value_type

        """
        return _nvisii.TextureVector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< nvisii::Texture * >::size_type

        """
        return _nvisii.TextureVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< nvisii::Texture * >::size_type"""
        return _nvisii.TextureVector_capacity(self)
    __swig_destroy__ = _nvisii.delete_TextureVector

# Register TextureVector in _nvisii:
_nvisii.TextureVector_swigregister(TextureVector)

class LightVector(object):
    r"""Proxy of C++ std::vector< nvisii::Light * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.LightVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.LightVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.LightVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< nvisii::Light * >::size_type"""
        return _nvisii.LightVector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> LightVector

        Parameters
        ----------
        i: std::vector< nvisii::Light * >::difference_type
        j: std::vector< nvisii::Light * >::difference_type

        """
        return _nvisii.LightVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Light * >::difference_type
        j: std::vector< nvisii::Light * >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< nvisii::Light * >::difference_type
        j: std::vector< nvisii::Light * >::difference_type
        v: std::vector< nvisii::Light *,std::allocator< nvisii::Light * > > const &

        """
        return _nvisii.LightVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Light * >::difference_type
        j: std::vector< nvisii::Light * >::difference_type

        """
        return _nvisii.LightVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< nvisii::Light * >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.LightVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> LightVector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> light

        Parameters
        ----------
        i: std::vector< nvisii::Light * >::difference_type

        """
        return _nvisii.LightVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< nvisii::Light *,std::allocator< nvisii::Light * > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< nvisii::Light * >::difference_type
        x: std::vector< nvisii::Light * >::value_type

        """
        return _nvisii.LightVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> light"""
        return _nvisii.LightVector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Light * >::value_type

        """
        return _nvisii.LightVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.LightVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< nvisii::Light * >::size_type"""
        return _nvisii.LightVector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< nvisii::Light * > &

        """
        return _nvisii.LightVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< nvisii::Light * >::iterator"""
        return _nvisii.LightVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< nvisii::Light * >::iterator"""
        return _nvisii.LightVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< nvisii::Light * >::reverse_iterator"""
        return _nvisii.LightVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< nvisii::Light * >::reverse_iterator"""
        return _nvisii.LightVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.LightVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< nvisii::Light * >::allocator_type"""
        return _nvisii.LightVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.LightVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< nvisii::Light * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Light * >::iterator

        erase(self, first, last) -> std::vector< nvisii::Light * >::iterator

        Parameters
        ----------
        first: std::vector< nvisii::Light * >::iterator
        last: std::vector< nvisii::Light * >::iterator

        """
        return _nvisii.LightVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> LightVector
        __init__(self, other) -> LightVector

        Parameters
        ----------
        other: std::vector< nvisii::Light * > const &

        __init__(self, size) -> LightVector

        Parameters
        ----------
        size: std::vector< nvisii::Light * >::size_type

        __init__(self, size, value) -> LightVector

        Parameters
        ----------
        size: std::vector< nvisii::Light * >::size_type
        value: std::vector< nvisii::Light * >::value_type

        """
        _nvisii.LightVector_swiginit(self, _nvisii.new_LightVector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Light * >::value_type

        """
        return _nvisii.LightVector_push_back(self, x)

    def front(self):
        r"""front(self) -> light"""
        return _nvisii.LightVector_front(self)

    def back(self):
        r"""back(self) -> light"""
        return _nvisii.LightVector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< nvisii::Light * >::size_type
        x: std::vector< nvisii::Light * >::value_type

        """
        return _nvisii.LightVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< nvisii::Light * >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< nvisii::Light * >::size_type
        x: std::vector< nvisii::Light * >::value_type

        """
        return _nvisii.LightVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< nvisii::Light * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Light * >::iterator
        x: std::vector< nvisii::Light * >::value_type

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< nvisii::Light * >::iterator
        n: std::vector< nvisii::Light * >::size_type
        x: std::vector< nvisii::Light * >::value_type

        """
        return _nvisii.LightVector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< nvisii::Light * >::size_type

        """
        return _nvisii.LightVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< nvisii::Light * >::size_type"""
        return _nvisii.LightVector_capacity(self)
    __swig_destroy__ = _nvisii.delete_LightVector

# Register LightVector in _nvisii:
_nvisii.LightVector_swigregister(LightVector)

class MaterialVector(object):
    r"""Proxy of C++ std::vector< nvisii::Material * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.MaterialVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.MaterialVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.MaterialVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< nvisii::Material * >::size_type"""
        return _nvisii.MaterialVector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> MaterialVector

        Parameters
        ----------
        i: std::vector< nvisii::Material * >::difference_type
        j: std::vector< nvisii::Material * >::difference_type

        """
        return _nvisii.MaterialVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Material * >::difference_type
        j: std::vector< nvisii::Material * >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< nvisii::Material * >::difference_type
        j: std::vector< nvisii::Material * >::difference_type
        v: std::vector< nvisii::Material *,std::allocator< nvisii::Material * > > const &

        """
        return _nvisii.MaterialVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Material * >::difference_type
        j: std::vector< nvisii::Material * >::difference_type

        """
        return _nvisii.MaterialVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< nvisii::Material * >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.MaterialVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> MaterialVector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> material

        Parameters
        ----------
        i: std::vector< nvisii::Material * >::difference_type

        """
        return _nvisii.MaterialVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< nvisii::Material *,std::allocator< nvisii::Material * > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< nvisii::Material * >::difference_type
        x: std::vector< nvisii::Material * >::value_type

        """
        return _nvisii.MaterialVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> material"""
        return _nvisii.MaterialVector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Material * >::value_type

        """
        return _nvisii.MaterialVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.MaterialVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< nvisii::Material * >::size_type"""
        return _nvisii.MaterialVector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< nvisii::Material * > &

        """
        return _nvisii.MaterialVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< nvisii::Material * >::iterator"""
        return _nvisii.MaterialVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< nvisii::Material * >::iterator"""
        return _nvisii.MaterialVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< nvisii::Material * >::reverse_iterator"""
        return _nvisii.MaterialVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< nvisii::Material * >::reverse_iterator"""
        return _nvisii.MaterialVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.MaterialVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< nvisii::Material * >::allocator_type"""
        return _nvisii.MaterialVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.MaterialVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< nvisii::Material * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Material * >::iterator

        erase(self, first, last) -> std::vector< nvisii::Material * >::iterator

        Parameters
        ----------
        first: std::vector< nvisii::Material * >::iterator
        last: std::vector< nvisii::Material * >::iterator

        """
        return _nvisii.MaterialVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> MaterialVector
        __init__(self, other) -> MaterialVector

        Parameters
        ----------
        other: std::vector< nvisii::Material * > const &

        __init__(self, size) -> MaterialVector

        Parameters
        ----------
        size: std::vector< nvisii::Material * >::size_type

        __init__(self, size, value) -> MaterialVector

        Parameters
        ----------
        size: std::vector< nvisii::Material * >::size_type
        value: std::vector< nvisii::Material * >::value_type

        """
        _nvisii.MaterialVector_swiginit(self, _nvisii.new_MaterialVector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Material * >::value_type

        """
        return _nvisii.MaterialVector_push_back(self, x)

    def front(self):
        r"""front(self) -> material"""
        return _nvisii.MaterialVector_front(self)

    def back(self):
        r"""back(self) -> material"""
        return _nvisii.MaterialVector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< nvisii::Material * >::size_type
        x: std::vector< nvisii::Material * >::value_type

        """
        return _nvisii.MaterialVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< nvisii::Material * >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< nvisii::Material * >::size_type
        x: std::vector< nvisii::Material * >::value_type

        """
        return _nvisii.MaterialVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< nvisii::Material * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Material * >::iterator
        x: std::vector< nvisii::Material * >::value_type

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< nvisii::Material * >::iterator
        n: std::vector< nvisii::Material * >::size_type
        x: std::vector< nvisii::Material * >::value_type

        """
        return _nvisii.MaterialVector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< nvisii::Material * >::size_type

        """
        return _nvisii.MaterialVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< nvisii::Material * >::size_type"""
        return _nvisii.MaterialVector_capacity(self)
    __swig_destroy__ = _nvisii.delete_MaterialVector

# Register MaterialVector in _nvisii:
_nvisii.MaterialVector_swigregister(MaterialVector)

class VolumeVector(object):
    r"""Proxy of C++ std::vector< nvisii::Volume * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _nvisii.VolumeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _nvisii.VolumeVector___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _nvisii.VolumeVector___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< nvisii::Volume * >::size_type"""
        return _nvisii.VolumeVector___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> VolumeVector

        Parameters
        ----------
        i: std::vector< nvisii::Volume * >::difference_type
        j: std::vector< nvisii::Volume * >::difference_type

        """
        return _nvisii.VolumeVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Volume * >::difference_type
        j: std::vector< nvisii::Volume * >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< nvisii::Volume * >::difference_type
        j: std::vector< nvisii::Volume * >::difference_type
        v: std::vector< nvisii::Volume *,std::allocator< nvisii::Volume * > > const &

        """
        return _nvisii.VolumeVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< nvisii::Volume * >::difference_type
        j: std::vector< nvisii::Volume * >::difference_type

        """
        return _nvisii.VolumeVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< nvisii::Volume * >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _nvisii.VolumeVector___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> VolumeVector

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(self, i) -> volume

        Parameters
        ----------
        i: std::vector< nvisii::Volume * >::difference_type

        """
        return _nvisii.VolumeVector___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< nvisii::Volume *,std::allocator< nvisii::Volume * > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< nvisii::Volume * >::difference_type
        x: std::vector< nvisii::Volume * >::value_type

        """
        return _nvisii.VolumeVector___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> volume"""
        return _nvisii.VolumeVector_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Volume * >::value_type

        """
        return _nvisii.VolumeVector_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _nvisii.VolumeVector_empty(self)

    def size(self):
        r"""size(self) -> std::vector< nvisii::Volume * >::size_type"""
        return _nvisii.VolumeVector_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< nvisii::Volume * > &

        """
        return _nvisii.VolumeVector_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< nvisii::Volume * >::iterator"""
        return _nvisii.VolumeVector_begin(self)

    def end(self):
        r"""end(self) -> std::vector< nvisii::Volume * >::iterator"""
        return _nvisii.VolumeVector_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< nvisii::Volume * >::reverse_iterator"""
        return _nvisii.VolumeVector_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< nvisii::Volume * >::reverse_iterator"""
        return _nvisii.VolumeVector_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _nvisii.VolumeVector_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< nvisii::Volume * >::allocator_type"""
        return _nvisii.VolumeVector_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _nvisii.VolumeVector_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< nvisii::Volume * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Volume * >::iterator

        erase(self, first, last) -> std::vector< nvisii::Volume * >::iterator

        Parameters
        ----------
        first: std::vector< nvisii::Volume * >::iterator
        last: std::vector< nvisii::Volume * >::iterator

        """
        return _nvisii.VolumeVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> VolumeVector
        __init__(self, other) -> VolumeVector

        Parameters
        ----------
        other: std::vector< nvisii::Volume * > const &

        __init__(self, size) -> VolumeVector

        Parameters
        ----------
        size: std::vector< nvisii::Volume * >::size_type

        __init__(self, size, value) -> VolumeVector

        Parameters
        ----------
        size: std::vector< nvisii::Volume * >::size_type
        value: std::vector< nvisii::Volume * >::value_type

        """
        _nvisii.VolumeVector_swiginit(self, _nvisii.new_VolumeVector(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< nvisii::Volume * >::value_type

        """
        return _nvisii.VolumeVector_push_back(self, x)

    def front(self):
        r"""front(self) -> volume"""
        return _nvisii.VolumeVector_front(self)

    def back(self):
        r"""back(self) -> volume"""
        return _nvisii.VolumeVector_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< nvisii::Volume * >::size_type
        x: std::vector< nvisii::Volume * >::value_type

        """
        return _nvisii.VolumeVector_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< nvisii::Volume * >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< nvisii::Volume * >::size_type
        x: std::vector< nvisii::Volume * >::value_type

        """
        return _nvisii.VolumeVector_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< nvisii::Volume * >::iterator

        Parameters
        ----------
        pos: std::vector< nvisii::Volume * >::iterator
        x: std::vector< nvisii::Volume * >::value_type

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< nvisii::Volume * >::iterator
        n: std::vector< nvisii::Volume * >::size_type
        x: std::vector< nvisii::Volume * >::value_type

        """
        return _nvisii.VolumeVector_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< nvisii::Volume * >::size_type

        """
        return _nvisii.VolumeVector_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< nvisii::Volume * >::size_type"""
        return _nvisii.VolumeVector_capacity(self)
    __swig_destroy__ = _nvisii.delete_VolumeVector

# Register VolumeVector in _nvisii:
_nvisii.VolumeVector_swigregister(VolumeVector)

class StringToUINT32Map(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _nvisii.StringToUINT32Map_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _nvisii.StringToUINT32Map___nonzero__(self)

    def __bool__(self):
        return _nvisii.StringToUINT32Map___bool__(self)

    def __len__(self):
        return _nvisii.StringToUINT32Map___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _nvisii.StringToUINT32Map___getitem__(self, key)

    def __delitem__(self, key):
        return _nvisii.StringToUINT32Map___delitem__(self, key)

    def has_key(self, key):
        return _nvisii.StringToUINT32Map_has_key(self, key)

    def keys(self):
        return _nvisii.StringToUINT32Map_keys(self)

    def values(self):
        return _nvisii.StringToUINT32Map_values(self)

    def items(self):
        return _nvisii.StringToUINT32Map_items(self)

    def __contains__(self, key):
        return _nvisii.StringToUINT32Map___contains__(self, key)

    def key_iterator(self):
        return _nvisii.StringToUINT32Map_key_iterator(self)

    def value_iterator(self):
        return _nvisii.StringToUINT32Map_value_iterator(self)

    def __setitem__(self, *args):
        return _nvisii.StringToUINT32Map___setitem__(self, *args)

    def asdict(self):
        return _nvisii.StringToUINT32Map_asdict(self)

    def __init__(self, *args):
        _nvisii.StringToUINT32Map_swiginit(self, _nvisii.new_StringToUINT32Map(*args))

    def empty(self):
        return _nvisii.StringToUINT32Map_empty(self)

    def size(self):
        return _nvisii.StringToUINT32Map_size(self)

    def swap(self, v):
        return _nvisii.StringToUINT32Map_swap(self, v)

    def begin(self):
        return _nvisii.StringToUINT32Map_begin(self)

    def end(self):
        return _nvisii.StringToUINT32Map_end(self)

    def rbegin(self):
        return _nvisii.StringToUINT32Map_rbegin(self)

    def rend(self):
        return _nvisii.StringToUINT32Map_rend(self)

    def clear(self):
        return _nvisii.StringToUINT32Map_clear(self)

    def get_allocator(self):
        return _nvisii.StringToUINT32Map_get_allocator(self)

    def count(self, x):
        return _nvisii.StringToUINT32Map_count(self, x)

    def erase(self, *args):
        return _nvisii.StringToUINT32Map_erase(self, *args)

    def find(self, x):
        return _nvisii.StringToUINT32Map_find(self, x)

    def lower_bound(self, x):
        return _nvisii.StringToUINT32Map_lower_bound(self, x)

    def upper_bound(self, x):
        return _nvisii.StringToUINT32Map_upper_bound(self, x)
    __swig_destroy__ = _nvisii.delete_StringToUINT32Map

# Register StringToUINT32Map in _nvisii:
_nvisii.StringToUINT32Map_swigregister(StringToUINT32Map)


def initialize_interactive(window_on_top=False, verbose=False, max_entities=10000, max_cameras=10, max_transforms=10000, max_meshes=10000, max_materials=10000, max_lights=100, max_textures=1000, max_volumes=1000):
    r"""Deprecated. Please use initialize() instead."""
    return _nvisii.initialize_interactive(window_on_top, verbose, max_entities, max_cameras, max_transforms, max_meshes, max_materials, max_lights, max_textures, max_volumes)

def initialize_headless(verbose=False, max_entities=10000, max_cameras=10, max_transforms=10000, max_meshes=10000, max_materials=10000, max_lights=100, max_textures=1000, max_volumes=1000):
    r"""Deprecated. Please use initialize(headless = True) instead."""
    return _nvisii.initialize_headless(verbose, max_entities, max_cameras, max_transforms, max_meshes, max_materials, max_lights, max_textures, max_volumes)

def initialize(headless=False, window_on_top=False, lazy_updates=False, verbose=False, max_entities=10000, max_cameras=10, max_transforms=10000, max_meshes=10000, max_materials=10000, max_lights=100, max_textures=1000, max_volumes=1000):
    r"""
    Initializes various backend systems required to render scene data.

    :type headless: boolean, optional
    :param headless: If true, avoids using any OpenGL resources, to enable use on systems without displays.
    :type window_on_top: boolean, optional
    :param window_on_top: Keeps the window opened during an interactive session on top of any other windows. (assuming headless is False)
    :type lazy_updates: boolean, optional
    :param lazy_updates: If True, nvisii will only upload components to the GPU on call to
        render/render_to_png/render_data for better scene editing performance. (assuming headless is False. Always on when headless is True)
    :type verbose: boolean, optional
    :param verbose: If false, nvisii will avoid outputing any unneccessary text
    :type max_entities: int, optional
    :param max_entities: The max number of creatable Entity components.
    :type max_cameras: int, optional
    :param max_cameras: The max number of creatable Camera components.
    :type max_transforms: int, optional
    :param max_transforms: The max number of creatable Transform components.
    :type max_meshes: int, optional
    :param max_meshes: The max number of creatable Mesh components.
    :type max_materials: int, optional
    :param max_materials: The max number of creatable Material components.
    :type max_lights: int, optional
    :param max_lights: The max number of creatable Light components.
    :type max_textures: int, optional
    :param max_textures: The max number of creatable Texture components.
    """
    return _nvisii.initialize(headless, window_on_top, lazy_updates, verbose, max_entities, max_cameras, max_transforms, max_meshes, max_materials, max_lights, max_textures, max_volumes)

def clear_all():
    r"""
    Removes any allocated components but keeps nvisii initialized.
    Call this if you would like to clear the current scene.
    """
    return _nvisii.clear_all()

def deinitialize():
    r"""
    Closes the interactive window, and shuts down any running backend systems.
    Call this function at the end of your script.
    """
    return _nvisii.deinitialize()

def register_pre_render_callback(callback):
    return _nvisii.register_pre_render_callback(callback)

def register_callback(callback):
    r"""
    Registers a callback which is called on the render thread before each rendered
    frame. This mechanism is useful for implementing camera controls and other
    routines dependent on cursor and button clicks. To disable the callback, pass
    nullptr/None here.
    """
    return _nvisii.register_callback(callback)

def set_camera_entity(camera_entity):
    r"""
    Tells the renderer which camera entity to use for rendering. The transform
    component of this camera entity places the camera into the world, and the
    camera component of this camera entity describes the perspective to use, the
    field of view, the depth of field, and other "analog" camera properties.

    :type camera_entity: :py:class:`Entity`
    :param camera_entity: The entity containing a camera and transform component, to use for rendering.
    """
    return _nvisii.set_camera_entity(camera_entity)

def set_dome_light_intensity(intensity):
    r"""
    Sets the intensity, or brightness, that the dome light (aka environment light) will emit it's color.

    :type intensity: float
    :param intensity: How powerful the dome light is in emitting light
    """
    return _nvisii.set_dome_light_intensity(intensity)

def set_dome_light_exposure(exposure):
    r"""
    Modifies the intensity, or brightness, that the dome light (aka environment light) will emit it's color.
    Increasing the exposure by 1 will double the energy emitted by the light.
    An exposure of 0 produces an unmodified intensity.
    An exposure of -1 cuts the intensity of the light in half.
    light_intensity = intensity * pow(2, exposureExposure)

    :type exposure: float
    :param exposure: How powerful the light source is in emitting light.
    """
    return _nvisii.set_dome_light_exposure(exposure)

def set_dome_light_color(color):
    r"""
    Sets the color which this dome light will emit.

    :param The: RGB color emitted that this dome light should emit.
    """
    return _nvisii.set_dome_light_color(color)

def set_dome_light_sky(*args, **kwargs):
    r"""
    Configures the procedural sky for the dome light (aka the environment).
    :type sun_position: :py:class:`vec3`
    :param sun_position: The position of the sun relative to [0,0,0]. As the sun
        goes down (in Z), Rayleigh scattering will cause the sky to change colors.

    :type sky_tint: :py:class:`vec3`, optional
    :param sky_tint: controls the relative color of the sky before Rayleigh scattering.
    :type atmosphere_thickness: float, optional
    :param atmosphere_thickness: effects Rayleigh scattering. Thin atmospheres look more
        like space, and thick atmospheres see more Rayleigh scattering.
    :type saturation: float, optional
    :param saturation: causes the sky to appear more or less "vibrant"
    """
    return _nvisii.set_dome_light_sky(*args, **kwargs)

def set_dome_light_texture(texture, enable_cdf=False):
    r"""
    Sets the texture used to color the dome light (aka the environment).
    Textures are sampled using a 2D to 3D latitude/longitude strategy.

    :type texture: :py:class:`Texture`
    :param texture: The texture to sample for the dome light.
    :type enable_cdf: boolean, optional
    :param enable_cdf: If True, reduces noise of sampling a dome light texture,
        but at the expense of frame rate. Useful for dome lights with bright lights
        that should cast shadows.
    """
    return _nvisii.set_dome_light_texture(texture, enable_cdf)

def clear_dome_light_texture():
    r""" Disconnects the dome light texture, reverting back to any existing constant dome light color"""
    return _nvisii.clear_dome_light_texture()

def set_dome_light_rotation(rotation):
    r"""
    Sets the rotation to apply to the dome light (aka the environment).

    :type rotation: :py:class:`quat`
    :param rotation: The rotation to apply to the dome light
    """
    return _nvisii.set_dome_light_rotation(rotation)

def enable_dome_light_sampling():
    r""" If enabled, objects will be lit by the dome light."""
    return _nvisii.enable_dome_light_sampling()

def disable_dome_light_sampling():
    r"""
     If disabled, objects will not be lit by the dome light.
    Instead, the dome light will only effect the background color.
    """
    return _nvisii.disable_dome_light_sampling()

def set_indirect_lighting_clamp(clamp):
    r"""
    Clamps the indirect light intensity during progressive image refinement.
    This reduces fireflies from indirect lighting, but also removes energy, and biases the resulting image.

    :type clamp: float
    :param clamp: The maximum intensity that indirect lighting can contribute per frame. A value of 0 disables indirect light clamping.
    """
    return _nvisii.set_indirect_lighting_clamp(clamp)

def set_direct_lighting_clamp(clamp):
    r"""
    Clamps the direct light intensity during progressive image refinement.
    This reduces fireflies from direct lighting, but also removes energy, and biases the resulting image.

    :type clamp: float
    :param clamp: The maximum intensity that direct lighting can contribute per frame. A value of 0 disables direct light clamping.
    """
    return _nvisii.set_direct_lighting_clamp(clamp)

def set_max_bounce_depth(diffuse_depth=2, glossy_depth=2, transparency_depth=8, transmission_depth=12, volume_depth=2):
    r"""
    Sets the maximum number of times that a ray originating from the camera can bounce through the scene to accumulate light.
    For scenes containing only rough surfaces, this max bounce depth can be set to lower values.
    For scenes containing complex transmissive or reflective objects like glass or metals, this
    max bounce depth might need to be increased to accurately render these objects.

    :type diffuse_depth: int, optional
    :param diffuse_depth: The maximum number of diffuse bounces allowed per ray.
        Higher counts will increase global illumination effects.
    :type glossy_depth: int, optional
    :param glossy_depth: The maximum number of glossy (reflection) bounces allowed per ray.
        Increases recursion in setups with mirrors, shiny surfaces, metals, etc
    :type transparency_depth: int, optional
    :param transparency_depth: The maximum number of transparency (alpha) bounces allowed per ray.
        Used for alpha cutouts of folliage and alpha transparent objects.
    :type transmission_depth: int, optional
    :param transmission_depth: The maximum number of transmission (refraction) bounces allowed per ray.
        For scenes containing glass, higher transmission depths result in more realistic refractions.
    :type volume_depth: int, optional
    :param volume_depth: The maximum number of volume bounces allowed per ray.
        At 0, volumes are single-scattering. Higher values result in multiple scattering.
    """
    return _nvisii.set_max_bounce_depth(diffuse_depth, glossy_depth, transparency_depth, transmission_depth, volume_depth)

def set_light_sample_count(count):
    r"""
    Sets the number of light samples to take per path vertex. A higher number of samples will reduce noise per frame, but
    also reduces frames per second.

    :type count: int
    :param count: The number of light samples to take per path vertex. Currently constrained to a maximum of 10 samples per vertex.
    """
    return _nvisii.set_light_sample_count(count)

def sample_pixel_area(*args, **kwargs):
    r"""
    Sets the region of the pixel where rays should sample. By default, rays sample the entire
    pixel area between [0,1]. Rays can instead sample a specific location of the pixel, like the pixel center,
    by specifying a specific location within the pixel area, eg [.5, .5].
    This allows for enabling or disabling antialiasing, possibly at the cost of noise in intermediate data buffers.

    :type x_sample_interval: :py:class:`vec2`, optional
    :param x_sample_interval: The interval to sample rays within along the x axis. A value of [0,1] will sample the entire pixel x axis.
    :type y_sample_interval: :py:class:`vec2`, optional
    :param y_sample_interval: The interval to sample rays within along the y axis. A value of [0,1] will sample the entire pixel y axis.
    """
    return _nvisii.sample_pixel_area(*args, **kwargs)

def sample_time_interval(*args, **kwargs):
    r"""
    Sets the interval of time that rays should sample. By default, rays sample the entire
    time interval befween the current frame and the next, [0,1]. Rays can instead sample a specific point in time,
    like the end-of-frame time, by specifying a specific location within the time interval, eg [1.0, 1.0] or [0.0, 0.0].
    This allows for enabling or disabling motion blur, while still preserving motion vectors.

    :type time_sample_interval: :py:class:`vec2`, optional
    :param time_sample_interval: The interval to sample rays within along in time. A value of [0,1] will result in motion blur across the entire frame.
    """
    return _nvisii.sample_time_interval(*args, **kwargs)

def enable_denoiser():
    r""" Enables the Optix denoiser."""
    return _nvisii.enable_denoiser()

def disable_denoiser():
    r""" Disables the Optix denoiser."""
    return _nvisii.disable_denoiser()

def configure_denoiser(use_albedo_guide=True, use_normal_guide=True, use_kernel_prediction=True):
    r"""
    Controls what guides and modes are used to denoise the image.
    :type use_albedo_guide: boolean, optional
    :param use_albedo_guide: If True, uses albedo to guide the denoiser. Useful for scenes with
        textures or large uniformly colored sections. Can cause issues when denoising motion blur.
    :type use_normal_guide: boolean, optional
    :param use_normal_guide: If True, uses surface normals to guide the denoiser. Useful for
        scenes where geometrically complex objects do not have distinct albedo (eg walls, uniformly colored objects, etc)
    :type use_kernel_prediction: boolean, optional
    :param use_kernel_prediction: If True, uses the OptiX kernel prediction model for denoising, which avoids intensity
        shifts and false color prediction by instead predicting a normalized kernel.
    """
    return _nvisii.configure_denoiser(use_albedo_guide, use_normal_guide, use_kernel_prediction)

def render(width, height, samples_per_pixel, seed=0):
    r"""
    Renders the current scene, returning the resulting framebuffer back to the user directly.

    :type width: int
    :param width: The width of the image to render
    :type height: int
    :param height: The height of the image to render
    :type samples_per_pixel: int
    :param samples_per_pixel: The number of rays to trace and accumulate per pixel.
    :type seed: int, optional
    :param seed: A seed used to initialize the random number generator.
    """
    return _nvisii.render(width, height, samples_per_pixel, seed)

def render_to_hdr(width, height, samples_per_pixel, image_path, seed=0):
    r"""Deprecated. Please use renderToFile."""
    return _nvisii.render_to_hdr(width, height, samples_per_pixel, image_path, seed)

def render_to_png(width, height, samples_per_pixel, image_path, seed=0):
    r"""Deprecated. Please use renderToFile."""
    return _nvisii.render_to_png(width, height, samples_per_pixel, image_path, seed)

def render_to_file(width, height, samples_per_pixel, file_path, seed=0):
    r"""
    Renders the current scene, saving the resulting framebuffer to an image on disk.

    :type width: int
    :param width: The width of the image to render
    :type height: int
    :param height: The height of the image to render
    :type samples_per_pixel: int
    :param samples_per_pixel: The number of rays to trace and accumulate per pixel.
    :type file_path: string
    :param file_path: The path to use to save the file, including the extension. Supported extensions include EXR, HDR, and PNG
    :type seed: int, optional
    :param seed: A seed used to initialize the random number generator.
    """
    return _nvisii.render_to_file(width, height, samples_per_pixel, file_path, seed)

def render_data(width, height, start_frame, frame_count, bounce, options, seed=0):
    r"""
    Renders out metadata used to render the current scene, returning the resulting framebuffer back to the user directly.

    :type width: int
    :param width: The width of the image to render
    :type height: int
    :param height: The height of the image to render
    :type start_frame: int
    :param start_frame: The start seed to feed into the random number generator
    :type frame_count: int
    :param frame_count: The number of frames to accumulate the resulting framebuffers by. For ID data, this should be set to 0.
    :type bounce: int
    :param bounce: The number of bounces required to reach the vertex whose metadata result should come from. A value of 0
        would save data for objects directly visible to the camera, a value of 1 would save reflections/refractions, etc.
    :type options: string
    :param options: Indicates the data to return. Current possible values include
        "none" for rendering out raw path traced data, "depth" to render the distance between the previous path vertex to the current one,
        "position" for rendering out the world space position of the path vertex, "normal" for rendering out the world space normal of the
        path vertex, "entity_id" for rendering out the entity ID whose surface the path vertex hit, "denoise_normal" for rendering out
        the normal buffer supplied to the Optix denoiser, and "denoise_albedo" for rendering out the albedo supplied to the Optix denoiser.
    :type seed: int, optional
    :param seed: A seed used to initialize the random number generator.
    """
    return _nvisii.render_data(width, height, start_frame, frame_count, bounce, options, seed)

def render_data_to_file(width, height, start_frame, frame_count, bounce, options, file_path, seed=0):
    r"""
    Renders out metadata used to render the current scene, returning the resulting framebuffer back to the user directly.

    :type width: int
    :param width: The width of the image to render
    :type height: int
    :param height: The height of the image to render
    :type start_frame: int
    :param start_frame: The start seed to feed into the random number generator
    :type frame_count: int
    :param frame_count: The number of frames to accumulate the resulting framebuffers by. For ID data, this should be set to 0.
    :type bounce: int
    :param bounce: The number of bounces required to reach the vertex whose metadata result should come from. A value of 0
        would save data for objects directly visible to the camera, a value of 1 would save reflections/refractions, etc.
    :type options: string
    :param options: Indicates the data to return. Current possible values include
        "none" for rendering out raw path traced data, "depth" to render the distance between the previous path vertex to the current one,
        "position" for rendering out the world space position of the path vertex, "normal" for rendering out the world space normal of the
        path vertex, "entity_id" for rendering out the entity ID whose surface the path vertex hit, "denoise_normal" for rendering out
        the normal buffer supplied to the Optix denoiser, and "denoise_albedo" for rendering out the albedo supplied to the Optix denoiser.
    :type file_path: string
    :param file_path: The path to use to save the file, including the extension. Supported extensions are EXR, HDR, and PNG
    :type seed: int, optional
    :param seed: A seed used to initialize the random number generator.
    """
    return _nvisii.render_data_to_file(width, height, start_frame, frame_count, bounce, options, file_path, seed)
class scene(object):
    r"""An object containing a list of components that together represent a scene"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    entities = property(_nvisii.scene_entities_get, _nvisii.scene_entities_set)
    transforms = property(_nvisii.scene_transforms_get, _nvisii.scene_transforms_set)
    textures = property(_nvisii.scene_textures_get, _nvisii.scene_textures_set)
    materials = property(_nvisii.scene_materials_get, _nvisii.scene_materials_set)
    meshes = property(_nvisii.scene_meshes_get, _nvisii.scene_meshes_set)
    lights = property(_nvisii.scene_lights_get, _nvisii.scene_lights_set)
    cameras = property(_nvisii.scene_cameras_get, _nvisii.scene_cameras_set)

    def __init__(self):
        _nvisii.scene_swiginit(self, _nvisii.new_scene())
    __swig_destroy__ = _nvisii.delete_scene

# Register scene in _nvisii:
_nvisii.scene_swigregister(scene)


def import_scene(*args, **kwargs):
    r"""
    Imports a file containing scene data.

    Supported file formats include: AMF 3DS AC ASE ASSBIN B3D BVH COLLADA DXF
    CSM HMP IRRMESH IRR LWO LWS M3D MD2 MD3 MD5 MDC MDL NFF NDO OFF OBJ OGRE
    OPENGEX PLY MS3D COB BLEND IFC XGL FBX Q3D Q3BSP RAW SIB SMD STL
    TERRAGEN 3D X X3D GLTF 3MF MMD

    First, any materials described by the file are used to generate Material components.
    Next, any textures required by those materials will be loaded.
    After that, all shapes will be separated by material.
    For each separated shape, an entity is created to attach a transform, mesh, and material component together.
    These shapes are then translated so that the transform component is centered at the centroid of the shape.
    Finally, any specified position, scale, and/or rotation are applied to the generated transforms.

    :param filepath: The path for the file to load
    :type position: :py:class:`vec3`, optional
    :param position: A change in position to apply to all entities generated by this function
    :type position: :py:class:`vec3`, optional
    :param position: A change in scale to apply to all entities generated by this function
    :type position: :py:class:`vec3`, optional
    :param position: A change in rotation to apply to all entities generated by this function
    :type args: std::vector< std::string,std::allocator< std::string > >, optional
    :param args: A list of optional arguments that can effect the importer.
        Possible options include:
        "verbose" - print out information related to loading the scene.
    """
    return _nvisii.import_scene(*args, **kwargs)

def get_scene_min_aabb_corner():
    r"""
    :rtype: :py:class:`vec3`
    :return: the minimum axis aligned bounding box position for the axis aligned bounding box containing all scene geometry
    """
    return _nvisii.get_scene_min_aabb_corner()

def get_scene_max_aabb_corner():
    r"""
    :rtype: :py:class:`vec3`
    :return: the maximum axis aligned bounding box position for the axis aligned bounding box containing all scene geometry
    """
    return _nvisii.get_scene_max_aabb_corner()

def get_scene_aabb_center():
    r"""
    :rtype: :py:class:`vec3`
    :return: the center of the aligned bounding box for the axis aligned bounding box containing all scene geometry
    """
    return _nvisii.get_scene_aabb_center()

def update_scene_aabb(entity):
    return _nvisii.update_scene_aabb(entity)

def enable_updates():
    r"""
    If enabled, the interactive window image will change asynchronously as scene components are altered.
    However, bulk component edits will slow down, as each component edit will individually cause the renderer to
    temporarily lock components while being uploaded to the GPU.
    """
    return _nvisii.enable_updates()

def disable_updates():
    r"""
    If disabled, the interactive window image will only show scene changes on call to render, render_to_png, and render_data.
    Bulk component edits will be much faster when disabled, as all component edits can be done without the renderer
    locking them for upload to the GPU.
    """
    return _nvisii.disable_updates()

def are_updates_enabled():
    return _nvisii.are_updates_enabled()

def resize_window(width, height):
    r"""
    If using interactive mode, resizes the window to the specified dimensions.

    :type width: int
    :param width: The width to resize the window to
    :type height: int
    :param height: The height to resize the window to
    """
    return _nvisii.resize_window(width, height)

def is_button_pressed(button):
    r"""
    If in interactive mode, returns True if the specified button is pressed but not held.
    :param The: button to check. Not case sensitive. Possible options include:
        SPACE, APOSTROPHE, COMMA, MINUS, PERIOD, SLASH, SEMICOLON, EQUAL, UP, DOWN, LEFT, RIGHT
        0-9, A->Z, [, ], \, `, ESCAPE, ENTER, TAB, BACKSPACE, INSERT, DELETE, PAGE_UP, PAGE_DOWN, HOME,
        CAPS_LOCK, SCROLL_LOCK, NUM_LOCK, PRINT_SCREEN, PAUSE, F1 -> F25, KP_0 -> KP_9,
        KP_DECIMAL, KP_DIVIDE, KP_MULTIPLY, KP_SUBTRACT, KP_ADD, KP_ENTER, KP_EQUAL,
        LEFT_SHIFT, LEFT_CONTROL, LEFT_ALT, LEFT_SUPER, RIGHT_SHIFT, RIGHT_CONTROL, RIGHT_ALT, RIGHT_SUPER,
        MOUSE_LEFT, MOUSE_MIDDLE, MOUSE_RIGHT
    """
    return _nvisii.is_button_pressed(button)

def is_button_held(button):
    r"""
    If in interactive mode, returns True if the specified button is held down.
    :param The: button to check. Not case sensitive. Possible options include:
        SPACE, APOSTROPHE, COMMA, MINUS, PERIOD, SLASH, SEMICOLON, EQUAL, UP, DOWN, LEFT, RIGHT
        0-9, A->Z, [, ], \, `, ESCAPE, ENTER, TAB, BACKSPACE, INSERT, DELETE, PAGE_UP, PAGE_DOWN, HOME,
        CAPS_LOCK, SCROLL_LOCK, NUM_LOCK, PRINT_SCREEN, PAUSE, F1 -> F25, KP_0 -> KP_9,
        KP_DECIMAL, KP_DIVIDE, KP_MULTIPLY, KP_SUBTRACT, KP_ADD, KP_ENTER, KP_EQUAL,
        LEFT_SHIFT, LEFT_CONTROL, LEFT_ALT, LEFT_SUPER, RIGHT_SHIFT, RIGHT_CONTROL, RIGHT_ALT, RIGHT_SUPER,
        MOUSE_LEFT, MOUSE_MIDDLE, MOUSE_RIGHT
    """
    return _nvisii.is_button_held(button)

def get_cursor_pos():
    r""" If in interactive mode, returns the position of the cursor relative to the window."""
    return _nvisii.get_cursor_pos()

def set_cursor_mode(mode):
    r"""
    If in interactive mode, sets the mode of the cursor.
    :type mode: string
    :param mode: Can be one of the following:
        NORMAL - makes the cursor visible and beaving normally
        HIDDEN makes the cursor invisible when it is over the content area of the window,
        but does not restrict the cursor from leaving.
        DISABLED - hides and grabs the cursor, providing virtual and unlimited cursor movement.
        This is useful for implementing for example 3D camera controls.
    """
    return _nvisii.set_cursor_mode(mode)

def get_window_size():
    r""" If in interactive mode, returns size of the window"""
    return _nvisii.get_window_size()

def should_window_close():
    r""" If in interactive mode, returns true if the close button on the window was clicked."""
    return _nvisii.should_window_close()

def __test__(args):
    return _nvisii.__test__(args)
SF_VERBOSE = _nvisii.SF_VERBOSE
class static_factory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def to_string(self):
        return _nvisii.static_factory_to_string(self)

    def get_name(self):
        return _nvisii.static_factory_get_name(self)

    def get_id(self):
        return _nvisii.static_factory_get_id(self)

    @staticmethod
    def does_item_exist(lookupTable, name):
        return _nvisii.static_factory_does_item_exist(lookupTable, name)
    __swig_destroy__ = _nvisii.delete_static_factory

# Register static_factory in _nvisii:
_nvisii.static_factory_swigregister(static_factory)

def static_factory_does_item_exist(lookupTable, name):
    return _nvisii.static_factory_does_item_exist(lookupTable, name)

class camera(static_factory):
    r"""
    The "Camera" component describes the perspective of an entity.
    It lens properties, like depth of field, focal length, field of view, and so on.
    It also describes the target render resolution.
    By connecting a camera component to an entity with a transform, that entity
    can be used to render the scene from a position in space.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def create(name, field_of_view=0.785398, aspect=1.0):
        r"""
        Constructs a camera component.
        :type name: string
        :param name: A unique name for this camera.
        :type field_of_view: float, optional
        :param field_of_view: Specifies the field of view angle in the y direction. Expressed in radians.
        :type aspect: float, optional
        :param aspect: Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is a ratio of x (width) to y (height)
        :rtype: :py:class:`Camera`
        :return: a reference to a camera component
        """
        return _nvisii.camera_create(name, field_of_view, aspect)

    @staticmethod
    def create_perspective_from_fov(name, field_of_view, aspect):
        r""" Deprecated in favor of either create or create_from_fov"""
        return _nvisii.camera_create_perspective_from_fov(name, field_of_view, aspect)

    @staticmethod
    def create_from_fov(name, field_of_view, aspect):
        r"""
        Constructs a camera component from a field of view.
        The field of view controls the amount of zoom, i.e. the amount of the scene
        which is visible all at once. A smaller field of view results in a longer focal length (more zoom),
        while larger field of view allow you to see more of the scene at once (shorter focal length, less zoom)

        :type name: string
        :param name: A unique name for this camera.
        :type field_of_view: float
        :param field_of_view: Specifies the field of view angle in the y direction. Expressed in radians.
        :type aspect: float
        :param aspect: Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is a ratio of x (width) to y (height)
        :rtype: :py:class:`Camera`
        :return: a reference to a camera component
        """
        return _nvisii.camera_create_from_fov(name, field_of_view, aspect)

    @staticmethod
    def create_perspective_from_focal_length(name, focal_length, sensor_width, sensor_height):
        r""" Deprecated in favor of create_from_focal_length"""
        return _nvisii.camera_create_perspective_from_focal_length(name, focal_length, sensor_width, sensor_height)

    @staticmethod
    def create_from_focal_length(name, focal_length, sensor_width, sensor_height):
        r"""
        Constructs a camera component from a focal length.
        The focal length controls the amount of zoom, i.e. the amount of the scene
        which is visible all at once. Longer focal lengths result in a smaller field of view (more zoom),
        while short focal lengths allow you to see more of the scene at once (larger FOV, less zoom)

        :type name: string
        :param name: A unique name for this camera.
        :type focal_length: float
        :param focal_length: Specifies the focal length of the camera lens (in millimeters).
        :type sensor_width: float
        :param sensor_width: Specifies the width of the camera sensor (in millimeters).
        :type sensor_height: float
        :param sensor_height: Specifies the height of the camera sensor (in millimeters).
        :rtype: :py:class:`Camera`
        :return: a reference to a camera component
        """
        return _nvisii.camera_create_from_focal_length(name, focal_length, sensor_width, sensor_height)

    @staticmethod
    def create_from_intrinsics(name, fx, fy, cx, cy, width, height, near=0.05, far=100.):
        r"""
        Constructs a camera component from a set of intrinsic properties.
        These properties are common in computer-vision setups.

        :type name: string
        :param name: A unique name for this camera.
        :type fx: float
        :param fx: X-axis focal length in meters.
        :type fy: float
        :param fy: Y-axis focal length in meters.
        :type cx: float
        :param cx: X-axis optical center in pixels.
        :type cy: float
        :param cy: Y-axis optical center in pixels.
        :type width: float
        :param width: Width of the current viewport, in pixels.
        :type height: float
        :param height: Height of the current viewport, in pixels.
        :param znear: The floating-point distance to the near clipping plane. If not specified, defaults to 0.05.
        :param zfar: The floating-point distance to the far clipping plane. zfar must be greater than znear. If not specified, defaults to 100.0.
        :rtype: :py:class:`Camera`
        :return: a reference to a camera component
        """
        return _nvisii.camera_create_from_intrinsics(name, fx, fy, cx, cy, width, height, near, far)

    @staticmethod
    def get(name):
        r"""
        :type name: string
        :param name: The name of the camera to get
        :rtype: :py:class:`Camera`
        :return: a Camera who's name matches the given name
        """
        return _nvisii.camera_get(name)

    @staticmethod
    def get_front_struct():
        r"""
        :rtype: CameraStruct
        :return: a pointer to the table of CameraStructs
        """
        return _nvisii.camera_get_front_struct()

    @staticmethod
    def get_front():
        r"""
        :rtype: :py:class:`Camera`
        :return: a pointer to the list of Camera components.
        """
        return _nvisii.camera_get_front()

    @staticmethod
    def get_count():
        r"""
        :rtype: int
        :return: the number of allocated cameras.
        """
        return _nvisii.camera_get_count()

    def get_name(self):
        r"""
        :rtype: string
        :return: the name of this component
        """
        return _nvisii.camera_get_name(self)

    @staticmethod
    def get_name_to_id_map():
        r"""
        :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
        :return: A map whose key is a camera name and whose value is the ID for that camera
        """
        return _nvisii.camera_get_name_to_id_map()

    @staticmethod
    def remove(name):
        r"""
        :type name: string
        :param name: The name of the camera to remove
        """
        return _nvisii.camera_remove(name)

    @staticmethod
    def initialize_factory(max_components):
        r""" Allocates the tables used to store all Camera components"""
        return _nvisii.camera_initialize_factory(max_components)

    @staticmethod
    def is_factory_initialized():
        r"""
        :rtype: boolean
        :return: True if the tables used to store all Camera components have been allocated, and False otherwise
        """
        return _nvisii.camera_is_factory_initialized()

    def is_initialized(self):
        r"""
        :rtype: boolean
        :return: True the current camera is a valid, initialized camera, and False if the camera was cleared or removed.
        """
        return _nvisii.camera_is_initialized(self)

    @staticmethod
    def update_components():
        r""" Iterates through all components, updating any component struct fields and marking components as clean."""
        return _nvisii.camera_update_components()

    @staticmethod
    def clear_all():
        r""" Clears any existing camera components."""
        return _nvisii.camera_clear_all()

    def to_string(self):
        r"""
        :rtype: string
        :return: a string representation of the current component
        """
        return _nvisii.camera_to_string(self)

    @staticmethod
    def are_any_dirty():
        r""" Indicates whether or not any cameras are "out of date" and need to be updated through the "update components" function"""
        return _nvisii.camera_are_any_dirty()

    def is_dirty(self):
        r"""
        :rtype: boolean
        :return: True if the camera has been modified since the previous frame, and False otherwise
        """
        return _nvisii.camera_is_dirty(self)

    def is_clean(self):
        r"""
        :rtype: boolean
        :return: True if the camera has not been modified since the previous frame, and False otherwise
        """
        return _nvisii.camera_is_clean(self)

    def mark_dirty(self):
        r""" Tags the current component as being modified since the previous frame."""
        return _nvisii.camera_mark_dirty(self)

    def mark_clean(self):
        r""" Tags the current component as being unmodified since the previous frame."""
        return _nvisii.camera_mark_clean(self)

    def get_struct(self):
        r""" Returns the simplified struct used to represent the current component"""
        return _nvisii.camera_get_struct(self)

    def set_fov(self, field_of_view, aspect):
        r"""
        Tells the current camera component to use a projection matrix constructed from a field of view.
        The field of view controls the amount of zoom, i.e. the amount of the scene
        which is visible all at once. A smaller field of view results in a longer focal length (more zoom),
        while larger field of view allow you to see more of the scene at once (shorter focal length, less zoom)

        :type field_of_view: float
        :param field_of_view: Specifies the field of view angle in the y direction. Expressed in radians.
        :type aspect: float
        :param aspect: Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is a ratio of x (width) to y (height)
        """
        return _nvisii.camera_set_fov(self, field_of_view, aspect)

    def set_focal_length(self, focal_length, sensor_width, sensor_height):
        r"""
        Tells the current camera component to use a projection matrix constructed from a focal length.
        The focal length controls the amount of zoom, i.e. the amount of the scene
        which is visible all at once. Longer focal lengths result in a smaller field of view (more zoom),
        while short focal lengths allow you to see more of the scene at once (larger FOV, less zoom)

        :type focal_length: float
        :param focal_length: Specifies the focal length of the camera lens (in millimeters).
        :type sensor_width: float
        :param sensor_width: Specifies the width of the camera sensor (in millimeters).
        :type sensor_height: float
        :param sensor_height: Specifies the height of the camera sensor (in millimeters).
            NOTE: not to be confused with set_focal_distance
        """
        return _nvisii.camera_set_focal_length(self, focal_length, sensor_width, sensor_height)

    def set_focal_distance(self, distance):
        r"""
        Real-world cameras transmit light through a lens that bends and focuses it onto the sensor.
        Because of this, objects that are a certain distance away are in focus, but objects in front
        and behind that are blurred.

        :type distance: float
        :param distance: The distance to the camera focal position. Note that this is different from focal length,
            and has no effect on the perspective of a camera.

        NOTE: not to be confused with set_focal_length
        """
        return _nvisii.camera_set_focal_distance(self, distance)

    def set_aperture_diameter(self, diameter):
        r"""
        Real-world cameras transmit light through a lens that bends and focuses it onto the sensor.
        Because of this, objects that are a certain distance away are in focus, but objects in front
        and behind that are blurred.

        :type diameter: float
        :param diameter: Defines the amount of blurring by setting the diameter of the aperture (in millimeters).
        """
        return _nvisii.camera_set_aperture_diameter(self, diameter)

    def get_projection(self):
        r"""
        :rtype: :py:class:`mat4`
        :return: the camera to projection matrix.
           			This transform can be used to achieve perspective (eg a vanishing point), or for scaling
           			an orthographic view.
        """
        return _nvisii.camera_get_projection(self)

    def set_projection(self, projection):
        r"""
         Sets the projection matrix used to achieve a perspective (eg a vanishing point), or for scaling
        an orthographic view
        """
        return _nvisii.camera_set_projection(self, projection)

    def get_intrinsic_matrix(self, width, height):
        r"""
        The intrinsic matrix is a 3x3 matrix that transforms 3D (non-homogeneous) cooordinates in camera space into 2D (homogeneous) image coordinates.
        These types of matrices are commonly used for computer vision applications, but are less common in computer graphics.
        :type width: float
        :param width: The width of the image (not tracked internally by the camera)
        :type height: float
        :param height: The height of the image (not tracked internally by the camera)
        :rtype: :py:class:`mat3`
        :return: An intrinsic matrix representation of the camera's perspective.
        """
        return _nvisii.camera_get_intrinsic_matrix(self, width, height)

    def set_intrinsics(self, fx, fy, cx, cy, width, height, near=0.05, far=100.):
        r"""
         Constructs a projection matrix using custom intrinsics.
        :type fx: float
        :param fx: X-axis focal length in meters.
        :type fy: float
        :param fy: Y-axis focal length in meters.
        :type cx: float
        :param cx: X-axis optical center in pixels.
        :type cy: float
        :param cy: Y-axis optical center in pixels.
        :type width: float
        :param width: Width of the current viewport, in pixels.
        :type height: float
        :param height: Height of the current viewport, in pixels.
        :param znear: The floating-point distance to the near clipping plane. If not specified, defaults to 0.05.
        :param zfar: The floating-point distance to the far clipping plane. zfar must be greater than znear. If not specified, defaults to 100.0.
        """
        return _nvisii.camera_set_intrinsics(self, fx, fy, cx, cy, width, height, near, far)

    @staticmethod
    def get_edit_mutex():
        r""" For internal use. Returns the mutex used to lock cameras for processing by the renderer."""
        return _nvisii.camera_get_edit_mutex()
    __swig_destroy__ = _nvisii.delete_camera

# Register camera in _nvisii:
_nvisii.camera_swigregister(camera)

def camera_create(name, field_of_view=0.785398, aspect=1.0):
    r"""
    Constructs a camera component.
    :type name: string
    :param name: A unique name for this camera.
    :type field_of_view: float, optional
    :param field_of_view: Specifies the field of view angle in the y direction. Expressed in radians.
    :type aspect: float, optional
    :param aspect: Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is a ratio of x (width) to y (height)
    :rtype: :py:class:`Camera`
    :return: a reference to a camera component
    """
    return _nvisii.camera_create(name, field_of_view, aspect)

def camera_create_perspective_from_fov(name, field_of_view, aspect):
    r""" Deprecated in favor of either create or create_from_fov"""
    return _nvisii.camera_create_perspective_from_fov(name, field_of_view, aspect)

def camera_create_from_fov(name, field_of_view, aspect):
    r"""
    Constructs a camera component from a field of view.
    The field of view controls the amount of zoom, i.e. the amount of the scene
    which is visible all at once. A smaller field of view results in a longer focal length (more zoom),
    while larger field of view allow you to see more of the scene at once (shorter focal length, less zoom)

    :type name: string
    :param name: A unique name for this camera.
    :type field_of_view: float
    :param field_of_view: Specifies the field of view angle in the y direction. Expressed in radians.
    :type aspect: float
    :param aspect: Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is a ratio of x (width) to y (height)
    :rtype: :py:class:`Camera`
    :return: a reference to a camera component
    """
    return _nvisii.camera_create_from_fov(name, field_of_view, aspect)

def camera_create_perspective_from_focal_length(name, focal_length, sensor_width, sensor_height):
    r""" Deprecated in favor of create_from_focal_length"""
    return _nvisii.camera_create_perspective_from_focal_length(name, focal_length, sensor_width, sensor_height)

def camera_create_from_focal_length(name, focal_length, sensor_width, sensor_height):
    r"""
    Constructs a camera component from a focal length.
    The focal length controls the amount of zoom, i.e. the amount of the scene
    which is visible all at once. Longer focal lengths result in a smaller field of view (more zoom),
    while short focal lengths allow you to see more of the scene at once (larger FOV, less zoom)

    :type name: string
    :param name: A unique name for this camera.
    :type focal_length: float
    :param focal_length: Specifies the focal length of the camera lens (in millimeters).
    :type sensor_width: float
    :param sensor_width: Specifies the width of the camera sensor (in millimeters).
    :type sensor_height: float
    :param sensor_height: Specifies the height of the camera sensor (in millimeters).
    :rtype: :py:class:`Camera`
    :return: a reference to a camera component
    """
    return _nvisii.camera_create_from_focal_length(name, focal_length, sensor_width, sensor_height)

def camera_create_from_intrinsics(name, fx, fy, cx, cy, width, height, near=0.05, far=100.):
    r"""
    Constructs a camera component from a set of intrinsic properties.
    These properties are common in computer-vision setups.

    :type name: string
    :param name: A unique name for this camera.
    :type fx: float
    :param fx: X-axis focal length in meters.
    :type fy: float
    :param fy: Y-axis focal length in meters.
    :type cx: float
    :param cx: X-axis optical center in pixels.
    :type cy: float
    :param cy: Y-axis optical center in pixels.
    :type width: float
    :param width: Width of the current viewport, in pixels.
    :type height: float
    :param height: Height of the current viewport, in pixels.
    :param znear: The floating-point distance to the near clipping plane. If not specified, defaults to 0.05.
    :param zfar: The floating-point distance to the far clipping plane. zfar must be greater than znear. If not specified, defaults to 100.0.
    :rtype: :py:class:`Camera`
    :return: a reference to a camera component
    """
    return _nvisii.camera_create_from_intrinsics(name, fx, fy, cx, cy, width, height, near, far)

def camera_get(name):
    r"""
    :type name: string
    :param name: The name of the camera to get
    :rtype: :py:class:`Camera`
    :return: a Camera who's name matches the given name
    """
    return _nvisii.camera_get(name)

def camera_get_front_struct():
    r"""
    :rtype: CameraStruct
    :return: a pointer to the table of CameraStructs
    """
    return _nvisii.camera_get_front_struct()

def camera_get_front():
    r"""
    :rtype: :py:class:`Camera`
    :return: a pointer to the list of Camera components.
    """
    return _nvisii.camera_get_front()

def camera_get_count():
    r"""
    :rtype: int
    :return: the number of allocated cameras.
    """
    return _nvisii.camera_get_count()

def camera_get_name_to_id_map():
    r"""
    :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
    :return: A map whose key is a camera name and whose value is the ID for that camera
    """
    return _nvisii.camera_get_name_to_id_map()

def camera_remove(name):
    r"""
    :type name: string
    :param name: The name of the camera to remove
    """
    return _nvisii.camera_remove(name)

def camera_initialize_factory(max_components):
    r""" Allocates the tables used to store all Camera components"""
    return _nvisii.camera_initialize_factory(max_components)

def camera_is_factory_initialized():
    r"""
    :rtype: boolean
    :return: True if the tables used to store all Camera components have been allocated, and False otherwise
    """
    return _nvisii.camera_is_factory_initialized()

def camera_update_components():
    r""" Iterates through all components, updating any component struct fields and marking components as clean."""
    return _nvisii.camera_update_components()

def camera_clear_all():
    r""" Clears any existing camera components."""
    return _nvisii.camera_clear_all()

def camera_are_any_dirty():
    r""" Indicates whether or not any cameras are "out of date" and need to be updated through the "update components" function"""
    return _nvisii.camera_are_any_dirty()

def camera_get_edit_mutex():
    r""" For internal use. Returns the mutex used to lock cameras for processing by the renderer."""
    return _nvisii.camera_get_edit_mutex()

class entity(static_factory):
    r"""
    An "Entity" is a component that is used to connect other component types together.

    If you'd like to place an object in the scene, an Entity would be used to
    connect a Mesh component, a Transform component, and a Material component together.

    Only one component of a given type can be connected to an entity at any given point
    in time.

    Multiple entities can "share" the same component type. For example, a sphere mesh
    component can be referenced by many entities, with each entity having a unique
    material. This is essentially a form of "instancing". Alternatively, many
    different entities can share the same Material component, such that any adjustments
    to that material component effect a collection of objects instead of just one.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def create(name, transform=None, material=None, mesh=None, light=None, camera=None, volume=None):
        r"""
        Constructs an Entity with the given name.

        :type transform: :py:class:`Transform`, optional
        :param transform: (optional) A transform component places the entity into the scene.
        :type material: :py:class:`Material`, optional
        :param material: (optional) A material component describes how an entity should look when rendered.
        :type mesh: :py:class:`Mesh`, optional
        :param mesh: (optional) A mesh component describes a surface to be rendered.
            Volume separating the inside and outside portion of the surface are implicitly represented using
            clockwise and counterclockwise triangles and corresponding surface normal.
            Note: Cannot be assigned if a "volume" component is also assigned.
        :type light: :py:class:`Light`, optional
        :param light: (optional) A light component indicates that any connected geometry should act like a light source.
        :type camera: :py:class:`Camera`, optional
        :param camera: (optional) A camera component indicates that the current entity can be used to view into the scene.
        :type volume: :py:class:`Volume`, optional
        :param volume: (optional) A volume component describes the volumetric particles
            to be rendered. Surfaces within the volume are implicitly defined using extinction.
            Note: Cannot be assigned if a "mesh" component is also assigned.
        :rtype: :py:class:`Entity`
        :return: a reference to an Entity
        """
        return _nvisii.entity_create(name, transform, material, mesh, light, camera, volume)

    @staticmethod
    def get(name):
        r"""
        :type name: string
        :param name: The name of the entity to get
        :rtype: :py:class:`Entity`
        :return: an Entity who's name matches the given name
        """
        return _nvisii.entity_get(name)

    @staticmethod
    def get_count():
        r"""
        :rtype: int
        :return: the number of allocated entities
        """
        return _nvisii.entity_get_count()

    def get_name(self):
        r"""
        :rtype: string
        :return: the name of this component
        """
        return _nvisii.entity_get_name(self)

    def get_id(self):
        r"""
        :rtype: int
        :return: the unique integer ID for this component
        """
        return _nvisii.entity_get_id(self)

    @staticmethod
    def get_name_to_id_map():
        r"""
        :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
        :return: A map whose key is an entity name and whose value is the ID for that entity
        """
        return _nvisii.entity_get_name_to_id_map()

    @staticmethod
    def remove(name):
        r"""
        :type name: string
        :param name: The name of the Entity to remove
        """
        return _nvisii.entity_remove(name)

    @staticmethod
    def initialize_factory(max_components):
        r""" Allocates the tables used to store all Entity components"""
        return _nvisii.entity_initialize_factory(max_components)

    def is_initialized(self):
        r"""
        :rtype: boolean
        :return: True the current entity is a valid, initialized entity, and False if the entity was cleared or removed.
        """
        return _nvisii.entity_is_initialized(self)

    @staticmethod
    def clear_all():
        r""" Clears any existing entity components. This function can be used to reset a scene."""
        return _nvisii.entity_clear_all()

    def to_string(self):
        r"""
        :rtype: string
        :return: a string representation of the current component
        """
        return _nvisii.entity_to_string(self)

    @staticmethod
    def are_any_dirty():
        r"""
        :rtype: boolean
        :return: True if any the entities has been modified since the previous frame, and False otherwise
        """
        return _nvisii.entity_are_any_dirty()

    @staticmethod
    def get_dirty_entities():
        r"""
        :rtype: std::set< nvisii::Entity * >
        :return: a list of entities that have been modified since the previous frame
        """
        return _nvisii.entity_get_dirty_entities()

    @staticmethod
    def get_renderable_entities():
        r"""
        :rtype: std::set< nvisii::Entity * >
        :return: a list of entities that are renderable (ie, can be seen) by the camera. (note, currently ignores visibility)
        """
        return _nvisii.entity_get_renderable_entities()

    def set_transform(self, transform):
        r""" Connects a transform component to the current entity"""
        return _nvisii.entity_set_transform(self, transform)

    def clear_transform(self):
        r""" Disconnects any transform component from the current entity"""
        return _nvisii.entity_clear_transform(self)

    def get_transform(self):
        r"""
        :rtype: :py:class:`Transform`
        :return: a reference to the connected transform component, or None/nullptr if no component is connected.
        """
        return _nvisii.entity_get_transform(self)

    def set_camera(self, camera):
        r""" Connects a camera component to the current entity"""
        return _nvisii.entity_set_camera(self, camera)

    def clear_camera(self):
        r""" Disconnects any camera component from the current entity"""
        return _nvisii.entity_clear_camera(self)

    def get_camera(self):
        r"""
        :rtype: :py:class:`Camera`
        :return: a reference to the connected camera component, or None/nullptr if no component is connected.
        """
        return _nvisii.entity_get_camera(self)

    def set_material(self, material):
        r""" Connects a material component to the current entity"""
        return _nvisii.entity_set_material(self, material)

    def clear_material(self):
        r""" Disconnects any material component from the current entity"""
        return _nvisii.entity_clear_material(self)

    def get_material(self):
        r"""
        :rtype: :py:class:`Material`
        :return: a reference to the connected material component, or None/nullptr if no component is connected.
        """
        return _nvisii.entity_get_material(self)

    def set_light(self, light):
        r""" Connects a light component to the current entity"""
        return _nvisii.entity_set_light(self, light)

    def clear_light(self):
        r""" Disconnects any light component from the current entity"""
        return _nvisii.entity_clear_light(self)

    def get_light(self):
        r"""
        :rtype: :py:class:`Light`
        :return: a reference to the connected light component, or None/nullptr if no component is connected.
        """
        return _nvisii.entity_get_light(self)

    def set_mesh(self, mesh):
        r"""
        Connects a mesh component to the current entity.
        Note: a mesh component cannot be attached if a volume component is currently attached.
        """
        return _nvisii.entity_set_mesh(self, mesh)

    def clear_mesh(self):
        r""" Disconnects any mesh component from the current entity"""
        return _nvisii.entity_clear_mesh(self)

    def get_mesh(self):
        r"""
        :rtype: :py:class:`Mesh`
        :return: a reference to the connected mesh component, or None/nullptr if no component is connected.
        """
        return _nvisii.entity_get_mesh(self)

    def set_volume(self, volume):
        r"""
        Connects a volume component to the current entity.
        Note: a volume component cannot be attached if a mesh component is currently attached.
        """
        return _nvisii.entity_set_volume(self, volume)

    def clear_volume(self):
        r""" Disconnects any volume component from the current entity"""
        return _nvisii.entity_clear_volume(self)

    def get_volume(self):
        r"""
        :rtype: :py:class:`Volume`
        :return: a reference to the connected volume component, or None/nullptr if no component is connected.
        """
        return _nvisii.entity_get_volume(self)

    def set_visibility(self, camera=True):
        r"""
        Objects can be set to be invisible to particular ray types:
        :type camera: boolean, optional
        :param camera: Makes the object visible to camera rays
        """
        return _nvisii.entity_set_visibility(self, camera)

    def get_min_aabb_corner(self):
        r"""
        :rtype: :py:class:`vec3`
        :return: the minimum axis aligned bounding box position. Requires a transform and mesh component to be attached.
        """
        return _nvisii.entity_get_min_aabb_corner(self)

    def get_max_aabb_corner(self):
        r"""
        :rtype: :py:class:`vec3`
        :return: the maximum axis aligned bounding box position. Requires a transform and mesh component to be attached.
        """
        return _nvisii.entity_get_max_aabb_corner(self)

    def get_aabb_center(self):
        r"""
        :rtype: :py:class:`vec3`
        :return: the center of the aligned bounding box. Requires a transform and mesh component to be attached.
        """
        return _nvisii.entity_get_aabb_center(self)

    def compute_aabb(self):
        r""" For internal use."""
        return _nvisii.entity_compute_aabb(self)

    def update_renderables(self):
        r""" For internal use."""
        return _nvisii.entity_update_renderables(self)
    __swig_destroy__ = _nvisii.delete_entity

# Register entity in _nvisii:
_nvisii.entity_swigregister(entity)

def entity_create(name, transform=None, material=None, mesh=None, light=None, camera=None, volume=None):
    r"""
    Constructs an Entity with the given name.

    :type transform: :py:class:`Transform`, optional
    :param transform: (optional) A transform component places the entity into the scene.
    :type material: :py:class:`Material`, optional
    :param material: (optional) A material component describes how an entity should look when rendered.
    :type mesh: :py:class:`Mesh`, optional
    :param mesh: (optional) A mesh component describes a surface to be rendered.
        Volume separating the inside and outside portion of the surface are implicitly represented using
        clockwise and counterclockwise triangles and corresponding surface normal.
        Note: Cannot be assigned if a "volume" component is also assigned.
    :type light: :py:class:`Light`, optional
    :param light: (optional) A light component indicates that any connected geometry should act like a light source.
    :type camera: :py:class:`Camera`, optional
    :param camera: (optional) A camera component indicates that the current entity can be used to view into the scene.
    :type volume: :py:class:`Volume`, optional
    :param volume: (optional) A volume component describes the volumetric particles
        to be rendered. Surfaces within the volume are implicitly defined using extinction.
        Note: Cannot be assigned if a "mesh" component is also assigned.
    :rtype: :py:class:`Entity`
    :return: a reference to an Entity
    """
    return _nvisii.entity_create(name, transform, material, mesh, light, camera, volume)

def entity_get(name):
    r"""
    :type name: string
    :param name: The name of the entity to get
    :rtype: :py:class:`Entity`
    :return: an Entity who's name matches the given name
    """
    return _nvisii.entity_get(name)

def entity_get_count():
    r"""
    :rtype: int
    :return: the number of allocated entities
    """
    return _nvisii.entity_get_count()

def entity_get_name_to_id_map():
    r"""
    :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
    :return: A map whose key is an entity name and whose value is the ID for that entity
    """
    return _nvisii.entity_get_name_to_id_map()

def entity_remove(name):
    r"""
    :type name: string
    :param name: The name of the Entity to remove
    """
    return _nvisii.entity_remove(name)

def entity_initialize_factory(max_components):
    r""" Allocates the tables used to store all Entity components"""
    return _nvisii.entity_initialize_factory(max_components)

def entity_clear_all():
    r""" Clears any existing entity components. This function can be used to reset a scene."""
    return _nvisii.entity_clear_all()

def entity_are_any_dirty():
    r"""
    :rtype: boolean
    :return: True if any the entities has been modified since the previous frame, and False otherwise
    """
    return _nvisii.entity_are_any_dirty()

def entity_get_dirty_entities():
    r"""
    :rtype: std::set< nvisii::Entity * >
    :return: a list of entities that have been modified since the previous frame
    """
    return _nvisii.entity_get_dirty_entities()

def entity_get_renderable_entities():
    r"""
    :rtype: std::set< nvisii::Entity * >
    :return: a list of entities that are renderable (ie, can be seen) by the camera. (note, currently ignores visibility)
    """
    return _nvisii.entity_get_renderable_entities()

class light(static_factory):
    r"""
    A "Light" component illuminates objects in a scene. Light components must
    be added to an entity with a transform component to have a visible
    impact on the scene.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def create(name):
        r"""
        Constructs a light with the given name.

        :type name: string
        :param name: A unique name for this light
        :rtype: :py:class:`Light`
        :return: a reference to a light component
        """
        return _nvisii.light_create(name)

    @staticmethod
    def create_from_temperature(name, kelvin, intensity):
        r"""
        Constructs a light component which emits a plausible light color based on
        standard temperature measurement.

        :type name: string
        :param name: A unique name for this light
        :type kelvin: float
        :param kelvin: The temperature of the black body light.
            Typical values range from 1000K (very warm) to 12000K (very cold).
        :type intensity: float
        :param intensity: How powerful the light source is in emitting light
        :rtype: :py:class:`Light`
        :return: a reference to a light component
        """
        return _nvisii.light_create_from_temperature(name, kelvin, intensity)

    @staticmethod
    def create_from_rgb(name, color, intensity):
        r"""
        Constructs a light component which emits a given light color.

        :type name: string
        :param name: A unique name for this light.
        :type color: :py:class:`vec3`
        :param color: An RGB color to emit. Values should range between 0 and 1.
        :type intensity: float
        :param intensity: How powerful the light source is in emitting light
        """
        return _nvisii.light_create_from_rgb(name, color, intensity)

    @staticmethod
    def get(name):
        r"""
        :type name: string
        :param name: The name of the light to get
        :rtype: :py:class:`Light`
        :return: a Light who's name matches the given name
        """
        return _nvisii.light_get(name)

    @staticmethod
    def get_front_struct():
        r"""
        :rtype: LightStruct
        :return: a pointer to the table of LightStructs required for rendering
        """
        return _nvisii.light_get_front_struct()

    @staticmethod
    def get_front():
        r"""
        :rtype: :py:class:`Light`
        :return: a pointer to the table of light components
        """
        return _nvisii.light_get_front()

    @staticmethod
    def get_count():
        r"""
        :rtype: int
        :return: the number of allocated lights
        """
        return _nvisii.light_get_count()

    def get_name(self):
        r"""
        :rtype: string
        :return: the name of this component
        """
        return _nvisii.light_get_name(self)

    @staticmethod
    def get_name_to_id_map():
        r"""
        :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
        :return: A map whose key is a light name and whose value is the ID for
           that light
        """
        return _nvisii.light_get_name_to_id_map()

    @staticmethod
    def remove(name):
        r"""
        :type name: string
        :param name: The name of the Light to remove
        """
        return _nvisii.light_remove(name)

    @staticmethod
    def initialize_factory(max_components):
        r""" Allocates the tables used to store all light components"""
        return _nvisii.light_initialize_factory(max_components)

    @staticmethod
    def is_factory_initialized():
        r"""
        :rtype: boolean
        :return: True if the tables used to store all light components have been
           allocated, and False otherwise
        """
        return _nvisii.light_is_factory_initialized()

    def is_initialized(self):
        r"""
        :rtype: boolean
        :return: True the current light is a valid, initialized light, and False
           if the light was cleared or removed.
        """
        return _nvisii.light_is_initialized(self)

    @staticmethod
    def update_components():
        r"""
         Iterates through all light components, computing light metadata for
        rendering purposes.
        """
        return _nvisii.light_update_components()

    @staticmethod
    def clear_all():
        r""" Clears any existing light components."""
        return _nvisii.light_clear_all()

    def to_string(self):
        r"""
        :rtype: string
        :return: a json string representation of the current component
        """
        return _nvisii.light_to_string(self)

    @staticmethod
    def are_any_dirty():
        r"""
        :rtype: boolean
        :return: True if any the light has been modified since the previous frame,
           and False otherwise
        """
        return _nvisii.light_are_any_dirty()

    def is_dirty(self):
        r"""
        :rtype: boolean
        :return: True if this lightmaterial has been modified since the previous
           frame, and False otherwise
        """
        return _nvisii.light_is_dirty(self)

    def is_clean(self):
        r"""
        :rtype: boolean
        :return: True if the light has not been modified since the previous frame,
           and False otherwise
        """
        return _nvisii.light_is_clean(self)

    def mark_dirty(self):
        r""" Tags the current component as being modified since the previous frame."""
        return _nvisii.light_mark_dirty(self)

    def get_struct(self):
        r""" Returns the simplified struct used to represent the current component"""
        return _nvisii.light_get_struct(self)

    def mark_clean(self):
        r""" Tags the current component as being unmodified since the previous frame."""
        return _nvisii.light_mark_clean(self)

    @staticmethod
    def get_edit_mutex():
        r"""
         For internal use. Returns the mutex used to lock entities for processing
        by the renderer.
        """
        return _nvisii.light_get_edit_mutex()

    def set_color(self, color):
        r"""
        Sets the color which this light component will emit.

        :param The: RGB color emitted that this light should emit.
        """
        return _nvisii.light_set_color(self, color)

    def set_color_texture(self, texture):
        r"""
        Sets the color which this light component will emit. Texture is expected
        to be RGB. Overrides any existing constant light color.

        :type texture: :py:class:`Texture`
        :param texture: An RGB texture component whose values range between 0 and 1.
            Alpha channel is ignored.
        """
        return _nvisii.light_set_color_texture(self, texture)

    def clear_color_texture(self):
        r"""
         Disconnects the color texture, reverting back to any existing constant
        light color
        """
        return _nvisii.light_clear_color_texture(self)

    def get_color(self):
        r"""
        :rtype: :py:class:`vec3`
        :return: the constant vec3 color used by this light. If a color texture
           is set, this function should not be used.
        """
        return _nvisii.light_get_color(self)

    def set_temperature(self, kelvin):
        r"""
        Sets a realistic emission color via a temperature.

        :type kelvin: float
        :param kelvin: The temperature of the black body light. Typical values
            range from 1000K (very warm) to 12000K (very cold).
        """
        return _nvisii.light_set_temperature(self, kelvin)

    def set_intensity(self, intensity):
        r"""
        Sets the intensity, or brightness, that this light component will emit
        it's color.

        :type intensity: float
        :param intensity: How powerful the light source is in emitting light
        """
        return _nvisii.light_set_intensity(self, intensity)

    def get_intensity(self):
        r"""
        :rtype: float
        :return: the constant intensity used by this light.
        """
        return _nvisii.light_get_intensity(self)

    def set_exposure(self, exposure):
        r"""
        Modifies the intensity, or brightness, that this light component will emit
        it's color by a power of 2.
        Increasing the exposure by 1 will double the energy emitted by the light.
        An exposure of 0 produces an unmodified intensity.
        An exposure of -1 cuts the intensity of the light in half.
        light_intensity = intensity * pow(2, exposureExposure)

        :type exposure: float
        :param exposure: How powerful the light source is in emitting light.
        """
        return _nvisii.light_set_exposure(self, exposure)

    def get_exposure(self):
        r"""
        :rtype: float
        :return: the constant exposure used by this light.
        """
        return _nvisii.light_get_exposure(self)

    def set_falloff(self, falloff):
        r"""
        Modifies the falloff exponent that this light component will use to reduce
        intensity due to distance. Physically realistic light transport uses an
        r^2 falloff, where the falloff exponent equals 2. Many video games instead
        use a linear falloff (falloff = 1). Distance falloff can be disabled
        in its entirety by setting falloff to 0.

        :type falloff: float
        :param falloff: The distance falloff exponent to use.
        """
        return _nvisii.light_set_falloff(self, falloff)

    def get_falloff(self):
        r"""
        :rtype: float
        :return: the distance falloff exponent used by this light.
        """
        return _nvisii.light_get_falloff(self)

    def use_surface_area(self, use):
        r"""
        Controls whether or not the surface area of the light should effect
        overall light intensity.
        :type use: boolean
        :param use: if True, allows the area of the light to affect intensity.
        """
        return _nvisii.light_use_surface_area(self, use)
    __swig_destroy__ = _nvisii.delete_light

# Register light in _nvisii:
_nvisii.light_swigregister(light)

def light_create(name):
    r"""
    Constructs a light with the given name.

    :type name: string
    :param name: A unique name for this light
    :rtype: :py:class:`Light`
    :return: a reference to a light component
    """
    return _nvisii.light_create(name)

def light_create_from_temperature(name, kelvin, intensity):
    r"""
    Constructs a light component which emits a plausible light color based on
    standard temperature measurement.

    :type name: string
    :param name: A unique name for this light
    :type kelvin: float
    :param kelvin: The temperature of the black body light.
        Typical values range from 1000K (very warm) to 12000K (very cold).
    :type intensity: float
    :param intensity: How powerful the light source is in emitting light
    :rtype: :py:class:`Light`
    :return: a reference to a light component
    """
    return _nvisii.light_create_from_temperature(name, kelvin, intensity)

def light_create_from_rgb(name, color, intensity):
    r"""
    Constructs a light component which emits a given light color.

    :type name: string
    :param name: A unique name for this light.
    :type color: :py:class:`vec3`
    :param color: An RGB color to emit. Values should range between 0 and 1.
    :type intensity: float
    :param intensity: How powerful the light source is in emitting light
    """
    return _nvisii.light_create_from_rgb(name, color, intensity)

def light_get(name):
    r"""
    :type name: string
    :param name: The name of the light to get
    :rtype: :py:class:`Light`
    :return: a Light who's name matches the given name
    """
    return _nvisii.light_get(name)

def light_get_front_struct():
    r"""
    :rtype: LightStruct
    :return: a pointer to the table of LightStructs required for rendering
    """
    return _nvisii.light_get_front_struct()

def light_get_front():
    r"""
    :rtype: :py:class:`Light`
    :return: a pointer to the table of light components
    """
    return _nvisii.light_get_front()

def light_get_count():
    r"""
    :rtype: int
    :return: the number of allocated lights
    """
    return _nvisii.light_get_count()

def light_get_name_to_id_map():
    r"""
    :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
    :return: A map whose key is a light name and whose value is the ID for
       that light
    """
    return _nvisii.light_get_name_to_id_map()

def light_remove(name):
    r"""
    :type name: string
    :param name: The name of the Light to remove
    """
    return _nvisii.light_remove(name)

def light_initialize_factory(max_components):
    r""" Allocates the tables used to store all light components"""
    return _nvisii.light_initialize_factory(max_components)

def light_is_factory_initialized():
    r"""
    :rtype: boolean
    :return: True if the tables used to store all light components have been
       allocated, and False otherwise
    """
    return _nvisii.light_is_factory_initialized()

def light_update_components():
    r"""
     Iterates through all light components, computing light metadata for
    rendering purposes.
    """
    return _nvisii.light_update_components()

def light_clear_all():
    r""" Clears any existing light components."""
    return _nvisii.light_clear_all()

def light_are_any_dirty():
    r"""
    :rtype: boolean
    :return: True if any the light has been modified since the previous frame,
       and False otherwise
    """
    return _nvisii.light_are_any_dirty()

def light_get_edit_mutex():
    r"""
     For internal use. Returns the mutex used to lock entities for processing
    by the renderer.
    """
    return _nvisii.light_get_edit_mutex()

class texture(static_factory):
    r"""The "Texture" component describes a 2D pattern used to drive the "Material" component's parameters."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def create_from_image(name, path, linear=False):
        r"""Deprecated. Please use createFromFile."""
        return _nvisii.texture_create_from_image(name, path, linear)

    @staticmethod
    def create_from_file(name, path, linear=False):
        r"""
        Constructs a Texture with the given name from a file.
        :type name: string
        :param name: The name of the texture to create.
            Supported formats include JPEG, PNG, TGA, BMP, PSD, GIF, HDR, PIC, PNM, KTX, and DDS
        :type path: string
        :param path: The path to the image.
        :type linear: boolean, optional
        :param linear: Indicates the image is already linear and should not be gamma corrected. Ignored for KTX, DDS, and HDR formats.
        :rtype: :py:class:`Texture`
        :return: a Texture allocated by the renderer.
        """
        return _nvisii.texture_create_from_file(name, path, linear)

    @staticmethod
    def create_from_data(name, width, height, data, linear=True, hdr=False):
        r"""
        Constructs a Texture with the given name from custom user data.
        :type name: string
        :param name: The name of the texture to create.
        :type width: int
        :param width: The width of the image.
        :type height: int
        :param height: The height of the image.
        :type data: float
        :param data: A row major flattened vector of RGBA texels. The length of this vector should be 4 * width * height.
        :type linear: boolean, optional
        :param linear: Indicates the image is already linear and should not be gamma corrected. Note, defaults to True for this function.
        :type hdr: boolean, optional
        :param hdr: If true, represents the channels of the texture using 32 bit floats. Otherwise, textures are stored natively using 8 bits per channel.
        :rtype: :py:class:`Texture`
        :return: a Texture allocated by the renderer.
        """
        return _nvisii.texture_create_from_data(name, width, height, data, linear, hdr)

    @staticmethod
    def create_mix(name, a, b, mix=1.0, hdr=False):
        r"""
        Constructs a Texture with the given name that mixes two different textures together.
        :type name: string
        :param name: The name of the texture to create.
        :type a: :py:class:`Texture`
        :param a: The first of two textures to mix.
        :type b: :py:class:`Texture`
        :param b: The second of two textures to mix.
        :type mix: float, optional
        :param mix: A value between 0 and 1 used to mix between the first and second textures.
        :type hdr: boolean, optional
        :param hdr: If true, represents the channels of the texture using 32 bit floats. Otherwise, textures are stored natively using 8 bits per channel.
        :rtype: :py:class:`Texture`
        :return: a Texture allocated by the renderer.
        """
        return _nvisii.texture_create_mix(name, a, b, mix, hdr)

    @staticmethod
    def create_add(name, a, b, hdr=False):
        r"""
        Constructs a Texture with the given name that adds two different textures together.
        :type name: string
        :param name: The name of the texture to create.
        :type a: :py:class:`Texture`
        :param a: The first of two textures to add.
        :type b: :py:class:`Texture`
        :param b: The second of two textures to add.
        :type hdr: boolean, optional
        :param hdr: If true, represents the channels of the texture using 32 bit floats. Otherwise, textures are stored natively using 8 bits per channel.
        :rtype: :py:class:`Texture`
        :return: a Texture allocated by the renderer.
        """
        return _nvisii.texture_create_add(name, a, b, hdr)

    @staticmethod
    def create_multiply(name, a, b, hdr=False):
        r"""
        Constructs a Texture with the given name that multiplies two different textures together.
        :type name: string
        :param name: The name of the texture to create.
        :type a: :py:class:`Texture`
        :param a: The first of two textures to multiply.
        :type b: :py:class:`Texture`
        :param b: The second of two textures to multiply.
        :type hdr: boolean, optional
        :param hdr: If true, represents the channels of the texture using 32 bit floats. Otherwise, textures are stored natively using 8 bits per channel.
        :rtype: :py:class:`Texture`
        :return: a Texture allocated by the renderer.
        """
        return _nvisii.texture_create_multiply(name, a, b, hdr)

    @staticmethod
    def create_hsv(name, tex, hue, saturation, value, mix=1.0, hdr=False):
        r"""
        Constructs a Texture with the given name by applying a color transformation on the HSV space to an existing texture.
        :type name: string
        :param name: The name of the texture to create.
        :param t: The texture to take pixels from
        :type hue: float
        :param hue: Specifies the hue rotation of the image. 360 degrees are mapped to [0,1].
            The hue shifts of 0 (-180) and 1 (180) have the same result.
        :type saturation: float
        :param saturation: A saturation of 0 removes hues from the image, resulting in a grayscale image.
            A shift greater than 1.0 increases saturation.
        :type value: float
        :param value: is the overall brightness of the image. De/Increasing values shift an image darker/lighter.
        :type mix: float, optional
        :param mix: A value between 0 and 1 used to mix between the original input and the HSV transformed image.
        :type hdr: boolean, optional
        :param hdr: If true, represents the channels of the texture using 32 bit floats. Otherwise, textures are stored natively using 8 bits per channel.
        :rtype: :py:class:`Texture`
        :return: a Texture allocated by the renderer.
        """
        return _nvisii.texture_create_hsv(name, tex, hue, saturation, value, mix, hdr)

    @staticmethod
    def get(name):
        r"""
        :type name: string
        :param name: The name of the Texture to get
        :rtype: :py:class:`Texture`
        :return: a Texture who's name matches the given name
        """
        return _nvisii.texture_get(name)

    @staticmethod
    def get_front_struct():
        r"""
        :rtype: TextureStruct
        :return: a pointer to the table of TextureStructs
        """
        return _nvisii.texture_get_front_struct()

    @staticmethod
    def get_front():
        r"""
        :rtype: :py:class:`Texture`
        :return: a pointer to the table of Texture components
        """
        return _nvisii.texture_get_front()

    @staticmethod
    def get_count():
        r"""
        :rtype: int
        :return: the number of allocated textures
        """
        return _nvisii.texture_get_count()

    def get_name(self):
        r"""
        :rtype: string
        :return: the name of this component
        """
        return _nvisii.texture_get_name(self)

    def get_id(self):
        r"""
        :rtype: int
        :return: the unique integer ID for this component
        """
        return _nvisii.texture_get_id(self)

    def get_address(self):
        return _nvisii.texture_get_address(self)

    @staticmethod
    def get_name_to_id_map():
        r"""
        :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
        :return: A map whose key is a texture name and whose value is the ID for that texture
        """
        return _nvisii.texture_get_name_to_id_map()

    @staticmethod
    def remove(name):
        r"""
        :type name: string
        :param name: The name of the Texture to remove
        """
        return _nvisii.texture_remove(name)

    @staticmethod
    def initialize_factory(max_components):
        r""" Allocates the tables used to store all Texture components"""
        return _nvisii.texture_initialize_factory(max_components)

    @staticmethod
    def is_factory_initialized():
        r"""
        :rtype: boolean
        :return: True if the tables used to store all Texture components have been allocated, and False otherwise
        """
        return _nvisii.texture_is_factory_initialized()

    def is_initialized(self):
        r"""
        :rtype: boolean
        :return: True the current Texture is a valid, initialized Texture, and False if the Texture was cleared or removed.
        """
        return _nvisii.texture_is_initialized(self)

    @staticmethod
    def update_components():
        r""" Iterates through all components, updating any component struct fields and marking components as clean."""
        return _nvisii.texture_update_components()

    @staticmethod
    def clear_all():
        r""" Clears any existing Texture components."""
        return _nvisii.texture_clear_all()

    @staticmethod
    def are_any_dirty():
        r""" Indicates whether or not any entities are "out of date" and need to be updated through the "update components" function"""
        return _nvisii.texture_are_any_dirty()

    @staticmethod
    def get_dirty_textures():
        r"""
        :rtype: std::set< nvisii::Texture * >
        :return: a list of textures that have been modified since the previous frame
        """
        return _nvisii.texture_get_dirty_textures()

    def mark_dirty(self):
        r""" Tags the current component as being modified since the previous frame."""
        return _nvisii.texture_mark_dirty(self)

    @staticmethod
    def get_edit_mutex():
        r""" For internal use. Returns the mutex used to lock entities for processing by the renderer."""
        return _nvisii.texture_get_edit_mutex()

    def to_string(self):
        r"""
        :rtype: string
        :return: a json string representation of the current component
        """
        return _nvisii.texture_to_string(self)

    def get_float_texels(self):
        r"""
        :rtype: std::vector< vec4,std::allocator< vec4 > >
        :return: a flattened list of 32-bit float texels
        """
        return _nvisii.texture_get_float_texels(self)

    def get_byte_texels(self):
        r"""
        :rtype: std::vector< u8vec4,std::allocator< u8vec4 > >
        :return: a flattened list of 8-bit texels
        """
        return _nvisii.texture_get_byte_texels(self)

    def sample_float_texels(self, uv):
        r"""
        Sample the texture at the given texture coordinates
        :type uv: vec2
        :param uv: A pair of values between [0,0] and [1,1]
        :rtype: vec4
        :return: a sampled texture value
        """
        return _nvisii.texture_sample_float_texels(self, uv)

    def sample_byte_texels(self, uv):
        r"""
        Sample the texture at the given texture coordinates
        :type uv: vec2
        :param uv: A pair of values between [0,0] and [1,1]
        :rtype: u8vec4
        :return: a sampled texture value
        """
        return _nvisii.texture_sample_byte_texels(self, uv)

    def get_width(self):
        r"""
        :rtype: int
        :return: the width of the texture in texels
        """
        return _nvisii.texture_get_width(self)

    def get_height(self):
        r"""
        :rtype: int
        :return: the height of the texture in texels
        """
        return _nvisii.texture_get_height(self)

    def set_scale(self, scale):
        r"""
        Sets the "scale" of a texture. Useful for patterns that repeat, eg tiles.
        Under the hood, this scales the texture coordinates of the object this texture influences.
        :type scale: :py:class:`vec2`
        :param scale: The scale of the texture. A value of [.5,.5] will cause a texture to take
            up half the footprint in UV space of the original texture, effectively causing the texture
            to repeat in a pattern. Textures can be flipped in either U and/or V using negative scales.
        """
        return _nvisii.texture_set_scale(self, scale)

    def is_hdr(self):
        r"""
        :rtype: boolean
        :return: True if the texture contains any values above 1
        """
        return _nvisii.texture_is_hdr(self)

    def is_linear(self):
        r"""
        :rtype: boolean
        :return: True if the texture is represented linearly. Otherwise, the texture is in sRGB space
        """
        return _nvisii.texture_is_linear(self)

# Register texture in _nvisii:
_nvisii.texture_swigregister(texture)

def texture_create_from_image(name, path, linear=False):
    r"""Deprecated. Please use createFromFile."""
    return _nvisii.texture_create_from_image(name, path, linear)

def texture_create_from_file(name, path, linear=False):
    r"""
    Constructs a Texture with the given name from a file.
    :type name: string
    :param name: The name of the texture to create.
        Supported formats include JPEG, PNG, TGA, BMP, PSD, GIF, HDR, PIC, PNM, KTX, and DDS
    :type path: string
    :param path: The path to the image.
    :type linear: boolean, optional
    :param linear: Indicates the image is already linear and should not be gamma corrected. Ignored for KTX, DDS, and HDR formats.
    :rtype: :py:class:`Texture`
    :return: a Texture allocated by the renderer.
    """
    return _nvisii.texture_create_from_file(name, path, linear)

def texture_create_from_data(name, width, height, data, linear=True, hdr=False):
    r"""
    Constructs a Texture with the given name from custom user data.
    :type name: string
    :param name: The name of the texture to create.
    :type width: int
    :param width: The width of the image.
    :type height: int
    :param height: The height of the image.
    :type data: float
    :param data: A row major flattened vector of RGBA texels. The length of this vector should be 4 * width * height.
    :type linear: boolean, optional
    :param linear: Indicates the image is already linear and should not be gamma corrected. Note, defaults to True for this function.
    :type hdr: boolean, optional
    :param hdr: If true, represents the channels of the texture using 32 bit floats. Otherwise, textures are stored natively using 8 bits per channel.
    :rtype: :py:class:`Texture`
    :return: a Texture allocated by the renderer.
    """
    return _nvisii.texture_create_from_data(name, width, height, data, linear, hdr)

def texture_create_mix(name, a, b, mix=1.0, hdr=False):
    r"""
    Constructs a Texture with the given name that mixes two different textures together.
    :type name: string
    :param name: The name of the texture to create.
    :type a: :py:class:`Texture`
    :param a: The first of two textures to mix.
    :type b: :py:class:`Texture`
    :param b: The second of two textures to mix.
    :type mix: float, optional
    :param mix: A value between 0 and 1 used to mix between the first and second textures.
    :type hdr: boolean, optional
    :param hdr: If true, represents the channels of the texture using 32 bit floats. Otherwise, textures are stored natively using 8 bits per channel.
    :rtype: :py:class:`Texture`
    :return: a Texture allocated by the renderer.
    """
    return _nvisii.texture_create_mix(name, a, b, mix, hdr)

def texture_create_add(name, a, b, hdr=False):
    r"""
    Constructs a Texture with the given name that adds two different textures together.
    :type name: string
    :param name: The name of the texture to create.
    :type a: :py:class:`Texture`
    :param a: The first of two textures to add.
    :type b: :py:class:`Texture`
    :param b: The second of two textures to add.
    :type hdr: boolean, optional
    :param hdr: If true, represents the channels of the texture using 32 bit floats. Otherwise, textures are stored natively using 8 bits per channel.
    :rtype: :py:class:`Texture`
    :return: a Texture allocated by the renderer.
    """
    return _nvisii.texture_create_add(name, a, b, hdr)

def texture_create_multiply(name, a, b, hdr=False):
    r"""
    Constructs a Texture with the given name that multiplies two different textures together.
    :type name: string
    :param name: The name of the texture to create.
    :type a: :py:class:`Texture`
    :param a: The first of two textures to multiply.
    :type b: :py:class:`Texture`
    :param b: The second of two textures to multiply.
    :type hdr: boolean, optional
    :param hdr: If true, represents the channels of the texture using 32 bit floats. Otherwise, textures are stored natively using 8 bits per channel.
    :rtype: :py:class:`Texture`
    :return: a Texture allocated by the renderer.
    """
    return _nvisii.texture_create_multiply(name, a, b, hdr)

def texture_create_hsv(name, tex, hue, saturation, value, mix=1.0, hdr=False):
    r"""
    Constructs a Texture with the given name by applying a color transformation on the HSV space to an existing texture.
    :type name: string
    :param name: The name of the texture to create.
    :param t: The texture to take pixels from
    :type hue: float
    :param hue: Specifies the hue rotation of the image. 360 degrees are mapped to [0,1].
        The hue shifts of 0 (-180) and 1 (180) have the same result.
    :type saturation: float
    :param saturation: A saturation of 0 removes hues from the image, resulting in a grayscale image.
        A shift greater than 1.0 increases saturation.
    :type value: float
    :param value: is the overall brightness of the image. De/Increasing values shift an image darker/lighter.
    :type mix: float, optional
    :param mix: A value between 0 and 1 used to mix between the original input and the HSV transformed image.
    :type hdr: boolean, optional
    :param hdr: If true, represents the channels of the texture using 32 bit floats. Otherwise, textures are stored natively using 8 bits per channel.
    :rtype: :py:class:`Texture`
    :return: a Texture allocated by the renderer.
    """
    return _nvisii.texture_create_hsv(name, tex, hue, saturation, value, mix, hdr)

def texture_get(name):
    r"""
    :type name: string
    :param name: The name of the Texture to get
    :rtype: :py:class:`Texture`
    :return: a Texture who's name matches the given name
    """
    return _nvisii.texture_get(name)

def texture_get_front_struct():
    r"""
    :rtype: TextureStruct
    :return: a pointer to the table of TextureStructs
    """
    return _nvisii.texture_get_front_struct()

def texture_get_front():
    r"""
    :rtype: :py:class:`Texture`
    :return: a pointer to the table of Texture components
    """
    return _nvisii.texture_get_front()

def texture_get_count():
    r"""
    :rtype: int
    :return: the number of allocated textures
    """
    return _nvisii.texture_get_count()

def texture_get_name_to_id_map():
    r"""
    :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
    :return: A map whose key is a texture name and whose value is the ID for that texture
    """
    return _nvisii.texture_get_name_to_id_map()

def texture_remove(name):
    r"""
    :type name: string
    :param name: The name of the Texture to remove
    """
    return _nvisii.texture_remove(name)

def texture_initialize_factory(max_components):
    r""" Allocates the tables used to store all Texture components"""
    return _nvisii.texture_initialize_factory(max_components)

def texture_is_factory_initialized():
    r"""
    :rtype: boolean
    :return: True if the tables used to store all Texture components have been allocated, and False otherwise
    """
    return _nvisii.texture_is_factory_initialized()

def texture_update_components():
    r""" Iterates through all components, updating any component struct fields and marking components as clean."""
    return _nvisii.texture_update_components()

def texture_clear_all():
    r""" Clears any existing Texture components."""
    return _nvisii.texture_clear_all()

def texture_are_any_dirty():
    r""" Indicates whether or not any entities are "out of date" and need to be updated through the "update components" function"""
    return _nvisii.texture_are_any_dirty()

def texture_get_dirty_textures():
    r"""
    :rtype: std::set< nvisii::Texture * >
    :return: a list of textures that have been modified since the previous frame
    """
    return _nvisii.texture_get_dirty_textures()

def texture_get_edit_mutex():
    r""" For internal use. Returns the mutex used to lock entities for processing by the renderer."""
    return _nvisii.texture_get_edit_mutex()

class volume(static_factory):
    r"""
    The "Volume" component is essentially the dual of a mesh component.
    As a result, entities can have a mesh component or a volume component attached,
    but not both.

    With a mesh component, surfaces are explicitly defined using triangles, and
    the volumes separating that surface are implicit (eg air outside vs glass inside).
    With a Volume component, that's reversed. Voxels are used to explicitly represent
    the density of particles in space, and surfaces are implicitly defined in areas
    where particles are dense.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def create_from_file(name, path):
        r"""
        Constructs a Volume with the given name from a file.
        :type name: string
        :param name: The name of the volume to create.
            Supported formats include NanoVDB (.nvdb)
        :type path: string
        :param path: The path to the file.
        :rtype: :py:class:`Volume`
        :return: a Volume allocated by the renderer.
        """
        return _nvisii.volume_create_from_file(name, path)

    @staticmethod
    def create_sphere(name):
        r"""
        Creates a sparse fog volume of a sphere such that the exterior
        is 0 and inactive, the interior is active with values varying
        smoothly from 0 at the surface of the sphere to 1 at the half
        width and interior of the sphere.
        """
        return _nvisii.volume_create_sphere(name)

    @staticmethod
    def create_torus(name):
        r"""
        Creates a sparse fog volume of a torus in the xz-plane such
        that the exterior is 0 and inactive, the interior is active with
        values varying smoothly from 0 at the surface of the torus to 1
        at the half width and interior of the torus.
        """
        return _nvisii.volume_create_torus(name)

    @staticmethod
    def create_box(name):
        r"""
        Creates a sparse fog volume of a box such that the exterior
        is 0 and inactive, the interior is active with values varying
        smoothly from 0 at the surface of the box to 1 at the half width
        and interior of the box.
        """
        return _nvisii.volume_create_box(name)

    @staticmethod
    def create_octahedron(name):
        r"""
        Creates a sparse fog volume of an octahedron such that the exterior
        is 0 and inactive, the interior is active with values varying
        smoothly from 0 at the surface of the octahedron to 1 at the half width
        and interior of the octahedron
        """
        return _nvisii.volume_create_octahedron(name)

    @staticmethod
    def create_from_data(name, width, height, depth, data, background):
        r"""
        Constructs a Volume with the given name from custom user data.
        :type name: string
        :param name: The name of the volume to create.
        :type width: int
        :param width: The width of the volume.
        :type height: int
        :param height: The height of the volume.
        :type depth: int
        :param depth: The depth of the volume.
        :type data: float
        :param data: A row major flattened vector of single-scalar voxels.
            The length of this vector should be width * height * depth.
        :type background: float
        :param background: If a voxel matches this value, that voxel is considered
            as "empty". This is used to "sparcify" the volume and save memory.
        """
        return _nvisii.volume_create_from_data(name, width, height, depth, data, background)

    @staticmethod
    def get(name):
        r"""
        :type name: string
        :param name: The name of the Volume to get
        :rtype: :py:class:`Volume`
        :return: a Volume who's name matches the given name
        """
        return _nvisii.volume_get(name)

    @staticmethod
    def get_front_struct():
        r"""
        :rtype: VolumeStruct
        :return: a pointer to the table of VolumeStructs
        """
        return _nvisii.volume_get_front_struct()

    @staticmethod
    def get_front():
        r"""
        :rtype: :py:class:`Volume`
        :return: a pointer to the table of Volume components
        """
        return _nvisii.volume_get_front()

    @staticmethod
    def get_count():
        r"""
        :rtype: int
        :return: the number of allocated volumes
        """
        return _nvisii.volume_get_count()

    def get_name(self):
        r"""
        :rtype: string
        :return: the name of this component
        """
        return _nvisii.volume_get_name(self)

    def get_id(self):
        r"""
        :rtype: int
        :return: the unique integer ID for this component
        """
        return _nvisii.volume_get_id(self)

    def get_address(self):
        return _nvisii.volume_get_address(self)

    @staticmethod
    def get_name_to_id_map():
        r"""
        :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
        :return: A map whose key is a volume name and whose value is the ID for
            that volume
        """
        return _nvisii.volume_get_name_to_id_map()

    @staticmethod
    def remove(name):
        r"""
        :type name: string
        :param name: The name of the Volume to remove
        """
        return _nvisii.volume_remove(name)

    @staticmethod
    def initialize_factory(max_components):
        r""" Allocates the tables used to store all Volume components"""
        return _nvisii.volume_initialize_factory(max_components)

    @staticmethod
    def is_factory_initialized():
        r"""
        :rtype: boolean
        :return: True if the tables used to store all Volume components have been
            allocated, and False otherwise
        """
        return _nvisii.volume_is_factory_initialized()

    def is_initialized(self):
        r"""
        :rtype: boolean
        :return: True the current Volume is a valid, initialized Volume, and
            False if the Volume was cleared or removed.
        """
        return _nvisii.volume_is_initialized(self)

    @staticmethod
    def update_components():
        r"""
        Iterates through all components, updating any component struct fields
        and marking components as clean.
        """
        return _nvisii.volume_update_components()

    @staticmethod
    def clear_all():
        r""" Clears any existing Volume components."""
        return _nvisii.volume_clear_all()

    @staticmethod
    def are_any_dirty():
        r"""
        Indicates whether or not any entities are "out of date" and need to be
        updated through the "update components" function
        """
        return _nvisii.volume_are_any_dirty()

    @staticmethod
    def get_dirty_volumes():
        r"""
        :rtype: std::set< nvisii::Volume * >
        :return: a list of volumes that have been modified since the previous
            frame
        """
        return _nvisii.volume_get_dirty_volumes()

    def mark_dirty(self):
        r""" Tags the current component as being modified since the previous frame."""
        return _nvisii.volume_mark_dirty(self)

    @staticmethod
    def get_edit_mutex():
        r"""
        For internal use. Returns the mutex used to lock entities for processing
        by the renderer.
        """
        return _nvisii.volume_get_edit_mutex()

    def to_string(self):
        r"""
        :rtype: string
        :return: a json string representation of the current component
        """
        return _nvisii.volume_to_string(self)

    def get_grid_type(self):
        r"""
        :rtype: string
        :return: the type of the volume's scalar field
        """
        return _nvisii.volume_get_grid_type(self)

    def get_node_count(self, level):
        r"""
        :type level: int
        :param level: The level of nodes being referenced (0->3 = leaf -> root)
        :rtype: int
        :return: the number of nodes, or subvolumes, used to store a volume.
            (See the illustration of the NanoVDB data structure for more details)
        """
        return _nvisii.volume_get_node_count(self, level)

    def get_min_aabb_corner(self, level, node_idx):
        r"""
        :type level: int
        :param level: The level of nodes being referenced (0->3 = leaf -> root).
        :type node_idx: int
        :param node_idx: The index of the node within the selected level.
        :rtype: :py:class:`vec3`
        :return: the minimum node axis aligned bounding box position
        """
        return _nvisii.volume_get_min_aabb_corner(self, level, node_idx)

    def get_max_aabb_corner(self, level, node_idx):
        r"""
        :type level: int
        :param level: The level of nodes being referenced (0->3 = leaf -> root).
        :type node_idx: int
        :param node_idx: The index of the node within the selected level.
        :rtype: :py:class:`vec3`
        :return: the maximum node axis aligned bounding box position
        """
        return _nvisii.volume_get_max_aabb_corner(self, level, node_idx)

    def get_aabb_center(self, level, node_idx):
        r"""
        :type level: int
        :param level: The level of nodes being referenced (0->3 = leaf -> root).
        :type node_idx: int
        :param node_idx: The index of the node within the selected level.
        :rtype: :py:class:`vec3`
        :return: the center of the aligned bounding box for a node
        """
        return _nvisii.volume_get_aabb_center(self, level, node_idx)

    def get_nano_vdbgrid_handle(self):
        r"""
        :rtype: std::shared_ptr< nanovdb::GridHandle< > >
        :return: the handle to the nanovdb grid. For internal purposes.
        """
        return _nvisii.volume_get_nano_vdbgrid_handle(self)

    def set_scale(self, units):
        r""" todo... document"""
        return _nvisii.volume_set_scale(self, units)

    def set_scattering(self, scattering):
        r""" todo... document"""
        return _nvisii.volume_set_scattering(self, scattering)

    def set_absorption(self, absorption):
        r""" todo... document"""
        return _nvisii.volume_set_absorption(self, absorption)

    def set_gradient_factor(self, factor):
        r""" todo... document"""
        return _nvisii.volume_set_gradient_factor(self, factor)

    def get_max(self, level, node_idx):
        r""" todo... document"""
        return _nvisii.volume_get_max(self, level, node_idx)

# Register volume in _nvisii:
_nvisii.volume_swigregister(volume)

def volume_create_from_file(name, path):
    r"""
    Constructs a Volume with the given name from a file.
    :type name: string
    :param name: The name of the volume to create.
        Supported formats include NanoVDB (.nvdb)
    :type path: string
    :param path: The path to the file.
    :rtype: :py:class:`Volume`
    :return: a Volume allocated by the renderer.
    """
    return _nvisii.volume_create_from_file(name, path)

def volume_create_sphere(name):
    r"""
    Creates a sparse fog volume of a sphere such that the exterior
    is 0 and inactive, the interior is active with values varying
    smoothly from 0 at the surface of the sphere to 1 at the half
    width and interior of the sphere.
    """
    return _nvisii.volume_create_sphere(name)

def volume_create_torus(name):
    r"""
    Creates a sparse fog volume of a torus in the xz-plane such
    that the exterior is 0 and inactive, the interior is active with
    values varying smoothly from 0 at the surface of the torus to 1
    at the half width and interior of the torus.
    """
    return _nvisii.volume_create_torus(name)

def volume_create_box(name):
    r"""
    Creates a sparse fog volume of a box such that the exterior
    is 0 and inactive, the interior is active with values varying
    smoothly from 0 at the surface of the box to 1 at the half width
    and interior of the box.
    """
    return _nvisii.volume_create_box(name)

def volume_create_octahedron(name):
    r"""
    Creates a sparse fog volume of an octahedron such that the exterior
    is 0 and inactive, the interior is active with values varying
    smoothly from 0 at the surface of the octahedron to 1 at the half width
    and interior of the octahedron
    """
    return _nvisii.volume_create_octahedron(name)

def volume_create_from_data(name, width, height, depth, data, background):
    r"""
    Constructs a Volume with the given name from custom user data.
    :type name: string
    :param name: The name of the volume to create.
    :type width: int
    :param width: The width of the volume.
    :type height: int
    :param height: The height of the volume.
    :type depth: int
    :param depth: The depth of the volume.
    :type data: float
    :param data: A row major flattened vector of single-scalar voxels.
        The length of this vector should be width * height * depth.
    :type background: float
    :param background: If a voxel matches this value, that voxel is considered
        as "empty". This is used to "sparcify" the volume and save memory.
    """
    return _nvisii.volume_create_from_data(name, width, height, depth, data, background)

def volume_get(name):
    r"""
    :type name: string
    :param name: The name of the Volume to get
    :rtype: :py:class:`Volume`
    :return: a Volume who's name matches the given name
    """
    return _nvisii.volume_get(name)

def volume_get_front_struct():
    r"""
    :rtype: VolumeStruct
    :return: a pointer to the table of VolumeStructs
    """
    return _nvisii.volume_get_front_struct()

def volume_get_front():
    r"""
    :rtype: :py:class:`Volume`
    :return: a pointer to the table of Volume components
    """
    return _nvisii.volume_get_front()

def volume_get_count():
    r"""
    :rtype: int
    :return: the number of allocated volumes
    """
    return _nvisii.volume_get_count()

def volume_get_name_to_id_map():
    r"""
    :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
    :return: A map whose key is a volume name and whose value is the ID for
        that volume
    """
    return _nvisii.volume_get_name_to_id_map()

def volume_remove(name):
    r"""
    :type name: string
    :param name: The name of the Volume to remove
    """
    return _nvisii.volume_remove(name)

def volume_initialize_factory(max_components):
    r""" Allocates the tables used to store all Volume components"""
    return _nvisii.volume_initialize_factory(max_components)

def volume_is_factory_initialized():
    r"""
    :rtype: boolean
    :return: True if the tables used to store all Volume components have been
        allocated, and False otherwise
    """
    return _nvisii.volume_is_factory_initialized()

def volume_update_components():
    r"""
    Iterates through all components, updating any component struct fields
    and marking components as clean.
    """
    return _nvisii.volume_update_components()

def volume_clear_all():
    r""" Clears any existing Volume components."""
    return _nvisii.volume_clear_all()

def volume_are_any_dirty():
    r"""
    Indicates whether or not any entities are "out of date" and need to be
    updated through the "update components" function
    """
    return _nvisii.volume_are_any_dirty()

def volume_get_dirty_volumes():
    r"""
    :rtype: std::set< nvisii::Volume * >
    :return: a list of volumes that have been modified since the previous
        frame
    """
    return _nvisii.volume_get_dirty_volumes()

def volume_get_edit_mutex():
    r"""
    For internal use. Returns the mutex used to lock entities for processing
    by the renderer.
    """
    return _nvisii.volume_get_edit_mutex()

class transform(static_factory):
    r"""
    The "Transform" component places an entity into the scene.
    These transform components represent a scale, a rotation, and a translation, in that order.
    These transform components also keep track of the previous frame scale, rotation, and translation, which
    can optionally be used for creating motion blur and for temporal effects like reprojection.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def create(*args, **kwargs):
        r"""
        Constructs a transform with the given name.

        :type name: string
        :param name: A unique name for this transform.
        :type scale: :py:class:`vec3`, optional
        :param scale: The initial scale of the transform, applied first.
        :type rotation: :py:class:`quat`, optional
        :param rotation: The initial scale of the transform, applied after scale.
        :type position: :py:class:`vec3`, optional
        :param position: The initial position of the transform, applied after rotation.
        :rtype: :py:class:`Transform`
        :return: a reference to a transform component
        """
        return _nvisii.transform_create(*args, **kwargs)

    @staticmethod
    def create_from_matrix(*args, **kwargs):
        r"""
        Constructs a transform with the given name, initializing with the given matrix.

        :type name: string
        :param name: A unique name for this transform.
        :param matrix: The initial local to world transformation to be applied
        :rtype: :py:class:`Transform`
        :return: a reference to a transform component
        """
        return _nvisii.transform_create_from_matrix(*args, **kwargs)

    @staticmethod
    def get(name):
        r"""
        :type name: string
        :param name: The name of the transform to get
        :rtype: :py:class:`Transform`
        :return: a transform who's name matches the given name
        """
        return _nvisii.transform_get(name)

    @staticmethod
    def get_count():
        r"""
        :rtype: int
        :return: the number of allocated transforms
        """
        return _nvisii.transform_get_count()

    def get_name(self):
        r"""
        :rtype: string
        :return: the name of this component
        """
        return _nvisii.transform_get_name(self)

    def get_id(self):
        r"""
        :rtype: int
        :return: the unique integer ID for this component
        """
        return _nvisii.transform_get_id(self)

    def get_address(self):
        return _nvisii.transform_get_address(self)

    @staticmethod
    def get_name_to_id_map():
        r"""
        :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
        :return: A map whose key is a transform name and whose value is the ID for that transform
        """
        return _nvisii.transform_get_name_to_id_map()

    @staticmethod
    def remove(name):
        r"""
        :type name: string
        :param name: The name of the transform to remove
        """
        return _nvisii.transform_remove(name)

    @staticmethod
    def initialize_factory(max_components):
        r""" Allocates the tables used to store all transform components"""
        return _nvisii.transform_initialize_factory(max_components)

    def is_initialized(self):
        r"""
        :rtype: boolean
        :return: True the current transform is a valid, initialized transform, and False if the transform was cleared or removed.
        """
        return _nvisii.transform_is_initialized(self)

    @staticmethod
    def clear_all():
        r""" Clears any existing transform components."""
        return _nvisii.transform_clear_all()

    @staticmethod
    def are_any_dirty():
        r"""
        :rtype: boolean
        :return: True if any the transform has been modified since the previous frame, and False otherwise
        """
        return _nvisii.transform_are_any_dirty()

    @staticmethod
    def get_dirty_transforms():
        r"""
        :rtype: std::set< nvisii::Transform * >
        :return: a list of transforms that have been modified since the previous frame
        """
        return _nvisii.transform_get_dirty_transforms()

    def to_string(self):
        r"""
        :rtype: string
        :return: a json string representation of the current component
        """
        return _nvisii.transform_to_string(self)

    def transform_direction(self, direction, previous=False):
        r"""
        Transforms direction from local to parent.
        This operation is not affected by scale or position of the transform.
        The returned vector has the same length as the input direction.

        :type direction: :py:class:`vec3`
        :param direction: The direction to apply the transform to.
        :type previous: boolean, optional
        :param previous: If true, uses the previous transform as the transform to apply.
        :rtype: :py:class:`vec3`
        :return: The transformed direction.
        """
        return _nvisii.transform_transform_direction(self, direction, previous)

    def transform_point(self, point, previous=False):
        r"""
        Transforms position from local to parent. Note, affected by scale.
        The opposite conversion, from parent to local, can be done with Transform.inverse_transform_point

        :type point: :py:class:`vec3`
        :param point: The point to apply the transform to.
        :type previous: boolean, optional
        :param previous: If true, uses the previous transform as the transform to apply.
        :rtype: :py:class:`vec3`
        :return: The transformed point.
        """
        return _nvisii.transform_transform_point(self, point, previous)

    def transform_vector(self, vector, previous=False):
        r"""
        Transforms vector from local to parent.
        This is not affected by position of the transform, but is affected by scale.
        The returned vector may have a different length that the input vector.

        :type vector: :py:class:`vec3`
        :param vector: The vector to apply the transform to.
        :type previous: boolean, optional
        :param previous: If true, uses the previous transform as the transform to apply.
        :rtype: :py:class:`vec3`
        :return: The transformed vector.
        """
        return _nvisii.transform_transform_vector(self, vector, previous)

    def inverse_transform_direction(self, direction, previous=False):
        r"""
        Transforms a direction from parent space to local space.
        The opposite of Transform.transform_direction.
        This operation is unaffected by scale.

        :param point: The direction to apply the inverse transform to.
        :type previous: boolean, optional
        :param previous: If true, uses the previous transform as the transform to apply.
        :rtype: :py:class:`vec3`
        :return: The transformed direction.
        """
        return _nvisii.transform_inverse_transform_direction(self, direction, previous)

    def inverse_transform_point(self, point, previous=False):
        r"""
        Transforms position from parent space to local space.
        Essentially the opposite of Transform.transform_point.
        Note, affected by scale.

        :type point: :py:class:`vec3`
        :param point: The point to apply the inverse transform to.
        :type previous: boolean, optional
        :param previous: If true, uses the previous transform as the transform to apply.
        :rtype: :py:class:`vec3`
        :return: The transformed point.
        """
        return _nvisii.transform_inverse_transform_point(self, point, previous)

    def inverse_transform_vector(self, vector, previous=False):
        r"""
        Transforms a vector from parent space to local space.
        The opposite of Transform.transform_vector.
        This operation is affected by scale.

        :param point: The vector to apply the inverse transform to.
        :type previous: boolean, optional
        :param previous: If true, uses the previous transform as the transform to apply.
        :rtype: :py:class:`vec3`
        :return: The transformed vector.
        """
        return _nvisii.transform_inverse_transform_vector(self, vector, previous)

    def look_at(self, *args, **kwargs):
        r"""
         Rotates the transform so the forward vector points at the target's current position.
         Then it rotates the transform to point its up direction vector in the direction hinted at
         by the parentUp vector.

        :type at: :py:class:`vec3`
        :param at: The position to point the transform towards
        :type up: :py:class:`vec3`
        :param up: The unit direction pointing upwards
        :type eye: :py:class:`vec3`, optional
        :param eye: (optional) The position to place the object
        :type previous: boolean, optional
        :param previous: If true, edits the previous translation and/or rotation.
        """
        return _nvisii.transform_look_at(self, *args, **kwargs)

    def rotate_around(self, point, quaternion, previous=False):
        r"""
        Rotates the transform through the provided quaternion, passing through the provided point in parent
        coordinates.
        This modifies both the position and rotation of the transform.

        :type point: :py:class:`vec3`
        :param point: The pivot point in space to rotate around.
        :type quaternion: :py:class:`quat`
        :param quaternion: The quaternion to use for rotation.
        :type previous: boolean, optional
        :param previous: If true, edits the previous translation and rotation.
        """
        return _nvisii.transform_rotate_around(self, point, quaternion, previous)

    def set_transform(self, transformation, decompose=True, previous=False):
        r"""
        Sets an optional additional transform, useful for representing normally unsupported transformations
        like sheers and projections.

        :type transformation: :py:class:`mat4`
        :param transformation: a 4 by 4 column major transformation matrix
        :type decompose: boolean, optional
        :param decompose: attempts to use the technique described in "Graphics Gems II: Decomposing a Matrix Into Simple Transformations"
            to represent the transform as a user controllable translation, rotation, and scale.
            If a sheer is detected, or if the decomposition failed, this will fall back to a non-decomposed transformation, and user
            controllable translation, rotation, and scale will be set to identity values.
        :type previous: boolean, optional
        :param previous: If true, edits the previous translation, rotation, and scale.
        """
        return _nvisii.transform_set_transform(self, transformation, decompose, previous)

    def get_rotation(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous rotation.
        :rtype: :py:class:`quat`
        :return: A quaternion rotating the transform from local to parent
        """
        return _nvisii.transform_get_rotation(self, previous)

    def set_rotation(self, newRotation, previous=False):
        r"""
        Sets the rotation of the transform from local to parent via a quaternion

        :type newRotation: :py:class:`quat`
        :param newRotation: The new rotation quaternion to set the current transform quaternion to.
        :type previous: boolean, optional
        :param previous: If true, edits the previous rotation.
        """
        return _nvisii.transform_set_rotation(self, newRotation, previous)

    def set_angle_axis(self, angle, axis, previous=False):
        r"""
        Sets the rotation of the transform from local to parent using an axis
        in local space to rotate about, and an angle in radians to drive the rotation.

        :type angle: float
        :param angle: The angle (in radians) to rotate.
        :type axis: :py:class:`vec3`
        :param axis:  The axis to rotate about.
        :type previous: boolean, optional
        :param previous: If true, edits the previous rotation.
        """
        return _nvisii.transform_set_angle_axis(self, angle, axis, previous)

    def add_rotation(self, additionalRotation, previous=False):
        r"""
        Adds a rotation to the existing transform rotation from local to parent
        via a quaternion.

        :type additionalRotation: :py:class:`quat`
        :param additionalRotation: The rotation quaternion apply to the existing transform quaternion.
        :type previous: boolean, optional
        :param previous: If true, edits the previous rotation.
        """
        return _nvisii.transform_add_rotation(self, additionalRotation, previous)

    def add_angle_axis(self, angle, axis, previous=False):
        r"""
        Adds a rotation to the existing transform rotation from local to parent
        using an axis in local space to rotate about, and an angle in radians to
        drive the rotation

        :type angle: float
        :param angle: The angle (in radians) to rotate the current transform quaterion by.
        :type axis: :py:class:`vec3`
        :param axis:  The axis to rotate about.
        :type previous: boolean, optional
        :param previous: If true, edits the previous rotation.
        """
        return _nvisii.transform_add_angle_axis(self, angle, axis, previous)

    def get_position(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous parent-space position.
        :rtype: :py:class:`vec3`
        :return: a position vector describing where this transform will be translated to in its' parent's space.
        """
        return _nvisii.transform_get_position(self, previous)

    def get_right(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous parent-space right vector.
        :rtype: :py:class:`vec3`
        :return: a vector pointing right relative to the current transform placed in its' parent's space.
        """
        return _nvisii.transform_get_right(self, previous)

    def get_up(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous parent-space up vector.
        :rtype: :py:class:`vec3`
        :return: a vector pointing up relative to the current transform placed in its' parent's space.
        """
        return _nvisii.transform_get_up(self, previous)

    def get_forward(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous parent-space forward vector.
        :rtype: :py:class:`vec3`
        :return: a vector pointing forward relative to the current transform placed in its' parent's space.
        """
        return _nvisii.transform_get_forward(self, previous)

    def get_world_position(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous world-space position.
        :rtype: :py:class:`vec3`
        :return: a position vector describing where this transform will be translated to in world-space.
        """
        return _nvisii.transform_get_world_position(self, previous)

    def get_world_right(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous world-space right vector.
        :rtype: :py:class:`vec3`
        :return: a vector pointing right relative to the current transform placed in world-space.
        """
        return _nvisii.transform_get_world_right(self, previous)

    def get_world_up(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous world-space up vector.
        :rtype: :py:class:`vec3`
        :return: a vector pointing up relative to the current transform placed in world-space.
        """
        return _nvisii.transform_get_world_up(self, previous)

    def get_world_forward(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous world-space forward vector.
        :rtype: :py:class:`vec3`
        :return: a vector pointing forward relative to the current transform placed in world-space.
        """
        return _nvisii.transform_get_world_forward(self, previous)

    def set_position(self, newPosition, previous=False):
        r"""
        Sets the position vector describing where this transform should be translated to when placed in its
        parent space.

        :type newPosition: :py:class:`vec3`
        :param newPosition: The new position to set the current transform position to.
        :type previous: boolean, optional
        :param previous: If true, edits the previous position.
        """
        return _nvisii.transform_set_position(self, newPosition, previous)

    def add_position(self, additionalPosition, previous=False):
        r"""
        Adds to the current the position vector describing where this transform should be translated to
        when placed in its parent space.

        :type additionalPosition: :py:class:`vec3`
        :param additionalPosition: The position (interpreted as a vector) to add onto the current transform position.
        :type previous: boolean, optional
        :param previous: If true, edits the previous position.
        """
        return _nvisii.transform_add_position(self, additionalPosition, previous)

    def get_scale(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous scale.
        :rtype: :py:class:`vec3`
        :return: the scale of this transform from local to parent space along its right, up, and forward
            directions respectively
        """
        return _nvisii.transform_get_scale(self, previous)

    def set_scale(self, newScale, previous=False):
        r"""
        Sets the scale of this transform from local to parent space along its right, up, and forward
        directions respectively.

        :type newScale: :py:class:`vec3`
        :param newScale: The new scale to set the current transform scale to.
        :type previous: boolean, optional
        :param previous: If true, edits the previous scale.
        """
        return _nvisii.transform_set_scale(self, newScale, previous)

    def add_scale(self, additionalScale, previous=False):
        r"""
        Adds to the current the scale of this transform from local to parent space along its right, up,
        and forward directions respectively

        :type additionalScale: :py:class:`vec3`
        :param additionalScale: The scale to add onto the current transform scale.
        :type previous: boolean, optional
        :param previous: If true, edits the previous scale.
        """
        return _nvisii.transform_add_scale(self, additionalScale, previous)

    def set_linear_velocity(self, velocity, frames_per_second=1.0, mix=0.0):
        r"""
        Sets the linear velocity vector describing how fast this transform is translating within its
        parent space. Causes motion blur.

        :type velocity: :py:class:`vec3`
        :param velocity: The new linear velocity to set the current transform linear velocity to, in meters per second.
        :type frames_per_second: float, optional
        :param frames_per_second: Used to convert meters per second into meters per frame. Useful for animations.
        """
        return _nvisii.transform_set_linear_velocity(self, velocity, frames_per_second, mix)

    def set_angular_velocity(self, velocity, frames_per_second=1.0, mix=0.0):
        r"""
        Sets the angular velocity vector describing how fast this transform is rotating within its
        parent space. Causes motion blur.

        :type velocity: :py:class:`quat`
        :param velocity: The new angular velocity to set the current transform angular velocity to, in radians per second.
        :type frames_per_second: float, optional
        :param frames_per_second: Used to convert radians per second into scale per frame. Useful for animations.
        """
        return _nvisii.transform_set_angular_velocity(self, velocity, frames_per_second, mix)

    def set_scalar_velocity(self, velocity, frames_per_second=1.0, mix=0.0):
        r"""
        Sets the scalar velocity vector describing how fast this transform is scaling within its
        parent space. Causes motion blur.

        :type velocity: :py:class:`vec3`
        :param velocity: The new scalar velocity to set the current transform scalar velocity to, in additional scale per second
        :type frames_per_second: float, optional
        :param frames_per_second: Used to convert additional scale per second into additional scale per frame. Useful for animations.
        """
        return _nvisii.transform_set_scalar_velocity(self, velocity, frames_per_second, mix)

    def clear_motion(self):
        r"""Resets any "previous" transform data, effectively clearing any current motion blur."""
        return _nvisii.transform_clear_motion(self)

    def get_parent_to_local_matrix(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous parent-to-local matrix.
        :rtype: :py:class:`mat4`
        :return: the final matrix transforming this object from it's parent coordinate space to it's
            local coordinate space
        """
        return _nvisii.transform_get_parent_to_local_matrix(self, previous)

    def get_local_to_parent_matrix(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous local-to-parent matrix.
        :rtype: :py:class:`mat4`
        :return: the final matrix transforming this object from it's local coordinate space to it's
            parents coordinate space
        """
        return _nvisii.transform_get_local_to_parent_matrix(self, previous)

    def get_local_to_parent_translation_matrix(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous local-to-parent translation matrix.
        :rtype: :py:class:`mat4`
        :return: the final matrix translating this object from it's local coordinate space to it's
            parent coordinate space
        """
        return _nvisii.transform_get_local_to_parent_translation_matrix(self, previous)

    def get_local_to_parent_scale_matrix(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous local-to-parent scale matrix.
        :rtype: :py:class:`mat4`
        :return: the final matrix translating this object from it's local coordinate space to it's
            parent coordinate space
        """
        return _nvisii.transform_get_local_to_parent_scale_matrix(self, previous)

    def get_local_to_parent_rotation_matrix(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous local-to-parent rotation matrix.
        :rtype: :py:class:`mat4`
        :return: the final matrix rotating this object in it's local coordinate space to it's
            parent coordinate space
        """
        return _nvisii.transform_get_local_to_parent_rotation_matrix(self, previous)

    def get_parent_to_local_translation_matrix(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous parent-to-local translation matrix.
        :rtype: :py:class:`mat4`
        :return: the final matrix translating this object from it's parent coordinate space to it's
            local coordinate space
        """
        return _nvisii.transform_get_parent_to_local_translation_matrix(self, previous)

    def get_parent_to_local_scale_matrix(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous parent-to-local scale matrix.
        :rtype: :py:class:`mat4`
        :return: the final matrix scaling this object from it's parent coordinate space to it's
            local coordinate space
        """
        return _nvisii.transform_get_parent_to_local_scale_matrix(self, previous)

    def get_parent_to_local_rotation_matrix(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous parent-to-local rotation matrix.
        :rtype: :py:class:`mat4`
        :return: the final matrix rotating this object from it's parent coordinate space to it's
            local coordinate space
        """
        return _nvisii.transform_get_parent_to_local_rotation_matrix(self, previous)

    def set_parent(self, parent):
        r"""
        Set the parent of this transform, whose transformation will be applied after the current
        transform.

        :type parent: :py:class:`Transform`
        :param parent: The transform component to constrain the current transform to. Any existing parent constraint is replaced.
        """
        return _nvisii.transform_set_parent(self, parent)

    def get_parent(self):
        return _nvisii.transform_get_parent(self)

    def get_children(self):
        return _nvisii.transform_get_children(self)

    def clear_parent(self):
        r""" Removes the parent-child relationship affecting this node."""
        return _nvisii.transform_clear_parent(self)

    def add_child(self, child):
        r"""
        Add a child to this transform, whose transformation will be applied before the current
        transform.

        :type child: :py:class:`Transform`
        :param child: The child transform component to constrain to the current transform. Any existing parent constraint is replaced.
        """
        return _nvisii.transform_add_child(self, child)

    def remove_child(self, child):
        r"""
        Removes a child transform previously added to the current transform.

        :type child: :py:class:`Transform`
        :param child: The constrained child transform component to un-constrain from the current transform. Any existing parent constraint is replaced.
        """
        return _nvisii.transform_remove_child(self, child)

    def get_world_to_local_matrix(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous world-to-local matrix.
        :rtype: :py:class:`mat4`
        :return: a matrix transforming this component from world space to its local space, taking all
            parent transforms into account.
        """
        return _nvisii.transform_get_world_to_local_matrix(self, previous)

    def get_local_to_world_matrix(self, previous=False):
        r"""
        :type previous: boolean, optional
        :param previous: If true, returns the previous local-to-world matrix.
        :rtype: :py:class:`mat4`
        :return: a matrix transforming this component from its local space to world space, taking all
            parent transforms into account.
        """
        return _nvisii.transform_get_local_to_world_matrix(self, previous)
    __swig_destroy__ = _nvisii.delete_transform

# Register transform in _nvisii:
_nvisii.transform_swigregister(transform)

def transform_create(*args, **kwargs):
    r"""
    Constructs a transform with the given name.

    :type name: string
    :param name: A unique name for this transform.
    :type scale: :py:class:`vec3`, optional
    :param scale: The initial scale of the transform, applied first.
    :type rotation: :py:class:`quat`, optional
    :param rotation: The initial scale of the transform, applied after scale.
    :type position: :py:class:`vec3`, optional
    :param position: The initial position of the transform, applied after rotation.
    :rtype: :py:class:`Transform`
    :return: a reference to a transform component
    """
    return _nvisii.transform_create(*args, **kwargs)

def transform_create_from_matrix(*args, **kwargs):
    r"""
    Constructs a transform with the given name, initializing with the given matrix.

    :type name: string
    :param name: A unique name for this transform.
    :param matrix: The initial local to world transformation to be applied
    :rtype: :py:class:`Transform`
    :return: a reference to a transform component
    """
    return _nvisii.transform_create_from_matrix(*args, **kwargs)

def transform_get(name):
    r"""
    :type name: string
    :param name: The name of the transform to get
    :rtype: :py:class:`Transform`
    :return: a transform who's name matches the given name
    """
    return _nvisii.transform_get(name)

def transform_get_count():
    r"""
    :rtype: int
    :return: the number of allocated transforms
    """
    return _nvisii.transform_get_count()

def transform_get_name_to_id_map():
    r"""
    :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
    :return: A map whose key is a transform name and whose value is the ID for that transform
    """
    return _nvisii.transform_get_name_to_id_map()

def transform_remove(name):
    r"""
    :type name: string
    :param name: The name of the transform to remove
    """
    return _nvisii.transform_remove(name)

def transform_initialize_factory(max_components):
    r""" Allocates the tables used to store all transform components"""
    return _nvisii.transform_initialize_factory(max_components)

def transform_clear_all():
    r""" Clears any existing transform components."""
    return _nvisii.transform_clear_all()

def transform_are_any_dirty():
    r"""
    :rtype: boolean
    :return: True if any the transform has been modified since the previous frame, and False otherwise
    """
    return _nvisii.transform_are_any_dirty()

def transform_get_dirty_transforms():
    r"""
    :rtype: std::set< nvisii::Transform * >
    :return: a list of transforms that have been modified since the previous frame
    """
    return _nvisii.transform_get_dirty_transforms()

class material(static_factory):
    r"""
    The "Material" component describes the surface properties of an entity.
    This material follows a physically based workflow, more specifically the
    Blender principled shader, and is very similar to the Disney material model.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def create(*args, **kwargs):
        r"""
        Constructs a material with the given name.

        :rtype: :py:class:`Material`
        :return: a reference to a material component
        :type name: string
        :param name: A unique name for this material.
        :type base_color: :py:class:`vec3`, optional
        :param base_color: The diffuse or metal surface color.
        :type roughness: float, optional
        :param roughness: Microfacet roughness of the surface for diffuse and specular reflection.
        :type metallic: float, optional
        :param metallic: Blends between a non-metallic and metallic material model.
        :type specular: float, optional
        :param specular: The amount of dielectric specular reflection.
        :type specular_tint: float, optional
        :param specular_tint: Tints the facing specular reflection using the base color, while glancing reflection remains white.
        :type transmission: float, optional
        :param transmission: Controls how much the surface looks like glass. Note, metallic takes precedence.
        :type transmission_roughness: float, optional
        :param transmission_roughness: The roughness of the interior surface used for transmitted light.
        :type ior: float, optional
        :param ior: Index of refraction used for transmission events.
        :type alpha: float, optional
        :param alpha: The transparency of the surface, independent of transmission.
        :type subsurface_radius: :py:class:`vec3`, optional
        :param subsurface_radius: Average distance that light scatters below the surface
        :type subsurface_color: :py:class:`vec3`, optional
        :param subsurface_color: The subsurface scattering base color.
        :type subsurface: float, optional
        :param subsurface: Mix between diffuse and subsurface scattering.
        :type anisotropic: float, optional
        :param anisotropic: The amount of anisotropy for specular reflection.
        :type anisotropic_rotation: float, optional
        :param anisotropic_rotation: The angle of anisotropy.
        :type sheen: float, optional
        :param sheen: Amount of soft velvet like reflection near edges, for simulating materials such as cloth.
        :type sheen_tint: float, optional
        :param sheen_tint: Mix between white and using base color for sheen reflection.
        :type clearcoat: float, optional
        :param clearcoat: Extra white specular layer on top of others.
        :type clearcoat_roughness: float, optional
        :param clearcoat_roughness: Microfacet surface roughness of clearcoat specular.
        """
        return _nvisii.material_create(*args, **kwargs)

    @staticmethod
    def get(name):
        r"""
        Gets a material by name

        :rtype: :py:class:`Material`
        :return: a material who's primary name key matches ``name``
        :type name: string
        :param name: A unique name used to lookup this material.
        """
        return _nvisii.material_get(name)

    @staticmethod
    def get_count():
        r"""
        :rtype: int
        :return: the number of allocated materials
        """
        return _nvisii.material_get_count()

    def get_name(self):
        r"""
        :rtype: string
        :return: the name of this component
        """
        return _nvisii.material_get_name(self)

    @staticmethod
    def get_name_to_id_map():
        r"""
        :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
        :return: A map whose key is a material name and whose value is the ID for that material
        """
        return _nvisii.material_get_name_to_id_map()

    @staticmethod
    def remove(name):
        r"""
        :type name: string
        :param name: The name of the material to remove
        """
        return _nvisii.material_remove(name)

    @staticmethod
    def initialize_factory(max_components):
        r""" Allocates the tables used to store all material components"""
        return _nvisii.material_initialize_factory(max_components)

    def is_initialized(self):
        r"""
        :rtype: boolean
        :return: True the current material is a valid, initialized material, and False if the material was cleared or removed.
        """
        return _nvisii.material_is_initialized(self)

    @staticmethod
    def clear_all():
        r""" Clears any existing material components."""
        return _nvisii.material_clear_all()

    @staticmethod
    def are_any_dirty():
        r"""
        :rtype: boolean
        :return: True if any the material has been modified since the previous frame, and False otherwise
        """
        return _nvisii.material_are_any_dirty()

    def to_string(self):
        r""" Returns a json string representation of the current component"""
        return _nvisii.material_to_string(self)

    def set_base_color(self, color):
        r"""
        The diffuse or metal surface color. Ignored if a base color texture is set.

        :type color: :py:class:`vec3`
        :param color: a red, green, blue color intensity vector, usually between 0 and 1
        """
        return _nvisii.material_set_base_color(self, color)

    def set_base_color_texture(self, texture):
        r"""
        The diffuse or metal surface color. Texture is expected to be RGB. Overrides any existing constant base color.

        :type texture: :py:class:`Texture`
        :param texture: An RGB texture component whose values range between 0 and 1. Alpha channel is ignored.
        """
        return _nvisii.material_set_base_color_texture(self, texture)

    def clear_base_color_texture(self):
        r""" Disconnects the base color texture, reverting back to any existing constant base color"""
        return _nvisii.material_clear_base_color_texture(self)

    def get_base_color(self):
        r"""
        The diffuse or metal surface color. Ignored if a base color texture is set.

        :rtype: :py:class:`vec3`
        :return: the color intensity vector
        """
        return _nvisii.material_get_base_color(self)

    def set_subsurface(self, subsurface):
        r"""
        Mix between diffuse and subsurface scattering.

        :type subsurface: float
        :param subsurface: Rather than being a simple mix between Diffuse and Subsurface Scattering,
            this value controls a multiplier for the Subsurface Radius.
        """
        return _nvisii.material_set_subsurface(self, subsurface)

    def set_subsurface_texture(self, texture, channel=0):
        r"""
        Mix between diffuse and subsurface scattering. Overrides any existing constant subsurface

        :type texture: :py:class:`Texture`
        :param texture: A grayscale texture component containing subsurface radius multipliers.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_subsurface_texture(self, texture, channel)

    def clear_subsurface_texture(self):
        r""" Disconnects the subsurface texture, reverting back to any existing constant subsurface"""
        return _nvisii.material_clear_subsurface_texture(self)

    def get_subsurface(self):
        r"""
        Mix between diffuse and subsurface scattering.

        :rtype: float
        :return: the current subsurface radius multiplier.
        """
        return _nvisii.material_get_subsurface(self)

    def set_subsurface_radius(self, subsurfaceRadius):
        r"""
        Average distance that light scatters below the surface. Higher radius gives a softer appearance,
        as light bleeds into shadows and through the object. The scattering distance is specified separately
        for the RGB channels, to render materials such as skin where red light scatters deeper.

        :param subsurface_radius: control the subsurface radius. The X, Y and Z values of this vector are mapped to the R, G and B radius values, respectively.
        """
        return _nvisii.material_set_subsurface_radius(self, subsurfaceRadius)

    def set_subsurface_radius_texture(self, texture):
        r"""
        Average distance that light scatters below the surface. Higher radius gives a softer appearance,
        as light bleeds into shadows and through the object. Overrides any existing constant subsurface radius

        :type texture: :py:class:`Texture`
        :param texture: An RGB texture component controlling the subsurface radius in x, y, and z. Alpha channel is ignored.
        """
        return _nvisii.material_set_subsurface_radius_texture(self, texture)

    def clear_subsurface_radius_texture(self):
        r""" Disconnects the subsurface radius texture, reverting back to any existing constant subsurface radius"""
        return _nvisii.material_clear_subsurface_radius_texture(self)

    def get_subsurface_radius(self):
        r"""
        Average distance that light scatters below the surface. Higher radius gives a softer appearance,
        as light bleeds into shadows and through the object.

        :rtype: :py:class:`vec3`
        :return: The subsurface scattering distance is specified separately for the RGB channels.
        """
        return _nvisii.material_get_subsurface_radius(self)

    def set_subsurface_color(self, color):
        r"""
        The subsurface scattering base color.

        :type color: :py:class:`vec3`
        :param color: the color intensity vector, usually between 0 and 1
        """
        return _nvisii.material_set_subsurface_color(self, color)

    def set_subsurface_color_texture(self, texture):
        r"""
        The subsurface scattering base color. Overrides any existing constant subsurface color

        :type texture: :py:class:`Texture`
        :param texture: An RGB texture whose values range between 0 and 1. Alpha channel is ignored.
        """
        return _nvisii.material_set_subsurface_color_texture(self, texture)

    def clear_subsurface_color_texture(self):
        r""" Disconnects the subsurface color texture, reverting back to any existing constant subsurface color"""
        return _nvisii.material_clear_subsurface_color_texture(self)

    def get_subsurface_color(self):
        return _nvisii.material_get_subsurface_color(self)

    def set_metallic(self, metallic):
        r"""
        Blends between a non-metallic and metallic material model.

        :type metallic: float
        :param metallic: A value of 1.0 gives
            a fully specular reflection tinted with the base color, without diffuse reflection
            or transmission. At 0.0 the material consists of a diffuse or transmissive base layer,
            with a specular reflection layer on top.
        """
        return _nvisii.material_set_metallic(self, metallic)

    def set_metallic_texture(self, texture, channel=0):
        r"""
        Blends between a non-metallic and metallic material model. Overrides any existing constant metallic

        :type texture: :py:class:`Texture`
        :param texture: A grayscale texture, where texel values of 1 give a fully specular reflection tinted with
            the base color, without diffuse reflection or transmission. When texel values equal 0.0 the material
            consists of a diffuse or transmissive base layer, with a specular reflection layer on top.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_metallic_texture(self, texture, channel)

    def clear_metallic_texture(self):
        r""" Disconnects the metallic texture, reverting back to any existing constant metallic"""
        return _nvisii.material_clear_metallic_texture(self)

    def get_metallic(self):
        r"""
        Blends between a non-metallic and metallic material model.

        :rtype: float
        :return: the current metallic value.
        """
        return _nvisii.material_get_metallic(self)

    def set_specular(self, specular):
        r"""
        The amount of dielectric specular reflection.

        :type specular: float
        :param specular: Specifies facing (along normal) reflectivity in the most common 0 - 8% range. Since materials with reflectivity above 8% do exist, the field allows values above 1.
        """
        return _nvisii.material_set_specular(self, specular)

    def set_specular_texture(self, texture, channel=0):
        r"""
        The amount of dielectric specular reflection. Overrides any existing constant specular

        :type texture: :py:class:`Texture`
        :param texture: A grayscale texture containing dielectric specular reflection values.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_specular_texture(self, texture, channel)

    def clear_specular_texture(self):
        r""" Disconnects the specular texture, reverting back to any existing constant specular"""
        return _nvisii.material_clear_specular_texture(self)

    def get_specular(self):
        r"""
        The amount of dielectric specular reflection.

        :rtype: float
        :return: the current dielectric specular reflection value.
        """
        return _nvisii.material_get_specular(self)

    def set_specular_tint(self, specularTint):
        r"""
        Tints the facing specular reflection using the base color, while glancing reflection remains white.
        Normal dielectrics have colorless reflection, so this parameter is not technically physically correct
        and is provided for faking the appearance of materials with complex surface structure.

        :param specular_tint: a value between 0 and 1, enabling/disabling specular tint
        """
        return _nvisii.material_set_specular_tint(self, specularTint)

    def set_specular_tint_texture(self, texture, channel=0):
        r"""
        Tints the facing specular reflection using the base color, while glancing reflection remains white. Overrides any existing constant specular tint

        :type texture: :py:class:`Texture`
        :param texture: A grayscale texture containing specular tint values, between 0 and 1.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_specular_tint_texture(self, texture, channel)

    def clear_specular_tint_texture(self):
        r""" Disconnects the specular tint texture, reverting back to any existing constant specular tint"""
        return _nvisii.material_clear_specular_tint_texture(self)

    def get_specular_tint(self):
        r"""
        Tints the facing specular reflection using the base color, while glancing reflection remains white.

        :rtype: float
        :return: the current specular tint value, between 0 and 1
        """
        return _nvisii.material_get_specular_tint(self)

    def set_roughness(self, roughness):
        r"""
        Microfacet roughness of the surface for diffuse and specular reflection.

        :type roughness: float
        :param roughness: Specifies the surface microfacet roughness value, between 0 and 1
        """
        return _nvisii.material_set_roughness(self, roughness)

    def set_roughness_texture(self, texture, channel=0):
        r"""
        Microfacet roughness of the surface for diffuse and specular reflection. Overrides any existing constant roughness

        :type texture: :py:class:`Texture`
        :param texture: A grayscale texture containing microfacet roughness values, between 0 and 1.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_roughness_texture(self, texture, channel)

    def clear_roughness_texture(self):
        r""" Disconnects the roughness texture, reverting back to any existing constant roughness"""
        return _nvisii.material_clear_roughness_texture(self)

    def get_roughness(self):
        r"""
        Microfacet roughness of the surface for diffuse and specular reflection.

        :rtype: float
        :return: the current surface microfacet roughness value, between 0 and 1
        """
        return _nvisii.material_get_roughness(self)

    def set_alpha(self, a):
        r"""
        The transparency of the surface, independent of transmission.

        :type a: float
        :param a: Controls the transparency of the surface, with 1.0 being fully opaque.
        """
        return _nvisii.material_set_alpha(self, a)

    def set_alpha_texture(self, texture, channel=0):
        r"""
        The transparency of the surface, independent of transmission. Overrides any existing constant alpha

        :type texture: :py:class:`Texture`
        :param texture: A grayscale texture containing surface transparency values, with 1.0 being fully opaque and 0.0
            being fully transparent.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_alpha_texture(self, texture, channel)

    def clear_alpha_texture(self):
        r""" Disconnects the alpha texture, reverting back to any existing constant alpha"""
        return _nvisii.material_clear_alpha_texture(self)

    def get_alpha(self):
        r"""
        The transparency of the surface, independent of transmission.

        :rtype: float
        :return: the current surface transparency, with 1.0 being fully opaque and 0.0 being fully transparent.
        """
        return _nvisii.material_get_alpha(self)

    def set_anisotropic(self, anisotropic):
        r"""
        The amount of anisotropy for specular reflection.

        :param anistropic: The amount of anisotropy for specular reflection. Higher values give elongated highlights along the tangent direction; negative values give highlights shaped perpendicular to the tangent direction.
        """
        return _nvisii.material_set_anisotropic(self, anisotropic)

    def set_anisotropic_texture(self, texture, channel=0):
        r"""
        The amount of anisotropy for specular reflection. Overrides any existing constant anisotropy

        :type texture: :py:class:`Texture`
        :param texture: A grayscale texture containing amounts of anisotropy for specular reflection. G, B, and A channels are ignored.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_anisotropic_texture(self, texture, channel)

    def clear_anisotropic_texture(self):
        r""" Disconnects the anisotropic texture, reverting back to any existing constant anisotropy"""
        return _nvisii.material_clear_anisotropic_texture(self)

    def get_anisotropic(self):
        r"""
        The amount of anisotropy for specular reflection.

        :rtype: float
        :return: The current amount of anisotropy for specular reflection.
        """
        return _nvisii.material_get_anisotropic(self)

    def set_anisotropic_rotation(self, anisotropicRotation):
        r"""
        The angle of anisotropy.
        :param anisotropic_rotation: Rotates the angle of anisotropy, with 1.0 going full circle.
        """
        return _nvisii.material_set_anisotropic_rotation(self, anisotropicRotation)

    def set_anisotropic_rotation_texture(self, texture, channel=0):
        r"""
        The angle of anisotropy. Overrides any existing constant anisotropic rotation

        :type texture: :py:class:`Texture`
        :param texture: A grayscale texture containing the angle of anisotropy, between 0 and 1.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_anisotropic_rotation_texture(self, texture, channel)

    def clear_anisotropic_rotation_texture(self):
        r""" Disconnects the anisotropic rotation texture, reverting back to any existing constant anisotropic rotation"""
        return _nvisii.material_clear_anisotropic_rotation_texture(self)

    def get_anisotropic_rotation(self):
        r"""
        The angle of anisotropy.

        :rtype: float
        :return: the current the angle of anisotropy, between 0 and 1.
        """
        return _nvisii.material_get_anisotropic_rotation(self)

    def set_sheen(self, sheen):
        r"""
        Amount of soft velvet like reflection near edges, for simulating materials such as cloth.

        :type sheen: float
        :param sheen: controls the amount of sheen, between 0 and 1
        """
        return _nvisii.material_set_sheen(self, sheen)

    def set_sheen_texture(self, texture, channel=0):
        r"""
        Amount of soft velvet like reflection near edges, for simulating materials such as cloth. Overrides any existing constant sheen

        :type texture: :py:class:`Texture`
        :param texture: A grayscale texture containing amounts of sheen, between 0 and 1.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_sheen_texture(self, texture, channel)

    def clear_sheen_texture(self):
        r""" Disconnects the sheen texture, reverting back to any existing constant sheen"""
        return _nvisii.material_clear_sheen_texture(self)

    def get_sheen(self):
        r"""
        Amount of soft velvet like reflection near edges, for simulating materials such as cloth.

        :rtype: float
        :return: the current sheen amount, between 0 and 1
        """
        return _nvisii.material_get_sheen(self)

    def set_sheen_tint(self, sheenTint):
        r"""
        Mix between white and using base color for sheen reflection.

        :param sheen_tint: controls the mix between white and base color for sheen reflection.
        """
        return _nvisii.material_set_sheen_tint(self, sheenTint)

    def set_sheen_tint_texture(self, texture, channel=0):
        r"""
        Mix between white and using base color for sheen reflection. Overrides any existing constant sheen tint

        :type texture: :py:class:`Texture`
        :param texture: A grayscale texture containing values used to mix between white and base color for sheen reflection.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_sheen_tint_texture(self, texture, channel)

    def clear_sheen_tint_texture(self):
        r""" Disconnects the sheen tint texture, reverting back to any existing constant sheen tint"""
        return _nvisii.material_clear_sheen_tint_texture(self)

    def get_sheen_tint(self):
        r"""
        Mix between white and using base color for sheen reflection.

        :rtype: float
        :return: the current value used to mix between white and base color for sheen reflection.
        """
        return _nvisii.material_get_sheen_tint(self)

    def set_clearcoat(self, clearcoat):
        r"""
        Extra white specular layer on top of others. This is useful for materials like car paint and the like.

        :type clearcoat: float
        :param clearcoat: controls the influence of clear coat, between 0 and 1
        """
        return _nvisii.material_set_clearcoat(self, clearcoat)

    def set_clearcoat_texture(self, texture, channel=0):
        r"""
        Extra white specular layer on top of others. Overrides any existing constant clearcoat

        :type texture: :py:class:`Texture`
        :param texture: A grayscale texture controlling the influence of clear coat, between 0 and 1.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_clearcoat_texture(self, texture, channel)

    def clear_clearcoat_texture(self):
        r""" Disconnects the clearcoat texture, reverting back to any existing constant clearcoat"""
        return _nvisii.material_clear_clearcoat_texture(self)

    def get_clearcoat(self):
        r"""
        Extra white specular layer on top of others. This is useful for materials like car paint and the like.

        :rtype: float
        :return: the current clear coat influence
        """
        return _nvisii.material_get_clearcoat(self)

    def set_clearcoat_roughness(self, clearcoatRoughness):
        r"""
        Microfacet surface roughness of clearcoat specular.

        :param clearcoat_roughness: the roughness of the microfacet distribution influencing the clearcoat, between 0 and 1
        """
        return _nvisii.material_set_clearcoat_roughness(self, clearcoatRoughness)

    def set_clearcoat_roughness_texture(self, texture, channel=0):
        r"""
        Microfacet surface roughness of clearcoat specular. Overrides any existing constant clearcoat roughness

        :type texture: :py:class:`Texture`
        :param texture: the roughness of the microfacet distribution influencing the clearcoat, between 0 and 1
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_clearcoat_roughness_texture(self, texture, channel)

    def clear_clearcoat_roughness_texture(self):
        r""" Disconnects the clearcoat roughness texture, reverting back to any existing constant clearcoat roughness"""
        return _nvisii.material_clear_clearcoat_roughness_texture(self)

    def get_clearcoat_roughness(self):
        r"""
        Microfacet surface roughness of clearcoat specular.

        :rtype: float
        :return: the current clearcoat microfacet roughness value, between 0 and 1
        """
        return _nvisii.material_get_clearcoat_roughness(self)

    def set_ior(self, ior):
        r"""
        Index of refraction used for transmission events.

        :type ior: float
        :param ior: the index of refraction. A value of 1 results in no refraction. For reference, the IOR of water is roughly 1.33, and for glass is roughly 1.57.
        """
        return _nvisii.material_set_ior(self, ior)

    def set_ior_texture(self, texture, channel=0):
        r"""
        Index of refraction used for transmission events. Overrides any existing constant ior.

        :type texture: :py:class:`Texture`
        :param texture: the index of refraction. A value of 1 results in no refraction. For reference, the IOR of water is roughly 1.33, and for glass is roughly 1.57.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_ior_texture(self, texture, channel)

    def clear_ior_texture(self):
        r""" Disconnects the ior texture, reverting back to any existing constant ior"""
        return _nvisii.material_clear_ior_texture(self)

    def get_ior(self):
        r"""
        Index of refraction used for transmission events.

        :rtype: float
        :return: the current index of refraction.
        """
        return _nvisii.material_get_ior(self)

    def set_transmission(self, transmission):
        r"""
        Controls how much the surface looks like glass. Note, metallic takes precedence.

        :type transmission: float
        :param transmission: Mixes between a fully opaque surface at zero to fully glass like transmissions at one.
        """
        return _nvisii.material_set_transmission(self, transmission)

    def set_transmission_texture(self, texture, channel=0):
        r"""
        Controls how much the surface looks like glass. Note, metallic takes precedence. Overrides any existing constant transmission.

        :type texture: :py:class:`Texture`
        :param texture: A grayscale texture containing the specular transmission of the surface.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_transmission_texture(self, texture, channel)

    def clear_transmission_texture(self):
        r""" Disconnects the transmission texture, reverting back to any existing constant transmission"""
        return _nvisii.material_clear_transmission_texture(self)

    def get_transmission(self):
        r"""
        Controls how much the surface looks like glass. Note, metallic takes precedence.

        :rtype: float
        :return: the current specular transmission of the surface.
        """
        return _nvisii.material_get_transmission(self)

    def set_transmission_roughness(self, transmissionRoughness):
        r"""
        The roughness of the interior surface used for transmitted light.

        :param transmission_roughness: Controls the roughness value used for transmitted light.
        """
        return _nvisii.material_set_transmission_roughness(self, transmissionRoughness)

    def set_transmission_roughness_texture(self, texture, channel=0):
        r"""
        The roughness of the interior surface used for transmitted light. Overrides any existing constant transmission roughness

        :type texture: :py:class:`Texture`
        :param texture: Controls the roughness value used for transmitted light.
        :type channel: int, optional
        :param channel: A value between 0 and 3 indicating the channel to use for this parameter.
        """
        return _nvisii.material_set_transmission_roughness_texture(self, texture, channel)

    def clear_transmission_roughness_texture(self):
        r""" Disconnects the TransmissionRoughness texture, reverting back to any existing constant TransmissionRoughness"""
        return _nvisii.material_clear_transmission_roughness_texture(self)

    def get_transmission_roughness(self):
        r"""
        The roughness of the interior surface used for transmitted light.

        :rtype: float
        :return: the current roughness value used for transmitted light.
        """
        return _nvisii.material_get_transmission_roughness(self)

    def set_normal_map_texture(self, texture):
        r"""
        A normal map texture used to displace surface normals.
        Note that we expect R=X+, G=Y+, and B=Z+ (Matches Blender / OpenGL).
        Textures imported as ".dds" are an exception, and use R=X+, G=Y-, and B=Z+ (Matches DirectX style)

        :type texture: :py:class:`Texture`
        :param texture: A texture containing a surface normal displacement between 0 and 1. A channel is ignored.
        """
        return _nvisii.material_set_normal_map_texture(self, texture)

    def clear_normal_map_texture(self):
        r""" Disconnects the normal map texture"""
        return _nvisii.material_clear_normal_map_texture(self)
    __swig_destroy__ = _nvisii.delete_material

# Register material in _nvisii:
_nvisii.material_swigregister(material)

def material_create(*args, **kwargs):
    r"""
    Constructs a material with the given name.

    :rtype: :py:class:`Material`
    :return: a reference to a material component
    :type name: string
    :param name: A unique name for this material.
    :type base_color: :py:class:`vec3`, optional
    :param base_color: The diffuse or metal surface color.
    :type roughness: float, optional
    :param roughness: Microfacet roughness of the surface for diffuse and specular reflection.
    :type metallic: float, optional
    :param metallic: Blends between a non-metallic and metallic material model.
    :type specular: float, optional
    :param specular: The amount of dielectric specular reflection.
    :type specular_tint: float, optional
    :param specular_tint: Tints the facing specular reflection using the base color, while glancing reflection remains white.
    :type transmission: float, optional
    :param transmission: Controls how much the surface looks like glass. Note, metallic takes precedence.
    :type transmission_roughness: float, optional
    :param transmission_roughness: The roughness of the interior surface used for transmitted light.
    :type ior: float, optional
    :param ior: Index of refraction used for transmission events.
    :type alpha: float, optional
    :param alpha: The transparency of the surface, independent of transmission.
    :type subsurface_radius: :py:class:`vec3`, optional
    :param subsurface_radius: Average distance that light scatters below the surface
    :type subsurface_color: :py:class:`vec3`, optional
    :param subsurface_color: The subsurface scattering base color.
    :type subsurface: float, optional
    :param subsurface: Mix between diffuse and subsurface scattering.
    :type anisotropic: float, optional
    :param anisotropic: The amount of anisotropy for specular reflection.
    :type anisotropic_rotation: float, optional
    :param anisotropic_rotation: The angle of anisotropy.
    :type sheen: float, optional
    :param sheen: Amount of soft velvet like reflection near edges, for simulating materials such as cloth.
    :type sheen_tint: float, optional
    :param sheen_tint: Mix between white and using base color for sheen reflection.
    :type clearcoat: float, optional
    :param clearcoat: Extra white specular layer on top of others.
    :type clearcoat_roughness: float, optional
    :param clearcoat_roughness: Microfacet surface roughness of clearcoat specular.
    """
    return _nvisii.material_create(*args, **kwargs)

def material_get(name):
    r"""
    Gets a material by name

    :rtype: :py:class:`Material`
    :return: a material who's primary name key matches ``name``
    :type name: string
    :param name: A unique name used to lookup this material.
    """
    return _nvisii.material_get(name)

def material_get_count():
    r"""
    :rtype: int
    :return: the number of allocated materials
    """
    return _nvisii.material_get_count()

def material_get_name_to_id_map():
    r"""
    :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
    :return: A map whose key is a material name and whose value is the ID for that material
    """
    return _nvisii.material_get_name_to_id_map()

def material_remove(name):
    r"""
    :type name: string
    :param name: The name of the material to remove
    """
    return _nvisii.material_remove(name)

def material_initialize_factory(max_components):
    r""" Allocates the tables used to store all material components"""
    return _nvisii.material_initialize_factory(max_components)

def material_clear_all():
    r""" Clears any existing material components."""
    return _nvisii.material_clear_all()

def material_are_any_dirty():
    r"""
    :rtype: boolean
    :return: True if any the material has been modified since the previous frame, and False otherwise
    """
    return _nvisii.material_are_any_dirty()

class vertex(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    point = property(_nvisii.vertex_point_get, _nvisii.vertex_point_set)
    color = property(_nvisii.vertex_color_get, _nvisii.vertex_color_set)
    normal = property(_nvisii.vertex_normal_get, _nvisii.vertex_normal_set)
    tangent = property(_nvisii.vertex_tangent_get, _nvisii.vertex_tangent_set)
    texcoord = property(_nvisii.vertex_texcoord_get, _nvisii.vertex_texcoord_set)
    wnormals = property(_nvisii.vertex_wnormals_get, _nvisii.vertex_wnormals_set)

    def __eq__(self, other):
        return _nvisii.vertex___eq__(self, other)

    def __init__(self):
        _nvisii.vertex_swiginit(self, _nvisii.new_vertex())
    __swig_destroy__ = _nvisii.delete_vertex

# Register vertex in _nvisii:
_nvisii.vertex_swigregister(vertex)

class mesh(static_factory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def create_box(*args, **kwargs):
        r"""
        Creates a rectangular box centered at the origin aligned along the x, y, and z axis.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type size: :py:class:`vec3`, optional
        :param size: Half of the side length in x (0), y (1) and z (2) direction.
        :type segments: :py:class:`ivec3`, optional
        :param segments: The number of segments in x (0), y (1) and z (2)
            directions. All should be >= 1. If any one is zero, faces in that
            direction are not genereted. If more than one is zero the mesh is empty.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_box(*args, **kwargs)

    @staticmethod
    def create_capped_cone(*args, **kwargs):
        r"""
        Creates a cone with a cap centered at the origin and pointing towards the positive z-axis.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type radius: float, optional
        :param radius: Radius of the flat (negative z) end along the xy-plane.
        :type size: float, optional
        :param size: Half of the length of the cylinder along the z-axis.
        :type slices: int, optional
        :param slices: Number of subdivisions around the z-axis.
        :type segments: int, optional
        :param segments: Number of subdivisions along the z-axis.
        :type rings: int, optional
        :param rings: Number of subdivisions of the cap.
        :type start: float, optional
        :param start: Counterclockwise angle around the z-axis relative to the positive x-axis.
        :type sweep: float, optional
        :param sweep: Counterclockwise angle around the z-axis.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_capped_cone(*args, **kwargs)

    @staticmethod
    def create_capped_cylinder(*args, **kwargs):
        r"""
        Creates a cylinder with a cap centered at the origin and aligned along the z-axis

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type radius: float, optional
        :param radius: Radius of the cylinder along the xy-plane.
        :type size: float, optional
        :param size: Half of the length cylinder along the z-axis.
        :type slices: int, optional
        :param slices: Number of subdivisions around the z-axis.
        :type segments: int, optional
        :param segments: Number of subdivisions along the z-axis.
        :type rings: int, optional
        :param rings: Number of subdivisions on the caps.
        :type start: float, optional
        :param start: Counterclockwise angle around the z-axis relative to x-axis.
        :type sweep: float, optional
        :param sweep: Counterclockwise angle around the z-axis.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_capped_cylinder(*args, **kwargs)

    @staticmethod
    def create_capped_tube(*args, **kwargs):
        r"""
        Creates a tube (a cylinder with thickness) with caps on both ends, centered at the origin and aligned along the z-axis.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type radius: float, optional
        :param radius: The outer radius of the cylinder on the xy-plane.
        :type innerRadius: float, optional
        :param innerRadius: The inner radius of the cylinder on the xy-plane.
        :type size: float, optional
        :param size: Half of the length of the cylinder along the z-axis.
        :type slices: int, optional
        :param slices: Number nubdivisions around the z-axis.
        :type segments: int, optional
        :param segments: Number of subdivisions along the z-axis.
        :type rings: int, optional
        :param rings: Number radial subdivisions in the cap.
        :type start: float, optional
        :param start: Counterclockwise angle around the z-axis relative to the x-axis.
        :type sweep: float, optional
        :param sweep: Counterclockwise angle around the z-axis.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_capped_tube(*args, **kwargs)

    @staticmethod
    def create_capsule(*args, **kwargs):
        r"""
        Creates a capsule (a cylinder with spherical caps) centered at the origin and aligned along the z-axis.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type radius: float, optional
        :param radius: Radius of the capsule on the xy-plane.
        :type size: float, optional
        :param size: Half of the length between centers of the caps along the z-axis.
        :type slices: int, optional
        :param slices: Number of subdivisions around the z-axis in the caps.
        :type segments: int, optional
        :param segments: Number radial subdivisions in the cylinder.
        :type rings: int, optional
        :param rings: Number of radial subdivisions in the caps.
        :type start: float, optional
        :param start: Counterclockwise angle relative to the x-axis.
        :type sweep: float, optional
        :param sweep: Counterclockwise angle.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_capsule(*args, **kwargs)

    @staticmethod
    def create_cone(*args, **kwargs):
        r"""
        Creates a cone centered at the origin, and whose tip points towards the z-axis.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type radius: float, optional
        :param radius: Radius of the negative z end on the xy-plane.
        :type size: float, optional
        :param size: Half of the length of the cylinder along the z-axis.
        :type slices: int, optional
        :param slices: Number of subdivisions around the z-axis.
        :type segments: int, optional
        :param segments: Number subdivisions along the z-axis.
        :type start: float, optional
        :param start: Counterclockwise angle around the z-axis relative to the x-axis.
        :type sweep: float, optional
        :param sweep: Counterclockwise angle around the z-axis.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_cone(*args, **kwargs)

    @staticmethod
    def create_convex_polygon_from_circle(name, radius=1.0, sides=5, segments=4, rings=4):
        r"""
        Creates a convex polygonal disk with an arbitrary number of corners.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type radius: float, optional
        :param radius: The radius the enclosing circle.
        :type sides: int, optional
        :param sides: The number of sides. Should be >= 3. If <3 an empty mesh is generated.
        :type segments: int, optional
        :param segments: The number of segments per side. Should be >= 1. If zero an empty mesh is generated.
        :type rings: int, optional
        :param rings: The number of radial segments. Should be >= 1. = yields an empty mesh.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_convex_polygon_from_circle(name, radius, sides, segments, rings)

    @staticmethod
    def create_convex_polygon(name, vertices, segments=1, rings=1):
        r"""
        Creates a convex polygon from a set of corner vertices.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type vertices: std::vector< glm::vec2,std::allocator< glm::vec2 > >
        :param vertices: The corner coplanar vertex coordinates. Should form a convex polygon.
        :type segments: int, optional
        :param segments: The number of segments per side. Should be >= 1. If zero an empty mesh is generated.
        :type rings: int, optional
        :param rings: The number of radial segments. Should be >= 1. = yields an empty mesh.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_convex_polygon(name, vertices, segments, rings)

    @staticmethod
    def create_cylinder(*args, **kwargs):
        r"""
        Creates an uncapped cylinder centered at the origin and aligned along the z-axis

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type radius: float, optional
        :param radius: Radius of the cylinder along the xy-plane.
        :type size: float, optional
        :param size: Half of the length of the cylinder along the z-axis.
        :type slices: int, optional
        :param slices: Subdivisions around the z-axis.
        :type segments: int, optional
        :param segments: Subdivisions along the z-axis.
        :type start: float, optional
        :param start: Counterclockwise angle around the z-axis relative to the x-axis.
        :type sweep: float, optional
        :param sweep: Counterclockwise angle around the z-axis.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_cylinder(*args, **kwargs)

    @staticmethod
    def create_disk(*args, **kwargs):
        r"""
        Creates a circular disk centered at the origin and along the xy-plane

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type radius: float, optional
        :param radius: Outer radius of the disk on the xy-plane.
        :type innerRadius: float, optional
        :param innerRadius: radius of the inner circle on the xy-plane.
        :type slices: int, optional
        :param slices: Number of subdivisions around the z-axis.
        :type rings: int, optional
        :param rings: Number of subdivisions along the radius.
        :type start: float, optional
        :param start: Counterclockwise angle relative to the x-axis
        :type sweep: float, optional
        :param sweep: Counterclockwise angle.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_disk(*args, **kwargs)

    @staticmethod
    def create_dodecahedron(name, radius=1.0, segments=1, rings=1):
        r"""
        Creates a regular dodecahedron centered at the origin and with a given radius.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
            Each face is optionally subdivided along the edges and/or radius.
        :type radius: float, optional
        :param radius: The radius of the enclosing sphere.
        :type segments: int, optional
        :param segments: The number segments along each edge. Should be >= 1. If <1 empty mesh is generated.
        :type rings: int, optional
        :param rings: The number of radial segments on each face. Should be >= 1. If <1 an empty mesh is generated.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_dodecahedron(name, radius, segments, rings)

    @staticmethod
    def create_plane(*args, **kwargs):
        r"""
        Creates a plane (a regular grid) on the xy-plane whose normal points towards the z-axis.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type size: :py:class:`vec2`, optional
        :param size: Half of the side length in x (0) and y (1) direction.
        :type segments: :py:class:`ivec2`, optional
        :param segments: Number of subdivisions in the x (0) and y (1) direction.
        :type flip_z: boolean, optional
        :param flip_z: Flips the plane such that the face is pointed down negative Z instead of positive Z.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_plane(*args, **kwargs)

    @staticmethod
    def create_icosahedron(name, radius=1.0, segments=1):
        r"""
        Creates a regular icosahedron centered at the origin and with a given radius.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type radius: float, optional
        :param radius: The radius of the enclosing sphere.
        :type segments: int, optional
        :param segments: The number segments along each edge. Must be >= 1.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_icosahedron(name, radius, segments)

    @staticmethod
    def create_icosphere(name, radius=1.0, segments=4):
        r"""
        Creates an icosphere, otherwise known as a spherical subdivided icosahedron.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type radius: float, optional
        :param radius: The radius of the containing sphere.
        :type segments: int, optional
        :param segments: The number of segments per icosahedron edge. Must be >= 1.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_icosphere(name, radius, segments)

    @staticmethod
    def create_rounded_box(*args, **kwargs):
        r"""
        Creates a rectangular box with rounded edges, centered at the origin and aligned along the x, y, and z axis.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type radius: float, optional
        :param radius: Radius of the rounded edges.
        :type size: :py:class:`vec3`, optional
        :param size: Half of the side length in x (0), y (1) and z (2) direction.
        :type slices: int, optional
        :param slices: Number subdivions around in the rounded edges.
        :type segments: :py:class:`ivec3`, optional
        :param segments: Number of subdivisions in x (0), y (1) and z (2) direction for the flat faces.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_rounded_box(*args, **kwargs)

    @staticmethod
    def create_sphere(*args, **kwargs):
        r"""
        Creates a sphere of the given radius, centered around the origin, subdivided around the z-axis in slices and along the z-axis in segments.

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type radius: float, optional
         :param radius: The radius of the sphere
         :type slices: int, optional
         :param slices: Subdivisions around the z-axis (longitudes).
         :type segments: int, optional
         :param segments: Subdivisions along the z-axis (latitudes).
         :type sliceStart: float, optional
         :param sliceStart: Counterclockwise angle around the z-axis relative to x-axis.
         :type sliceSweep: float, optional
         :param sliceSweep: Counterclockwise angle.
         :type segmentStart: float, optional
         :param segmentStart: Counterclockwise angle relative to the z-axis.
         :type segmentSweep: float, optional
         :param segmentSweep: Counterclockwise angle.
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_sphere(*args, **kwargs)

    @staticmethod
    def create_spherical_cone(*args, **kwargs):
        r"""
        Creates a cone with a spherical cap, centered at the origin and whose tip points towards the z-axis.
         Each point on the cap has equal distance from the tip.

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type radius: float, optional
         :param radius: Radius of the negative z end on the xy-plane.
         :type size: float, optional
         :param size: Half of the distance between cap and tip along the z-axis.
         :type slices: int, optional
         :param slices: Number of subdivisions around the z-axis.
         :type segments: int, optional
         :param segments: Number subdivisions along the z-axis.
         :type rings: int, optional
         :param rings: Number subdivisions in the cap.
         :type start: float, optional
         :param start: Counterclockwise angle around the z-axis relative to the positive x-axis.
         :type sweep: float, optional
         :param sweep: Counterclockwise angle around the z-axis.
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_spherical_cone(*args, **kwargs)

    @staticmethod
    def create_spherical_triangle_from_sphere(name, radius=1.0, segments=4):
        r"""
        Creates a triangular region on the surface of a sphere.

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type radius: float, optional
         :param radius: Radius of the containing sphere.
         :type segments: int, optional
         :param segments: Number of subdivisions along each edge.
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_spherical_triangle_from_sphere(name, radius, segments)

    @staticmethod
    def create_spherical_triangle_from_triangle(name, v0, v1, v2, segments=4):
        r"""
        Creates a triangular region on the surface of a sphere.

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type v0: :py:class:`vec3`
         :param v0: First of the three counter-clockwise triangle vertices
         :type v1: :py:class:`vec3`
         :param v1: Second of the three counter-clockwise triangle vertices
         :type v2: :py:class:`vec3`
         :param v2: Third of the three counter-clockwise triangle vertices
         :type segments: int, optional
         :param segments: Number of subdivisions along each edge.
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_spherical_triangle_from_triangle(name, v0, v1, v2, segments)

    @staticmethod
    def create_spring(*args, **kwargs):
        r"""
        Creates a spring aligned along the z-axis and with a counter-clockwise winding.

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type minor: float, optional
         :param minor: Radius of the spring it self.
         :type major: float, optional
         :param major: Radius from the z-axis
         :type size: float, optional
         :param size: Half of the length along the z-axis.
         :type slices: int, optional
         :param slices: Subdivisions around the spring.
         :type segments: int, optional
         :param segments: Subdivisions along the path.
         :type majorStart: float, optional
         :param majorStart: Counterclockwise angle around the z-axis relative to the x-axis.
         :type majorSweep: float, optional
         :param majorSweep: Counterclockwise angle around the z-axis.
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_spring(*args, **kwargs)

    @staticmethod
    def create_teapotahedron(name, segments=8):
        r"""
        Creates the Utah Teapot using the original b-spline surface data. (https://en.wikipedia.org/wiki/Utah_teapot)
         The lid is points towards the z axis and the spout points towards the x axis.

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type segments: int, optional
         :param segments: The number segments along each patch. Should be >= 1. If zero empty mesh is generated.
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_teapotahedron(name, segments)

    @staticmethod
    def create_torus(*args, **kwargs):
        r"""
        Creates a torus centered at the origin and along the xy-plane.

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type minor: float, optional
         :param minor: Radius of the minor (inner) ring
         :type major: float, optional
         :param major: Radius of the major (outer) ring
         :type slices: int, optional
         :param slices: Subdivisions around the minor ring
         :type segments: int, optional
         :param segments: Subdivisions around the major ring
         :type minorStart: float, optional
         :param minorStart: Counterclockwise angle relative to the xy-plane.
         :type minorSweep: float, optional
         :param minorSweep: Counterclockwise angle around the circle.
         :type majorStart: float, optional
         :param majorStart: Counterclockwise angle around the z-axis relative to the x-axis.
         :type majorSweep: float, optional
         :param majorSweep: Counterclockwise angle around the z-axis.
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_torus(*args, **kwargs)

    @staticmethod
    def create_torus_knot(name, p=2, q=3, slices=8, segments=96):
        r"""
        Creates a circle extruded along the path of a knot. (https://en.wikipedia.org/wiki/Torus_knot)

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type p: int, optional
         :param p: First coprime integer.
         :type q: int, optional
         :param q: Second coprime integer.
         :type slices: int, optional
         :param slices: Number subdivisions around the circle.
         :type segments: int, optional
         :param segments: Number of subdivisions around the path.
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_torus_knot(name, p, q, slices, segments)

    @staticmethod
    def create_triangle_from_circumscribed_circle(name, radius=1.0, segments=4):
        r"""
        Creates a triangle centered at the origin and contained within the circumscribed circle.

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type radius: float, optional
         :param radius: The radius of the containing circle.
         :type segments: int, optional
         :param segments: The number of segments along each edge. Must be >= 1.
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_triangle_from_circumscribed_circle(name, radius, segments)

    @staticmethod
    def create_triangle(name, v0, v1, v2, segments=4):
        r"""
        Creates a triangle from the specified vertices

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type v0: :py:class:`vec3`
         :param v0: First of the vertex positions of the triangle.
         :type v1: :py:class:`vec3`
         :param v1: Second of the vertex positions of the triangle.
         :type v2: :py:class:`vec3`
         :param v2: Third of the vertex positions of the triangle.
         :type segments: int, optional
         :param segments: The number of segments along each edge. Must be >= 1.
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_triangle(name, v0, v1, v2, segments)

    @staticmethod
    def create_line(name, start, stop, radius=1.0, segments=16):
        r"""
        Creates a line from a circle extruded linearly between the specified start and stop positions.

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type start: :py:class:`vec3`
         :param start: The start position of the linear path.
         :type start: :py:class:`vec3`
         :param start: The stop position of the linear path.
         :type radius: float, optional
         :param radius: The radius of the extruded circle
         :type segments: int, optional
         :param segments: Number of subdivisions around the circle.
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_line(name, start, stop, radius, segments)

    @staticmethod
    def create_tube(*args, **kwargs):
        r"""
        Creates an uncapped tube (a cylinder with thickness) centered at the origin and aligned along the z-axis.

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type radius: float, optional
         :param radius: The outer radius of the cylinder on the xy-plane.
         :type innerRadius: float, optional
         :param innerRadius: The inner radius of the cylinder on the xy-plane.
         :type size: float, optional
         :param size: Half of the length of the cylinder along the z-axis.
         :type slices: int, optional
         :param slices: Subdivisions around the z-axis.
         :type segments: int, optional
         :param segments: Subdivisions along the z-axis.
         :type start: float, optional
         :param start: Counterclockwise angle around the z-axis relative to the x-axis.
         :type sweep: float, optional
         :param sweep: Counterclockwise angle around the z-axis.
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_tube(*args, **kwargs)

    @staticmethod
    def create_tube_from_polyline(name, path, radius=1.0, segments=16):
        r"""
        Creates a tube from a circle extruded linearly along the specified path.

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type path: std::vector< glm::vec3,std::allocator< glm::vec3 > >
         :param path: A set of vertices describing a linear path.
         :type radius: float, optional
         :param radius: The radius of the extruded circle
         :type segments: int, optional
         :param segments: Number of subdivisions around the circle.
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_tube_from_polyline(name, path, radius, segments)

    @staticmethod
    def create_rounded_rectangle_tube_from_polyline(*args, **kwargs):
        r"""
        Creates a tube from a rounded rectangle extruded linearly along the specified path.

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type path: std::vector< glm::vec3,std::allocator< glm::vec3 > >
         :param path: A set of vertices describing a linear path.
         :type radius: float, optional
         :param radius: The radius of the rounded corners
         :type size: :py:class:`vec2`, optional
         :param size: Half of the length of an edge
         :type slices: int, optional
         :param slices: Number of subdivisions in each rounded corner
         :type segments: :py:class:`ivec2`, optional
         :param segments: Number of subdivisions along each edge
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_rounded_rectangle_tube_from_polyline(*args, **kwargs)

    @staticmethod
    def create_rectangle_tube_from_polyline(*args, **kwargs):
        r"""
        Creates a tube from a rounded rectangle extruded linearly along the specified path.

         :type name: string
         :param name: The name (used as a primary key) for this mesh component
         :type path: std::vector< glm::vec3,std::allocator< glm::vec3 > >
         :param path: A set of vertices describing a linear path.
         :type size: :py:class:`vec2`, optional
         :param size: Half of the length of an edge
         :type segments: :py:class:`ivec2`, optional
         :param segments: Number of subdivisions along each edge
         :rtype: :py:class:`Mesh`
         :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_rectangle_tube_from_polyline(*args, **kwargs)

    @staticmethod
    def create_wireframe_bounding_box(*args, **kwargs):
        r"""
        Creates a wireframe bounding box spanning the region between the minimum corner to
        the maximum corner, and aligned along the x, y, and z axis.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type min_corner: :py:class:`vec3`, optional
        :param min_corner: The position of the bottom left near corner of the axis aligned bounding box.
        :type max_corner: :py:class:`vec3`, optional
        :param max_corner: The position of the top right far corner of the axis aligned bounding box.
        :param size: The side length in x (0), y (1) and z (2) direction.
        :type thickness: float, optional
        :param thickness: The thickness of the wires in the wireframe.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_wireframe_bounding_box(*args, **kwargs)

    @staticmethod
    def create_from_obj(name, path):
        r"""Deprecated. Please use create_from_file instead."""
        return _nvisii.mesh_create_from_obj(name, path)

    @staticmethod
    def create_from_file(name, path):
        r"""
        Creates a mesh component from a file (ignoring any associated materials)

        Supported file formats include: AMF 3DS AC ASE ASSBIN B3D BVH COLLADA DXF
        CSM HMP IRRMESH IRR LWO LWS M3D MD2 MD3 MD5 MDC MDL NFF NDO OFF OBJ OGRE
        OPENGEX PLY MS3D COB BLEND IFC XGL FBX Q3D Q3BSP RAW SIB SMD STL
        TERRAGEN 3D X X3D GLTF 3MF MMD

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type path: string
        :param path: A path to the file.
        """
        return _nvisii.mesh_create_from_file(name, path)

    @staticmethod
    def create_from_data(*args, **kwargs):
        r"""
        Creates a mesh component from a set of positions, optional normals, optional colors, optional texture coordinates,
        and optional indices. If anything other than positions is supplied (eg normals), that list must be the same length
        as the point list. If indicies are supplied, indices must be a multiple of 3 (triangles). Otherwise, all other
        supplied per vertex data must be a multiple of 3 in length.

        :type name: string
        :param name: The name (used as a primary key) for this mesh component
        :type positions: std::vector< float,std::allocator< float > >
        :param positions: A list of vertex positions. If indices aren't supplied, this must be a multiple of 3.
        :type position_dimensions: int, optional
        :param position_dimensions: The number of floats per position. Valid numbers are 3 or 4.
        :type normals: std::vector< float,std::allocator< float > >, optional
        :param normals: A list of vertex normals. If indices aren't supplied, this must be a multiple of 3.
        :type normal_dimensions: int, optional
        :param normal_dimensions: The number of floats per normal. Valid numbers are 3 or 4.
        :type colors: std::vector< float,std::allocator< float > >, optional
        :param colors: A list of per-vertex colors. If indices aren't supplied, this must be a multiple of 3.
        :type color_dimensions: int, optional
        :param color_dimensions: The number of floats per color. Valid numbers are 3 or 4.
        :type texcoords: std::vector< float,std::allocator< float > >, optional
        :param texcoords: A list of 2D per-vertex texture coordinates. If indices aren't supplied, this must be a multiple of 3.
        :type texcoord_dimensions: int, optional
        :param texcoord_dimensions: The number of floats per texcoord. Valid numbers are 2. (3 might be supported later for 3D textures...)
        :type indices: std::vector< uint32_t,std::allocator< uint32_t > >, optional
        :param indices: A list of integer indices connecting vertex positions in a counterclockwise ordering to form triangles. If supplied, indices must be a multiple of 3.
        :rtype: :py:class:`Mesh`
        :return: a reference to the mesh component
        """
        return _nvisii.mesh_create_from_data(*args, **kwargs)

    @staticmethod
    def get(name):
        r"""
        :type name: string
        :param name: The name of the Mesh to get
        :rtype: :py:class:`Mesh`
        :return: a Mesh who's name matches the given name
        """
        return _nvisii.mesh_get(name)

    @staticmethod
    def get_front_struct():
        r"""
        :rtype: MeshStruct
        :return: a pointer to the table of MeshStructs required for rendering
        """
        return _nvisii.mesh_get_front_struct()

    @staticmethod
    def get_front():
        r"""
        :rtype: :py:class:`Mesh`
        :return: a pointer to the table of mesh components
        """
        return _nvisii.mesh_get_front()

    @staticmethod
    def get_count():
        r"""
        :rtype: int
        :return: the number of allocated meshes
        """
        return _nvisii.mesh_get_count()

    def get_name(self):
        r"""
        :rtype: string
        :return: the name of this component
        """
        return _nvisii.mesh_get_name(self)

    def get_id(self):
        r"""
        :rtype: int
        :return: the unique integer ID for this component
        """
        return _nvisii.mesh_get_id(self)

    def get_address(self):
        return _nvisii.mesh_get_address(self)

    @staticmethod
    def get_name_to_id_map():
        r"""
        :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
        :return: A map whose key is a mesh name and whose value is the ID for that mesh
        """
        return _nvisii.mesh_get_name_to_id_map()

    @staticmethod
    def remove(name):
        r"""
        :type name: string
        :param name: The name of the Mesh to remove
        """
        return _nvisii.mesh_remove(name)

    @staticmethod
    def initialize_factory(max_components):
        r""" Allocates the tables used to store all mesh components"""
        return _nvisii.mesh_initialize_factory(max_components)

    @staticmethod
    def is_factory_initialized():
        r"""
        :rtype: boolean
        :return: True if the tables used to store all mesh components have been allocated, and False otherwise
        """
        return _nvisii.mesh_is_factory_initialized()

    def is_initialized(self):
        r"""
        :rtype: boolean
        :return: True the current mesh is a valid, initialized mesh, and False if the mesh was cleared or removed.
        """
        return _nvisii.mesh_is_initialized(self)

    @staticmethod
    def update_components():
        r""" Iterates through all mesh components, computing mesh metadata for rendering purposes."""
        return _nvisii.mesh_update_components()

    @staticmethod
    def clear_all():
        r""" Clears any existing Mesh components."""
        return _nvisii.mesh_clear_all()

    @staticmethod
    def are_any_dirty():
        r""" Indicates whether or not any meshes are "out of date" and need to be updated through the "update components" function"""
        return _nvisii.mesh_are_any_dirty()

    @staticmethod
    def get_dirty_meshes():
        r"""
        :rtype: std::set< nvisii::Mesh * >
        :return: a list of meshes that have been modified since the previous frame
        """
        return _nvisii.mesh_get_dirty_meshes()

    def mark_dirty(self):
        r""" Tags the current component as being modified since the previous frame."""
        return _nvisii.mesh_mark_dirty(self)

    def to_string(self):
        r"""
        :rtype: string
        :return: a json string representation of the current component
        """
        return _nvisii.mesh_to_string(self)

    def get_vertices(self):
        r"""
        :param vertex_dimensions: The number of floats per vertex to return. Valid numbers are 3 or 4.
        :rtype: std::vector< std::array< float,3 >,std::allocator< std::array< float,3 > > >
        :return: a list of per vertex positions
        """
        return _nvisii.mesh_get_vertices(self)

    def get_colors(self):
        r"""
        :rtype: std::vector< glm::vec4,std::allocator< glm::vec4 > >
        :return: a list of per vertex colors
        """
        return _nvisii.mesh_get_colors(self)

    def get_normals(self):
        r"""
        :rtype: std::vector< glm::vec4,std::allocator< glm::vec4 > >
        :return: a list of per vertex normals
        """
        return _nvisii.mesh_get_normals(self)

    def get_tangents(self):
        r"""
        :rtype: std::vector< glm::vec4,std::allocator< glm::vec4 > >
        :return: a list of per vertex tangents
        """
        return _nvisii.mesh_get_tangents(self)

    def get_tex_coords(self):
        r"""
        :rtype: std::vector< glm::vec2,std::allocator< glm::vec2 > >
        :return: a list of per vertex texture coordinates
        """
        return _nvisii.mesh_get_tex_coords(self)

    def get_triangle_indices(self):
        r"""
        :rtype: std::vector< uint32_t,std::allocator< uint32_t > >
        :return: a list of triangle indices
        """
        return _nvisii.mesh_get_triangle_indices(self)

    def compute_metadata(self):
        r"""
        Computes the average of all vertex positions. (centroid)
        as well as min/max bounds and bounding sphere data.
        """
        return _nvisii.mesh_compute_metadata(self)

    def get_centroid(self):
        r"""
        :rtype: :py:class:`vec3`
        :return: the last computed mesh centroid.
        """
        return _nvisii.mesh_get_centroid(self)

    def get_min_aabb_corner(self):
        r"""
        :rtype: :py:class:`vec3`
        :return: the minimum axis aligned bounding box position
        """
        return _nvisii.mesh_get_min_aabb_corner(self)

    def get_max_aabb_corner(self):
        r"""
        :rtype: :py:class:`vec3`
        :return: the maximum axis aligned bounding box position
        """
        return _nvisii.mesh_get_max_aabb_corner(self)

    def get_aabb_center(self):
        r"""
        :rtype: :py:class:`vec3`
        :return: the center of the aligned bounding box
        """
        return _nvisii.mesh_get_aabb_center(self)

    def get_bounding_sphere_radius(self):
        r"""
        :rtype: float
        :return: the radius of a sphere centered at the centroid which completely contains the mesh
        """
        return _nvisii.mesh_get_bounding_sphere_radius(self)

    def generate_smooth_normals(self):
        r"""
        Replaces any existing normals with per-vertex smooth normals computed by
        averaging neighboring geometric face normals together.
        Note that this does not take into account the surface area of each triangular face.
        """
        return _nvisii.mesh_generate_smooth_normals(self)

    def generate_smooth_tangents(self):
        return _nvisii.mesh_generate_smooth_tangents(self)

    @staticmethod
    def get_edit_mutex():
        r""" For internal use. Returns the mutex used to lock entities for processing by the renderer."""
        return _nvisii.mesh_get_edit_mutex()
    __swig_destroy__ = _nvisii.delete_mesh

# Register mesh in _nvisii:
_nvisii.mesh_swigregister(mesh)

def mesh_create_box(*args, **kwargs):
    r"""
    Creates a rectangular box centered at the origin aligned along the x, y, and z axis.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type size: :py:class:`vec3`, optional
    :param size: Half of the side length in x (0), y (1) and z (2) direction.
    :type segments: :py:class:`ivec3`, optional
    :param segments: The number of segments in x (0), y (1) and z (2)
        directions. All should be >= 1. If any one is zero, faces in that
        direction are not genereted. If more than one is zero the mesh is empty.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_box(*args, **kwargs)

def mesh_create_capped_cone(*args, **kwargs):
    r"""
    Creates a cone with a cap centered at the origin and pointing towards the positive z-axis.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type radius: float, optional
    :param radius: Radius of the flat (negative z) end along the xy-plane.
    :type size: float, optional
    :param size: Half of the length of the cylinder along the z-axis.
    :type slices: int, optional
    :param slices: Number of subdivisions around the z-axis.
    :type segments: int, optional
    :param segments: Number of subdivisions along the z-axis.
    :type rings: int, optional
    :param rings: Number of subdivisions of the cap.
    :type start: float, optional
    :param start: Counterclockwise angle around the z-axis relative to the positive x-axis.
    :type sweep: float, optional
    :param sweep: Counterclockwise angle around the z-axis.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_capped_cone(*args, **kwargs)

def mesh_create_capped_cylinder(*args, **kwargs):
    r"""
    Creates a cylinder with a cap centered at the origin and aligned along the z-axis

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type radius: float, optional
    :param radius: Radius of the cylinder along the xy-plane.
    :type size: float, optional
    :param size: Half of the length cylinder along the z-axis.
    :type slices: int, optional
    :param slices: Number of subdivisions around the z-axis.
    :type segments: int, optional
    :param segments: Number of subdivisions along the z-axis.
    :type rings: int, optional
    :param rings: Number of subdivisions on the caps.
    :type start: float, optional
    :param start: Counterclockwise angle around the z-axis relative to x-axis.
    :type sweep: float, optional
    :param sweep: Counterclockwise angle around the z-axis.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_capped_cylinder(*args, **kwargs)

def mesh_create_capped_tube(*args, **kwargs):
    r"""
    Creates a tube (a cylinder with thickness) with caps on both ends, centered at the origin and aligned along the z-axis.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type radius: float, optional
    :param radius: The outer radius of the cylinder on the xy-plane.
    :type innerRadius: float, optional
    :param innerRadius: The inner radius of the cylinder on the xy-plane.
    :type size: float, optional
    :param size: Half of the length of the cylinder along the z-axis.
    :type slices: int, optional
    :param slices: Number nubdivisions around the z-axis.
    :type segments: int, optional
    :param segments: Number of subdivisions along the z-axis.
    :type rings: int, optional
    :param rings: Number radial subdivisions in the cap.
    :type start: float, optional
    :param start: Counterclockwise angle around the z-axis relative to the x-axis.
    :type sweep: float, optional
    :param sweep: Counterclockwise angle around the z-axis.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_capped_tube(*args, **kwargs)

def mesh_create_capsule(*args, **kwargs):
    r"""
    Creates a capsule (a cylinder with spherical caps) centered at the origin and aligned along the z-axis.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type radius: float, optional
    :param radius: Radius of the capsule on the xy-plane.
    :type size: float, optional
    :param size: Half of the length between centers of the caps along the z-axis.
    :type slices: int, optional
    :param slices: Number of subdivisions around the z-axis in the caps.
    :type segments: int, optional
    :param segments: Number radial subdivisions in the cylinder.
    :type rings: int, optional
    :param rings: Number of radial subdivisions in the caps.
    :type start: float, optional
    :param start: Counterclockwise angle relative to the x-axis.
    :type sweep: float, optional
    :param sweep: Counterclockwise angle.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_capsule(*args, **kwargs)

def mesh_create_cone(*args, **kwargs):
    r"""
    Creates a cone centered at the origin, and whose tip points towards the z-axis.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type radius: float, optional
    :param radius: Radius of the negative z end on the xy-plane.
    :type size: float, optional
    :param size: Half of the length of the cylinder along the z-axis.
    :type slices: int, optional
    :param slices: Number of subdivisions around the z-axis.
    :type segments: int, optional
    :param segments: Number subdivisions along the z-axis.
    :type start: float, optional
    :param start: Counterclockwise angle around the z-axis relative to the x-axis.
    :type sweep: float, optional
    :param sweep: Counterclockwise angle around the z-axis.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_cone(*args, **kwargs)

def mesh_create_convex_polygon_from_circle(name, radius=1.0, sides=5, segments=4, rings=4):
    r"""
    Creates a convex polygonal disk with an arbitrary number of corners.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type radius: float, optional
    :param radius: The radius the enclosing circle.
    :type sides: int, optional
    :param sides: The number of sides. Should be >= 3. If <3 an empty mesh is generated.
    :type segments: int, optional
    :param segments: The number of segments per side. Should be >= 1. If zero an empty mesh is generated.
    :type rings: int, optional
    :param rings: The number of radial segments. Should be >= 1. = yields an empty mesh.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_convex_polygon_from_circle(name, radius, sides, segments, rings)

def mesh_create_convex_polygon(name, vertices, segments=1, rings=1):
    r"""
    Creates a convex polygon from a set of corner vertices.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type vertices: std::vector< glm::vec2,std::allocator< glm::vec2 > >
    :param vertices: The corner coplanar vertex coordinates. Should form a convex polygon.
    :type segments: int, optional
    :param segments: The number of segments per side. Should be >= 1. If zero an empty mesh is generated.
    :type rings: int, optional
    :param rings: The number of radial segments. Should be >= 1. = yields an empty mesh.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_convex_polygon(name, vertices, segments, rings)

def mesh_create_cylinder(*args, **kwargs):
    r"""
    Creates an uncapped cylinder centered at the origin and aligned along the z-axis

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type radius: float, optional
    :param radius: Radius of the cylinder along the xy-plane.
    :type size: float, optional
    :param size: Half of the length of the cylinder along the z-axis.
    :type slices: int, optional
    :param slices: Subdivisions around the z-axis.
    :type segments: int, optional
    :param segments: Subdivisions along the z-axis.
    :type start: float, optional
    :param start: Counterclockwise angle around the z-axis relative to the x-axis.
    :type sweep: float, optional
    :param sweep: Counterclockwise angle around the z-axis.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_cylinder(*args, **kwargs)

def mesh_create_disk(*args, **kwargs):
    r"""
    Creates a circular disk centered at the origin and along the xy-plane

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type radius: float, optional
    :param radius: Outer radius of the disk on the xy-plane.
    :type innerRadius: float, optional
    :param innerRadius: radius of the inner circle on the xy-plane.
    :type slices: int, optional
    :param slices: Number of subdivisions around the z-axis.
    :type rings: int, optional
    :param rings: Number of subdivisions along the radius.
    :type start: float, optional
    :param start: Counterclockwise angle relative to the x-axis
    :type sweep: float, optional
    :param sweep: Counterclockwise angle.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_disk(*args, **kwargs)

def mesh_create_dodecahedron(name, radius=1.0, segments=1, rings=1):
    r"""
    Creates a regular dodecahedron centered at the origin and with a given radius.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
        Each face is optionally subdivided along the edges and/or radius.
    :type radius: float, optional
    :param radius: The radius of the enclosing sphere.
    :type segments: int, optional
    :param segments: The number segments along each edge. Should be >= 1. If <1 empty mesh is generated.
    :type rings: int, optional
    :param rings: The number of radial segments on each face. Should be >= 1. If <1 an empty mesh is generated.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_dodecahedron(name, radius, segments, rings)

def mesh_create_plane(*args, **kwargs):
    r"""
    Creates a plane (a regular grid) on the xy-plane whose normal points towards the z-axis.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type size: :py:class:`vec2`, optional
    :param size: Half of the side length in x (0) and y (1) direction.
    :type segments: :py:class:`ivec2`, optional
    :param segments: Number of subdivisions in the x (0) and y (1) direction.
    :type flip_z: boolean, optional
    :param flip_z: Flips the plane such that the face is pointed down negative Z instead of positive Z.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_plane(*args, **kwargs)

def mesh_create_icosahedron(name, radius=1.0, segments=1):
    r"""
    Creates a regular icosahedron centered at the origin and with a given radius.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type radius: float, optional
    :param radius: The radius of the enclosing sphere.
    :type segments: int, optional
    :param segments: The number segments along each edge. Must be >= 1.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_icosahedron(name, radius, segments)

def mesh_create_icosphere(name, radius=1.0, segments=4):
    r"""
    Creates an icosphere, otherwise known as a spherical subdivided icosahedron.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type radius: float, optional
    :param radius: The radius of the containing sphere.
    :type segments: int, optional
    :param segments: The number of segments per icosahedron edge. Must be >= 1.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_icosphere(name, radius, segments)

def mesh_create_rounded_box(*args, **kwargs):
    r"""
    Creates a rectangular box with rounded edges, centered at the origin and aligned along the x, y, and z axis.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type radius: float, optional
    :param radius: Radius of the rounded edges.
    :type size: :py:class:`vec3`, optional
    :param size: Half of the side length in x (0), y (1) and z (2) direction.
    :type slices: int, optional
    :param slices: Number subdivions around in the rounded edges.
    :type segments: :py:class:`ivec3`, optional
    :param segments: Number of subdivisions in x (0), y (1) and z (2) direction for the flat faces.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_rounded_box(*args, **kwargs)

def mesh_create_sphere(*args, **kwargs):
    r"""
    Creates a sphere of the given radius, centered around the origin, subdivided around the z-axis in slices and along the z-axis in segments.

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type radius: float, optional
     :param radius: The radius of the sphere
     :type slices: int, optional
     :param slices: Subdivisions around the z-axis (longitudes).
     :type segments: int, optional
     :param segments: Subdivisions along the z-axis (latitudes).
     :type sliceStart: float, optional
     :param sliceStart: Counterclockwise angle around the z-axis relative to x-axis.
     :type sliceSweep: float, optional
     :param sliceSweep: Counterclockwise angle.
     :type segmentStart: float, optional
     :param segmentStart: Counterclockwise angle relative to the z-axis.
     :type segmentSweep: float, optional
     :param segmentSweep: Counterclockwise angle.
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_sphere(*args, **kwargs)

def mesh_create_spherical_cone(*args, **kwargs):
    r"""
    Creates a cone with a spherical cap, centered at the origin and whose tip points towards the z-axis.
     Each point on the cap has equal distance from the tip.

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type radius: float, optional
     :param radius: Radius of the negative z end on the xy-plane.
     :type size: float, optional
     :param size: Half of the distance between cap and tip along the z-axis.
     :type slices: int, optional
     :param slices: Number of subdivisions around the z-axis.
     :type segments: int, optional
     :param segments: Number subdivisions along the z-axis.
     :type rings: int, optional
     :param rings: Number subdivisions in the cap.
     :type start: float, optional
     :param start: Counterclockwise angle around the z-axis relative to the positive x-axis.
     :type sweep: float, optional
     :param sweep: Counterclockwise angle around the z-axis.
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_spherical_cone(*args, **kwargs)

def mesh_create_spherical_triangle_from_sphere(name, radius=1.0, segments=4):
    r"""
    Creates a triangular region on the surface of a sphere.

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type radius: float, optional
     :param radius: Radius of the containing sphere.
     :type segments: int, optional
     :param segments: Number of subdivisions along each edge.
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_spherical_triangle_from_sphere(name, radius, segments)

def mesh_create_spherical_triangle_from_triangle(name, v0, v1, v2, segments=4):
    r"""
    Creates a triangular region on the surface of a sphere.

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type v0: :py:class:`vec3`
     :param v0: First of the three counter-clockwise triangle vertices
     :type v1: :py:class:`vec3`
     :param v1: Second of the three counter-clockwise triangle vertices
     :type v2: :py:class:`vec3`
     :param v2: Third of the three counter-clockwise triangle vertices
     :type segments: int, optional
     :param segments: Number of subdivisions along each edge.
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_spherical_triangle_from_triangle(name, v0, v1, v2, segments)

def mesh_create_spring(*args, **kwargs):
    r"""
    Creates a spring aligned along the z-axis and with a counter-clockwise winding.

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type minor: float, optional
     :param minor: Radius of the spring it self.
     :type major: float, optional
     :param major: Radius from the z-axis
     :type size: float, optional
     :param size: Half of the length along the z-axis.
     :type slices: int, optional
     :param slices: Subdivisions around the spring.
     :type segments: int, optional
     :param segments: Subdivisions along the path.
     :type majorStart: float, optional
     :param majorStart: Counterclockwise angle around the z-axis relative to the x-axis.
     :type majorSweep: float, optional
     :param majorSweep: Counterclockwise angle around the z-axis.
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_spring(*args, **kwargs)

def mesh_create_teapotahedron(name, segments=8):
    r"""
    Creates the Utah Teapot using the original b-spline surface data. (https://en.wikipedia.org/wiki/Utah_teapot)
     The lid is points towards the z axis and the spout points towards the x axis.

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type segments: int, optional
     :param segments: The number segments along each patch. Should be >= 1. If zero empty mesh is generated.
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_teapotahedron(name, segments)

def mesh_create_torus(*args, **kwargs):
    r"""
    Creates a torus centered at the origin and along the xy-plane.

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type minor: float, optional
     :param minor: Radius of the minor (inner) ring
     :type major: float, optional
     :param major: Radius of the major (outer) ring
     :type slices: int, optional
     :param slices: Subdivisions around the minor ring
     :type segments: int, optional
     :param segments: Subdivisions around the major ring
     :type minorStart: float, optional
     :param minorStart: Counterclockwise angle relative to the xy-plane.
     :type minorSweep: float, optional
     :param minorSweep: Counterclockwise angle around the circle.
     :type majorStart: float, optional
     :param majorStart: Counterclockwise angle around the z-axis relative to the x-axis.
     :type majorSweep: float, optional
     :param majorSweep: Counterclockwise angle around the z-axis.
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_torus(*args, **kwargs)

def mesh_create_torus_knot(name, p=2, q=3, slices=8, segments=96):
    r"""
    Creates a circle extruded along the path of a knot. (https://en.wikipedia.org/wiki/Torus_knot)

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type p: int, optional
     :param p: First coprime integer.
     :type q: int, optional
     :param q: Second coprime integer.
     :type slices: int, optional
     :param slices: Number subdivisions around the circle.
     :type segments: int, optional
     :param segments: Number of subdivisions around the path.
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_torus_knot(name, p, q, slices, segments)

def mesh_create_triangle_from_circumscribed_circle(name, radius=1.0, segments=4):
    r"""
    Creates a triangle centered at the origin and contained within the circumscribed circle.

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type radius: float, optional
     :param radius: The radius of the containing circle.
     :type segments: int, optional
     :param segments: The number of segments along each edge. Must be >= 1.
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_triangle_from_circumscribed_circle(name, radius, segments)

def mesh_create_triangle(name, v0, v1, v2, segments=4):
    r"""
    Creates a triangle from the specified vertices

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type v0: :py:class:`vec3`
     :param v0: First of the vertex positions of the triangle.
     :type v1: :py:class:`vec3`
     :param v1: Second of the vertex positions of the triangle.
     :type v2: :py:class:`vec3`
     :param v2: Third of the vertex positions of the triangle.
     :type segments: int, optional
     :param segments: The number of segments along each edge. Must be >= 1.
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_triangle(name, v0, v1, v2, segments)

def mesh_create_line(name, start, stop, radius=1.0, segments=16):
    r"""
    Creates a line from a circle extruded linearly between the specified start and stop positions.

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type start: :py:class:`vec3`
     :param start: The start position of the linear path.
     :type start: :py:class:`vec3`
     :param start: The stop position of the linear path.
     :type radius: float, optional
     :param radius: The radius of the extruded circle
     :type segments: int, optional
     :param segments: Number of subdivisions around the circle.
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_line(name, start, stop, radius, segments)

def mesh_create_tube(*args, **kwargs):
    r"""
    Creates an uncapped tube (a cylinder with thickness) centered at the origin and aligned along the z-axis.

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type radius: float, optional
     :param radius: The outer radius of the cylinder on the xy-plane.
     :type innerRadius: float, optional
     :param innerRadius: The inner radius of the cylinder on the xy-plane.
     :type size: float, optional
     :param size: Half of the length of the cylinder along the z-axis.
     :type slices: int, optional
     :param slices: Subdivisions around the z-axis.
     :type segments: int, optional
     :param segments: Subdivisions along the z-axis.
     :type start: float, optional
     :param start: Counterclockwise angle around the z-axis relative to the x-axis.
     :type sweep: float, optional
     :param sweep: Counterclockwise angle around the z-axis.
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_tube(*args, **kwargs)

def mesh_create_tube_from_polyline(name, path, radius=1.0, segments=16):
    r"""
    Creates a tube from a circle extruded linearly along the specified path.

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type path: std::vector< glm::vec3,std::allocator< glm::vec3 > >
     :param path: A set of vertices describing a linear path.
     :type radius: float, optional
     :param radius: The radius of the extruded circle
     :type segments: int, optional
     :param segments: Number of subdivisions around the circle.
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_tube_from_polyline(name, path, radius, segments)

def mesh_create_rounded_rectangle_tube_from_polyline(*args, **kwargs):
    r"""
    Creates a tube from a rounded rectangle extruded linearly along the specified path.

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type path: std::vector< glm::vec3,std::allocator< glm::vec3 > >
     :param path: A set of vertices describing a linear path.
     :type radius: float, optional
     :param radius: The radius of the rounded corners
     :type size: :py:class:`vec2`, optional
     :param size: Half of the length of an edge
     :type slices: int, optional
     :param slices: Number of subdivisions in each rounded corner
     :type segments: :py:class:`ivec2`, optional
     :param segments: Number of subdivisions along each edge
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_rounded_rectangle_tube_from_polyline(*args, **kwargs)

def mesh_create_rectangle_tube_from_polyline(*args, **kwargs):
    r"""
    Creates a tube from a rounded rectangle extruded linearly along the specified path.

     :type name: string
     :param name: The name (used as a primary key) for this mesh component
     :type path: std::vector< glm::vec3,std::allocator< glm::vec3 > >
     :param path: A set of vertices describing a linear path.
     :type size: :py:class:`vec2`, optional
     :param size: Half of the length of an edge
     :type segments: :py:class:`ivec2`, optional
     :param segments: Number of subdivisions along each edge
     :rtype: :py:class:`Mesh`
     :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_rectangle_tube_from_polyline(*args, **kwargs)

def mesh_create_wireframe_bounding_box(*args, **kwargs):
    r"""
    Creates a wireframe bounding box spanning the region between the minimum corner to
    the maximum corner, and aligned along the x, y, and z axis.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type min_corner: :py:class:`vec3`, optional
    :param min_corner: The position of the bottom left near corner of the axis aligned bounding box.
    :type max_corner: :py:class:`vec3`, optional
    :param max_corner: The position of the top right far corner of the axis aligned bounding box.
    :param size: The side length in x (0), y (1) and z (2) direction.
    :type thickness: float, optional
    :param thickness: The thickness of the wires in the wireframe.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_wireframe_bounding_box(*args, **kwargs)

def mesh_create_from_obj(name, path):
    r"""Deprecated. Please use create_from_file instead."""
    return _nvisii.mesh_create_from_obj(name, path)

def mesh_create_from_file(name, path):
    r"""
    Creates a mesh component from a file (ignoring any associated materials)

    Supported file formats include: AMF 3DS AC ASE ASSBIN B3D BVH COLLADA DXF
    CSM HMP IRRMESH IRR LWO LWS M3D MD2 MD3 MD5 MDC MDL NFF NDO OFF OBJ OGRE
    OPENGEX PLY MS3D COB BLEND IFC XGL FBX Q3D Q3BSP RAW SIB SMD STL
    TERRAGEN 3D X X3D GLTF 3MF MMD

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type path: string
    :param path: A path to the file.
    """
    return _nvisii.mesh_create_from_file(name, path)

def mesh_create_from_data(*args, **kwargs):
    r"""
    Creates a mesh component from a set of positions, optional normals, optional colors, optional texture coordinates,
    and optional indices. If anything other than positions is supplied (eg normals), that list must be the same length
    as the point list. If indicies are supplied, indices must be a multiple of 3 (triangles). Otherwise, all other
    supplied per vertex data must be a multiple of 3 in length.

    :type name: string
    :param name: The name (used as a primary key) for this mesh component
    :type positions: std::vector< float,std::allocator< float > >
    :param positions: A list of vertex positions. If indices aren't supplied, this must be a multiple of 3.
    :type position_dimensions: int, optional
    :param position_dimensions: The number of floats per position. Valid numbers are 3 or 4.
    :type normals: std::vector< float,std::allocator< float > >, optional
    :param normals: A list of vertex normals. If indices aren't supplied, this must be a multiple of 3.
    :type normal_dimensions: int, optional
    :param normal_dimensions: The number of floats per normal. Valid numbers are 3 or 4.
    :type colors: std::vector< float,std::allocator< float > >, optional
    :param colors: A list of per-vertex colors. If indices aren't supplied, this must be a multiple of 3.
    :type color_dimensions: int, optional
    :param color_dimensions: The number of floats per color. Valid numbers are 3 or 4.
    :type texcoords: std::vector< float,std::allocator< float > >, optional
    :param texcoords: A list of 2D per-vertex texture coordinates. If indices aren't supplied, this must be a multiple of 3.
    :type texcoord_dimensions: int, optional
    :param texcoord_dimensions: The number of floats per texcoord. Valid numbers are 2. (3 might be supported later for 3D textures...)
    :type indices: std::vector< uint32_t,std::allocator< uint32_t > >, optional
    :param indices: A list of integer indices connecting vertex positions in a counterclockwise ordering to form triangles. If supplied, indices must be a multiple of 3.
    :rtype: :py:class:`Mesh`
    :return: a reference to the mesh component
    """
    return _nvisii.mesh_create_from_data(*args, **kwargs)

def mesh_get(name):
    r"""
    :type name: string
    :param name: The name of the Mesh to get
    :rtype: :py:class:`Mesh`
    :return: a Mesh who's name matches the given name
    """
    return _nvisii.mesh_get(name)

def mesh_get_front_struct():
    r"""
    :rtype: MeshStruct
    :return: a pointer to the table of MeshStructs required for rendering
    """
    return _nvisii.mesh_get_front_struct()

def mesh_get_front():
    r"""
    :rtype: :py:class:`Mesh`
    :return: a pointer to the table of mesh components
    """
    return _nvisii.mesh_get_front()

def mesh_get_count():
    r"""
    :rtype: int
    :return: the number of allocated meshes
    """
    return _nvisii.mesh_get_count()

def mesh_get_name_to_id_map():
    r"""
    :rtype: std::map< std::string,uint32_t,std::less< std::string >,std::allocator< std::pair< std::string const,uint32_t > > >
    :return: A map whose key is a mesh name and whose value is the ID for that mesh
    """
    return _nvisii.mesh_get_name_to_id_map()

def mesh_remove(name):
    r"""
    :type name: string
    :param name: The name of the Mesh to remove
    """
    return _nvisii.mesh_remove(name)

def mesh_initialize_factory(max_components):
    r""" Allocates the tables used to store all mesh components"""
    return _nvisii.mesh_initialize_factory(max_components)

def mesh_is_factory_initialized():
    r"""
    :rtype: boolean
    :return: True if the tables used to store all mesh components have been allocated, and False otherwise
    """
    return _nvisii.mesh_is_factory_initialized()

def mesh_update_components():
    r""" Iterates through all mesh components, computing mesh metadata for rendering purposes."""
    return _nvisii.mesh_update_components()

def mesh_clear_all():
    r""" Clears any existing Mesh components."""
    return _nvisii.mesh_clear_all()

def mesh_are_any_dirty():
    r""" Indicates whether or not any meshes are "out of date" and need to be updated through the "update components" function"""
    return _nvisii.mesh_are_any_dirty()

def mesh_get_dirty_meshes():
    r"""
    :rtype: std::set< nvisii::Mesh * >
    :return: a list of meshes that have been modified since the previous frame
    """
    return _nvisii.mesh_get_dirty_meshes()

def mesh_get_edit_mutex():
    r""" For internal use. Returns the mutex used to lock entities for processing by the renderer."""
    return _nvisii.mesh_get_edit_mutex()



