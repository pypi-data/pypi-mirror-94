<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>libPoMo.cf &mdash; PoMo 1.1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="PoMo 1.1.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PoMo 1.1.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for libPoMo.cf</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot;libPoMo.cf</span>
<span class="sd">=============</span>

<span class="sd">This model provides functions to read, write and access files that are</span>
<span class="sd">in counts format.</span>

<span class="sd">The Counts Format</span>
<span class="sd">-----------------</span>

<span class="sd">This file format is used by PoMo and lists the base</span>
<span class="sd">counts for every position.</span>

<span class="sd">It contains:</span>
<span class="sd">  - 1 line that specifies the file as counts file and states the</span>
<span class="sd">    number of populations as well as the number of sites</span>
<span class="sd">  - 1 headerline with tab separated sequence names</span>
<span class="sd">  - N lines with counts of A, C, G and T bases at position n</span>

<span class="sd">It can contain:</span>
<span class="sd">  - any number of lines that start with a #, these are treated as</span>
<span class="sd">    comments; There are no more comments allowed after the headerline.</span>

<span class="sd">::</span>

<span class="sd">  COUNTSFILE \t NPOP 5 \t NSITES N</span>
<span class="sd">  CHROM \t POS   \t Sheep   \t BlackSheep \t RedSheep \t Wolf    \t RedWolf</span>
<span class="sd">  1  \t s     \t 0,0,1,0 \t 0,0,1,0    \t 0,0,1,0  \t 0,0,5,0 \t 0,0,0,1</span>
<span class="sd">  1  \t s + 1 \t 0,0,0,1 \t 0,0,0,1    \t 0,0,0,1  \t 0,0,0,5 \t 0,0,0,1</span>
<span class="sd">  .</span>
<span class="sd">  .</span>
<span class="sd">  .</span>
<span class="sd">  9  \t 8373  \t 0,0,0,1 \t 1,0,0,0    \t 0,1,0,0  \t 0,1,4,0 \t 0,0,1,0</span>
<span class="sd">  .</span>
<span class="sd">  .</span>
<span class="sd">  .</span>
<span class="sd">  Y  \t end   \t 0,0,0,1 \t 0,1,0,0    \t 0,1,0,0  \t 0,5,0,0 \t 0,0,1,0</span>

<span class="sd">Convert to Counts Format</span>
<span class="sd">------------------------</span>

<span class="sd">To convert a fasta reference file with SNP information from a variant</span>
<span class="sd">call format (VCF) to counts format use the :class:`CFWriter`. If you</span>
<span class="sd">want to convert a multiple alignment fasta file, use the</span>
<span class="sd">:class:`CFWriter` together with the convenience function</span>
<span class="sd">:func:`write_cf_from_MFaStream()`.</span>

<span class="sd">Tabix index files need to be provided for all VCF files. They can be</span>
<span class="sd">created from the terminal with $(tabix -p vcf &quot;vcf-file.vcf.gz&quot;) if</span>
<span class="sd">tabix is installed.</span>

<span class="sd">A code example is::</span>

<span class="sd">  import import_libPoMo</span>
<span class="sd">  import libPoMo.fasta as fa</span>
<span class="sd">  import libPoMo.cf as cf</span>

<span class="sd">  vcfFL = [&quot;/path/to/vcf/file1&quot;, &quot;/path/to/vcf/file2&quot;, &quot;...&quot;]</span>

<span class="sd">  cfw = cf.CFWriter(vcfFL, &quot;name-of-outfile&quot;)</span>
<span class="sd">  mFaStr = fa.MFaStream(&quot;/path/to/fasta/reference&quot;)</span>

<span class="sd">  cfw.write_HLn()</span>
<span class="sd">  cf.write_cf_from_MFaStream(mFaStr, cfw)</span>

<span class="sd">  cfw.close()</span>

<span class="sd">Objects</span>
<span class="sd">-------</span>
<span class="sd">Classes:</span>
<span class="sd">  - :class:`CFStream`</span>
<span class="sd">  - :class:`CFWriter`, write a counts format file</span>

<span class="sd">Exception Classes:</span>
<span class="sd">  - :class:`NotACountsFormatFileError`</span>
<span class="sd">  - :class:`CountsFormatWriterError`</span>
<span class="sd">  - :class:`NoSynBase`</span>

<span class="sd">Functions:</span>
<span class="sd">  - :func:`interpret_cf_line()`, get data of a line in counts format</span>
<span class="sd">  - :func:`faseq_append_base_of_cfS()`, append CFStream line to FaSeq</span>
<span class="sd">  - :func:`cf_to_fasta()`, convert counts file to fasta file</span>
<span class="sd">  - :func:`write_cf_from_MFaStream()`, write counts file using the</span>
<span class="sd">    given MFaStream and CFWriter</span>
<span class="sd">  - :func:`fasta_to_cf()`, convert fasta to counts format</span>

<span class="sd">----</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s1">&#39;restructuredtext&#39;</span>

<span class="kn">import</span> <span class="nn">pysam</span> <span class="k">as</span> <span class="nn">ps</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">pdb</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">libPoMo.seqbase</span> <span class="k">as</span> <span class="nn">sb</span>
<span class="kn">import</span> <span class="nn">libPoMo.fasta</span> <span class="k">as</span> <span class="nn">fasta</span>
<span class="kn">import</span> <span class="nn">libPoMo.vcf</span> <span class="k">as</span> <span class="nn">vcf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Honor IUPAC code.</span>
<span class="n">dna</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
       <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
       <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="mi">17</span><span class="p">}</span>
<span class="n">ind2dna</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span>
           <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="NotACountsFormatFileError"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.NotACountsFormatFileError">[docs]</a><span class="k">class</span> <span class="nc">NotACountsFormatFileError</span><span class="p">(</span><span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;CF file not valid.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="CountsFormatWriterError"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CountsFormatWriterError">[docs]</a><span class="k">class</span> <span class="nc">CountsFormatWriterError</span><span class="p">(</span><span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;General `CFWriter` object error.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="NoSynBase"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.NoSynBase">[docs]</a><span class="k">class</span> <span class="nc">NoSynBase</span><span class="p">(</span><span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Not a 4-fold degenerate site.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="interpret_cf_line"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.interpret_cf_line">[docs]</a><span class="k">def</span> <span class="nf">interpret_cf_line</span><span class="p">(</span><span class="n">ln</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpret a counts file line.</span>

<span class="sd">    Return type is a tuple containing the chromosome name, the</span>
<span class="sd">    position and a list with nucleotide counts (cf. counts file).</span>

<span class="sd">    :param str ln: Line in counts format.</span>

<span class="sd">    :rtype: (str, int, [[int]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">ln</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">ln</span> <span class="o">=</span> <span class="n">tmp</span>
    <span class="n">lnL</span> <span class="o">=</span> <span class="n">ln</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lnL</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">NotACountsFormatFileError</span><span class="p">(</span><span class="s2">&quot;Line contains no data.&quot;</span><span class="p">)</span>

    <span class="n">chrom</span> <span class="o">=</span> <span class="n">lnL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">lnL</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">countsLStr</span> <span class="o">=</span> <span class="p">[</span><span class="n">eL</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">eL</span> <span class="ow">in</span> <span class="n">lnL</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]</span>
    <span class="n">le</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">countsLStr</span><span class="p">)</span>
    <span class="n">countsL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">le</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">le</span><span class="p">):</span>
        <span class="n">countsL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">countsLStr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">countsL</span><span class="p">)</span></div>


<div class="viewcode-block" id="CFStream"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFStream">[docs]</a><span class="k">class</span> <span class="nc">CFStream</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Store data of a CF file line per line.</span>

<span class="sd">    Open a (gzipped) CF file. The file can be read line per line with</span>
<span class="sd">    :func:`read_next_pos()`.</span>

<span class="sd">    :param str CFFileName: Counts format file name to be read.</span>
<span class="sd">    :param str name: Optional; stream name, defaults to stripped</span>
<span class="sd">        filename.</span>

<span class="sd">    :ivar str name: Stream name.</span>
<span class="sd">    :ivar str chrom: Chromosome name.</span>
<span class="sd">    :ivar str pos: Positional string.</span>
<span class="sd">    :ivar fo fo: Fileobject.</span>
<span class="sd">    :ivar [str] indivL: List of names of individuals (populations).</span>
<span class="sd">    :ivar [[int]] countsL: Numpy array of nucleotide counts.</span>
<span class="sd">    :ivar int nIndiv: Number of individuals (populations).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CFFileName</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">CFFile</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">gz_open</span><span class="p">(</span><span class="n">CFFileName</span><span class="p">)</span>
        <span class="c1"># Set the cf sequence name.</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">stripFName</span><span class="p">(</span><span class="n">CFFileName</span><span class="p">)</span>
        <span class="c1"># Find the start of the first base.</span>
        <span class="n">ln</span> <span class="o">=</span> <span class="n">CFFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ln</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotACountsFormatFileError</span><span class="p">(</span><span class="s2">&quot;File contains no data.&quot;</span><span class="p">)</span>

        <span class="c1"># Skip comments.</span>
        <span class="k">while</span> <span class="n">ln</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
            <span class="n">ln</span> <span class="o">=</span> <span class="n">CFFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

        <span class="c1"># Read in first line.</span>
        <span class="n">lnL</span> <span class="o">=</span> <span class="n">ln</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lnL</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lnL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;COUNTSFILE&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NotACountsFormatFileError</span><span class="p">(</span><span class="s2">&quot;First line is corrupt.&quot;</span><span class="p">)</span>
        <span class="c1"># TODO: The first line is needed by IQ-Tree, but not by</span>
        <span class="c1"># libPoMo.  Maybe I should use this information here!</span>

        <span class="n">ln</span> <span class="o">=</span> <span class="n">CFFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

        <span class="c1"># Skip comments.</span>
        <span class="k">while</span> <span class="n">ln</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;#&#39;</span><span class="p">:</span>
            <span class="n">ln</span> <span class="o">=</span> <span class="n">CFFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

        <span class="c1"># Read in headerline.</span>
        <span class="n">lnL</span> <span class="o">=</span> <span class="n">ln</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lnL</span><span class="p">)</span>
        <span class="n">indivL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lnL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;CHROM&quot;</span><span class="p">,</span> <span class="s2">&quot;Chrom&quot;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">lnL</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;POS&quot;</span><span class="p">,</span> <span class="s2">&quot;Pos&quot;</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
                <span class="n">indivL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lnL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotACountsFormatFileError</span><span class="p">(</span><span class="s2">&quot;Header line is corrupt.&quot;</span><span class="p">)</span>
        <span class="n">ln</span> <span class="o">=</span> <span class="n">CFFile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="p">(</span><span class="n">chrom</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">countsL</span><span class="p">)</span> <span class="o">=</span> <span class="n">interpret_cf_line</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">countsL</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indivL</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">NotACountsFormatFileError</span><span class="p">(</span><span class="s2">&quot;Line doesn&#39;t fit nr. of species.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">chrom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fo</span> <span class="o">=</span> <span class="n">CFFile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indivL</span> <span class="o">=</span> <span class="n">indivL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">countsL</span> <span class="o">=</span> <span class="n">countsL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nIndiv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">countsL</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__update_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ln</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read CF line into :class:`CFStream`.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">countsL</span><span class="p">)</span> <span class="o">=</span> <span class="n">interpret_cf_line</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">countsL</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nIndiv</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NotACountsFormatFileError</span><span class="p">(</span><span class="s2">&quot;Line doesn&#39;t fit nr. of species.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="CFStream.read_next_pos"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFStream.read_next_pos">[docs]</a>    <span class="k">def</span> <span class="nf">read_next_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get next base.</span>

<span class="sd">        Return position of next base.  Raises `ValueError` if there is</span>
<span class="sd">        no next base.</span>

<span class="sd">        :rtype: int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ln</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fo</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ln</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__update_base</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;End of CFStream.&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="fasta_to_cf"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.fasta_to_cf">[docs]</a><span class="k">def</span> <span class="nf">fasta_to_cf</span><span class="p">(</span><span class="n">fastaFN</span><span class="p">,</span> <span class="n">countsFN</span><span class="p">,</span> <span class="n">splitChar</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">chromName</span><span class="o">=</span><span class="s2">&quot;NA&quot;</span><span class="p">,</span>
                <span class="n">double_fixed_sites</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert fasta to counts format.</span>

<span class="sd">    The (aligned) sequences in the fasta file are read in and the data</span>
<span class="sd">    is written to a counts format file.</span>

<span class="sd">    Sequence names are stripped at the first dash.  If the strupped</span>
<span class="sd">    sequence name coincide, individuals are put into the same</span>
<span class="sd">    population.</span>

<span class="sd">    E.g., homo_sapiens-XXX and homo_sapiens-YYY will be in the same</span>
<span class="sd">    population homo_sapiens.</span>

<span class="sd">    Take care with large files, this uses a lot of memory.</span>

<span class="sd">    The input as well as the output files can additionally be gzipped</span>
<span class="sd">    (indicated by a .gz file ending).</span>

<span class="sd">    :ivar bool double_fixed_sites: Set to true if heterozygotes are</span>
<span class="sd">    encoded with IUPAC codes.  Then, fixed sites will be counted twice</span>
<span class="sd">    so that the level of polymorphism stays correct.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">FaStr</span> <span class="o">=</span> <span class="n">fasta</span><span class="o">.</span><span class="n">init_seq</span><span class="p">(</span><span class="n">fastaFN</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Read in fasta file </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">fastaFN</span><span class="p">)</span>
    <span class="n">seqL</span> <span class="o">=</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">FaStr</span><span class="o">.</span><span class="n">seq</span><span class="p">)]</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">FaStr</span><span class="o">.</span><span class="n">read_next_seq</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">seqL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">FaStr</span><span class="o">.</span><span class="n">seq</span><span class="p">))</span>

    <span class="n">nSeqs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqL</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Number of sequences: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">nSeqs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seqL</span><span class="p">:</span>
        <span class="n">newName</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="n">splitChar</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">newName</span>
        <span class="c1"># s.print_info()</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Checking sequence lengths.&quot;</span><span class="p">)</span>
    <span class="n">nSites</span> <span class="o">=</span> <span class="n">seqL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dataLen</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seqL</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nSites</span> <span class="o">!=</span> <span class="n">s</span><span class="o">.</span><span class="n">dataLen</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s2">&quot;Sequences do not have equal length.&quot;</span><span class="p">)</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Creating assignment list.&quot;</span><span class="p">)</span>
    <span class="n">assL</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nameL</span> <span class="o">=</span> <span class="p">[</span><span class="n">seqL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seqL</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">nameL</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">assL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">nameL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">assL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nameL</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">nPops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nameL</span><span class="p">)</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Number of Populations: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">nPops</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Number of Sites: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">nSites</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Populations: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">nameL</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Assignment list: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">assL</span><span class="p">)</span>

    <span class="n">cfw</span> <span class="o">=</span> <span class="n">CFWriter</span><span class="p">([],</span> <span class="n">countsFN</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Manually initializing CFWriter.&quot;</span><span class="p">)</span>
    <span class="n">cfw</span><span class="o">.</span><span class="n">nL</span> <span class="o">=</span> <span class="n">nameL</span>
    <span class="n">cfw</span><span class="o">.</span><span class="n">nPop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nameL</span><span class="p">)</span>
    <span class="n">cfw</span><span class="o">.</span><span class="n">write_HLn</span><span class="p">()</span>

    <span class="c1"># Loop over sites.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nSites</span><span class="p">):</span>
        <span class="n">cfw</span><span class="o">.</span><span class="n">purge_cD</span><span class="p">()</span>
        <span class="n">cfw</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">cfw</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">chromName</span>
        <span class="c1"># Loop over sequences / individuals.</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nSeqs</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">seqL</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">cfw</span><span class="o">.</span><span class="n">add_base_to_sequence</span><span class="p">(</span><span class="n">assL</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">base</span><span class="p">,</span> <span class="n">double_fixed_sites</span><span class="p">)</span>
        <span class="n">cfw</span><span class="o">.</span><span class="n">write_Ln</span><span class="p">()</span>
    <span class="n">cfw</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="weighted_choice"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.weighted_choice">[docs]</a><span class="k">def</span> <span class="nf">weighted_choice</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Choose element in integer list according to its value.</span>

<span class="sd">    E.g., in [1,10], the second element will be chosen 10 times as</span>
<span class="sd">    often as the first one.  Returns the index of the chosen element.</span>

<span class="sd">    :ivar [int] lst: List of integers.</span>

<span class="sd">    :rtype: int</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span>
    <span class="n">upto</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Loop over list and pick one element.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">upto</span> <span class="o">+</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>
        <span class="n">upto</span> <span class="o">+=</span> <span class="n">c</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Shouldn&#39;t get here&quot;</span></div>


<div class="viewcode-block" id="faseq_append_base_of_cfS"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.faseq_append_base_of_cfS">[docs]</a><span class="k">def</span> <span class="nf">faseq_append_base_of_cfS</span><span class="p">(</span><span class="n">faS</span><span class="p">,</span> <span class="n">cfS</span><span class="p">,</span> <span class="n">consensus</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Append a :class:`CFStream` line to an :class:`libPoMo.fasta.FaSeq`.</span>

<span class="sd">    Randomly chooses bases for each position according to their</span>
<span class="sd">    abundance.</span>

<span class="sd">    :param FaSeq faS: Fasta sequence to append base to.</span>
<span class="sd">    :param CFStream cfS: CFStream containing the base.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">consensus</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cfS</span><span class="o">.</span><span class="n">nIndiv</span><span class="p">):</span>
            <span class="n">max_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">cfS</span><span class="o">.</span><span class="n">countsL</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># print(&quot;base:&quot;, ind2dna[max_index])</span>
            <span class="n">faS</span><span class="o">.</span><span class="n">seqL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">+=</span> <span class="n">ind2dna</span><span class="p">[</span><span class="n">max_index</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cfS</span><span class="o">.</span><span class="n">nIndiv</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">weighted_choice</span><span class="p">(</span><span class="n">cfS</span><span class="o">.</span><span class="n">countsL</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">faS</span><span class="o">.</span><span class="n">seqL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">+=</span> <span class="n">ind2dna</span><span class="p">[</span><span class="n">j</span><span class="p">]</span></div>


<div class="viewcode-block" id="cf_to_fasta"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.cf_to_fasta">[docs]</a><span class="k">def</span> <span class="nf">cf_to_fasta</span><span class="p">(</span><span class="n">cfS</span><span class="p">,</span> <span class="n">outname</span><span class="p">,</span> <span class="n">consensus</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a :class:`CFStream` to a fasta file.</span>

<span class="sd">    Extracts the sequences of a counts file that has been initialized</span>
<span class="sd">    with an :class:`CFStream`.  The conversion starts at the line</span>
<span class="sd">    pointed to by the :class:`CFStream`.</span>

<span class="sd">    If more than one base is present at a single site, one base is</span>
<span class="sd">    sampled out of all present ones according to its abundance.</span>

<span class="sd">    If consensus is set to True, the consensus sequence is extracted</span>
<span class="sd">    (e.g., no sampling but the bases with highest counts for each</span>
<span class="sd">    individual or population are chosen).</span>

<span class="sd">    :param CFStream cfS: Counts format file stream.</span>
<span class="sd">    :param str outname: Fasta output file name.</span>
<span class="sd">    :param Boolean consensus: Optional; Extract consensus sequence?</span>
<span class="sd">      Defaults to False.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Convert counts file to fasta.&quot;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Counts file stream to be converted: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">cfS</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fasta output file: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">outname</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Consensus is set to </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">consensus</span><span class="p">)</span>
    <span class="n">faS</span> <span class="o">=</span> <span class="n">fasta</span><span class="o">.</span><span class="n">FaSeq</span><span class="p">()</span>

    <span class="n">faS</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">cfS</span><span class="o">.</span><span class="n">name</span>

    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">cfS</span><span class="o">.</span><span class="n">indivL</span><span class="p">:</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">Seq</span><span class="p">()</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">ind</span>
        <span class="n">faS</span><span class="o">.</span><span class="n">seqL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

    <span class="c1"># print(cfS.chrom, cfS.pos)</span>
    <span class="n">faseq_append_base_of_cfS</span><span class="p">(</span><span class="n">faS</span><span class="p">,</span> <span class="n">cfS</span><span class="p">)</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cfS</span><span class="o">.</span><span class="n">read_next_pos</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print(cfS.chrom, cfS.pos)</span>
            <span class="n">faseq_append_base_of_cfS</span><span class="p">(</span><span class="n">faS</span><span class="p">,</span> <span class="n">cfS</span><span class="p">,</span> <span class="n">consensus</span><span class="p">)</span>

    <span class="n">of</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">outname</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cfS</span><span class="o">.</span><span class="n">nIndiv</span><span class="p">):</span>
        <span class="n">faS</span><span class="o">.</span><span class="n">seqL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">print_fa_entry</span><span class="p">(</span><span class="n">fo</span><span class="o">=</span><span class="n">of</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">of</span><span class="p">)</span>
    <span class="n">of</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="CFWriter"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter">[docs]</a><span class="k">class</span> <span class="nc">CFWriter</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Write a counts format file.</span>

<span class="sd">    Save information that is needed to write a CF file and use this</span>
<span class="sd">    information to write a CF file.  Initialize with a list of vcf</span>
<span class="sd">    file names and an output file name::</span>

<span class="sd">      CFWriter([vcfFileNames], &quot;output&quot;)</span>

<span class="sd">    Tabix index files need to be provided for all VCF files. They can</span>
<span class="sd">    be created from the terminal with $(tabix -p vcf</span>
<span class="sd">    &quot;vcf-file.vcf.gz&quot;) if tabix is installed.</span>

<span class="sd">    Before the count file can be written, a reference sequence has to</span>
<span class="sd">    be specified.  A single reference sequence can be set with</span>
<span class="sd">    :func:`set_seq`.</span>

<span class="sd">    Write a header line to output::</span>

<span class="sd">       self.write_HLn()</span>

<span class="sd">    Write lines in counts format from 1-based positions *start* to</span>
<span class="sd">    *end* on chromosome *chrom* to output::</span>

<span class="sd">       rg = sb.Region(&quot;chrom&quot;, start, end)</span>
<span class="sd">       self.write_Rn(rg)</span>

<span class="sd">    If you want to compare the SNPs of the VCF files to a multiple</span>
<span class="sd">    alingment fasta stream (:class:`MFaStream</span>
<span class="sd">    &lt;libPoMo.fasta.MFaStream&gt;`) consider the very convenient function</span>
<span class="sd">    :func:`write_cf_from_MFaStream`.</span>

<span class="sd">    To determine the different populations present in the VCF files,</span>
<span class="sd">    the names of the individuals will be cropped at a specific char</span>
<span class="sd">    that can be set at initialization (standard value = &#39;-&#39;). It is</span>
<span class="sd">    also possible to collapse all individuals of determined VCF files</span>
<span class="sd">    to a single population (cf. mergeL and nameL).</span>

<span class="sd">    The ploidity has to be set manually if it differs from 2.</span>

<span class="sd">    Additional filters can be set before the counts file is written</span>
<span class="sd">    (e.g. only write synonymous sites).</span>

<span class="sd">    Important: Remember to close the attached file objectsL with</span>
<span class="sd">    :func:`close()`.  If the CFWriter is not closed, the counts file</span>
<span class="sd">    is not usable because the first line is missing!</span>

<span class="sd">    :param [str] vcfFileNameL: List with names of vcf files.</span>
<span class="sd">    :param str outFileName: Output file name.</span>
<span class="sd">    :param int verb: Optional; verbosity level.</span>
<span class="sd">    :param char splitChar: Optional; set the split character so that</span>
<span class="sd">      the individuals get sorted into the correct populations.</span>
<span class="sd">    :param [Boolean] mergeL: Optional; a list of truth values.  If</span>
<span class="sd">      *mL[i]* is True, all individuals of *self.vcfL[i]* are treated as</span>
<span class="sd">      one population orspecies independent of their name.  The</span>
<span class="sd">      respective counts are summed up.  If *self.nL[i]* is given, the</span>
<span class="sd">      name of the summed sequence will be *self.nL[i]*.  If not, the</span>
<span class="sd">      name of the first individual in *vcfL[i]* will be used.</span>
<span class="sd">    :param [str] nameL: Optional; a list of names. Cf. *self.mL*.</span>
<span class="sd">    :param Boolean oneIndividual: Optional; pick one individual out</span>
<span class="sd">      of each population.</span>

<span class="sd">    :ivar str refFN: Name of reference fasta file.</span>
<span class="sd">    :ivar [str] vcfL: List with names of vcf files.</span>
<span class="sd">    :ivar str outFN: Output file name.</span>
<span class="sd">    :ivar int v: Verbosity.</span>
<span class="sd">    :ivar [Boolean] mL: A list of truth values.  If *mL[i]* is True,</span>
<span class="sd">        all individuals of *self.vcfL[i]* are treated as one</span>
<span class="sd">        population orspecies independent of their name.  The</span>
<span class="sd">        respective counts are summed up.  If *self.nL[i]* is given,</span>
<span class="sd">        the name of the summed sequence will be *self.nL[i]*.  If not,</span>
<span class="sd">        the name of the first individual in *vcfL[i]* will be used.</span>
<span class="sd">    :ivar [str] nL: A list of names. Cf. *self.mL*.</span>
<span class="sd">    :ivar int nV: Number of vcf files.</span>
<span class="sd">    :ivar [fo] vcfTfL: List with *pysam.Tabixfile* objects. Filled by</span>
<span class="sd">        *self.__init_vcfTfL()* during initialization.</span>
<span class="sd">    :ivar fo outFO: File object of the outfile. Filled by</span>
<span class="sd">        *self.__init_outFO()* during initialization.</span>
<span class="sd">    :ivar cD: List with allele or base counts. The alleles of</span>
<span class="sd">        individuals from the same population are summed up.  Hence,</span>
<span class="sd">        *self.cD[p]* gives the base counts of population *p* in the</span>
<span class="sd">        form: [0, 0, 0, 0].  Population *p* does not need to be the</span>
<span class="sd">        one from *self.vcfL[p]* because several populations might be</span>
<span class="sd">        present in one vcf file.  *self.assM* connects the individual</span>
<span class="sd">        j from *self.vcfL[i]* such that *self.assM[i][j]* is *p*.</span>
<span class="sd">    :ivar str chrom: Name of the current chromosome. Set and updated</span>
<span class="sd">        by :func:`write_Rn`.</span>
<span class="sd">    :ivar int pos: Current position on chromosome. Set and updated by</span>
<span class="sd">        :func:`write_Rn`.</span>
<span class="sd">    :ivar int offset: Value that can be set with :func:`set_offset`,</span>
<span class="sd">                      if the reference sequence does not start at the</span>
<span class="sd">                      1-based position 1 but at the 1-based position</span>
<span class="sd">                      *offset*.</span>
<span class="sd">    :ivar indM: Matrix with individuals from vcf files. *self.indM[i]*</span>
<span class="sd">        is the list of individuals found in *self.vcfL[i]*.</span>
<span class="sd">    :ivar [int] nIndL: List with number of individuals in</span>
<span class="sd">        *self.vcfL[i]*.</span>
<span class="sd">    :ivar assM: Assignment matrix that connects the individuals from</span>
<span class="sd">        the vcf files to the correct *self.cD* index.  Cf. *self.cD*</span>
<span class="sd">    :ivar int nPop: Number of different populations in count format</span>
<span class="sd">        output file (e.g. number of populations).  Filled by</span>
<span class="sd">        *self.__init_assM()* during initialization.</span>
<span class="sd">    :ivar Seq refSeq: :class:`Seq &lt;libPoMo.seqbase.Seq&gt;` object of the</span>
<span class="sd">        reference Sequence. This has to be set with :class:`set_seq`.</span>
<span class="sd">    :ivar int ploidy: Ploidy of individuals in vcf files.  This has to</span>
<span class="sd">        be set manually to the correct value for non-diploids!</span>
<span class="sd">    :ivar char splitCh: Character that is used to split the</span>
<span class="sd">        individual names.</span>
<span class="sd">    :ivar Boolean onlySynonymous: Only write 4-fold degenerate sites.</span>
<span class="sd">    :ivar int baseCounter: Counts the total number of bases.</span>
<span class="sd">    :ivar Boolean __force: If set to true, skip name checks.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vcfFileNameL</span><span class="p">,</span> <span class="n">outFileName</span><span class="p">,</span>
                 <span class="n">splitChar</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">mergeL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nameL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">oneIndividual</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Passed variables.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcfL</span> <span class="o">=</span> <span class="n">vcfFileNameL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outFN</span> <span class="o">=</span> <span class="n">outFileName</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mL</span> <span class="o">=</span> <span class="n">mergeL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="o">=</span> <span class="n">nameL</span>
        <span class="c1"># Variables that are filled during initialization.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nV</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcfL</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outFO</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cD</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indM</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nIndL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assM</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nPop</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Variables that have to be set manually.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refSeq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Variables that may need to be set manually.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">splitCh</span> <span class="o">=</span> <span class="n">splitChar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onlySynonymous</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oneIndiv</span> <span class="o">=</span> <span class="n">oneIndividual</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseCounter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__force</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__init_vcfTfL</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_outFO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_indM</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_nIndL</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_assM</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_nL</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_cD</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init_vcfTfL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open vcf files given in *self.vcfL*.</span>

<span class="sd">        Tabix index files need to be provided. They can be created</span>
<span class="sd">        from the terminal with $(tabix -p vcf &quot;vcf-file.vcf.gz&quot;). The</span>
<span class="sd">        tabix file objects are stored in *self.vcfTfL*. They need to</span>
<span class="sd">        be closed with :func:`close`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcfL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">Tabixfile</span><span class="p">(</span><span class="n">fn</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No VCF file given, &quot;</span>
                          <span class="s2">&quot;CFWriter has to be initialized manually.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init_outFO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open *self.outFN*.</span>

<span class="sd">        If the file name ends with &quot;gz&quot;, the outfile will be</span>
<span class="sd">        compressed and is opened with gzip.open().</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outFO</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">gz_open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outFN</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init_indM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Extract individuals from the vcf files.&quot;&quot;&quot;</span>
        <span class="c1"># Get individuals from the vcf files.</span>
        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">tf</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
                <span class="n">hLn</span> <span class="o">=</span> <span class="n">ln</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">vcf</span><span class="o">.</span><span class="n">get_indiv_from_field_header</span><span class="p">(</span><span class="n">hLn</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">__init_nIndL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Count individuals in each vcf file.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">indL</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nIndL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indL</span><span class="p">))</span>

    <span class="c1"># TODO: Check if this works, when individuals are mixed.</span>
    <span class="k">def</span> <span class="nf">__init_assM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill assignment matrix *self.assM*.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">collapse_and_append</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dN</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Collapse individual names of *self.vcfL[n]*.</span>

<span class="sd">            Appends the collapsed individual names of *self.vcfL[n]*</span>
<span class="sd">            to *self.assM*.</span>

<span class="sd">            :param int n: Index.</span>
<span class="sd">            :param int dN: Offset in assL.</span>
<span class="sd">            :rtype: int</span>

<span class="sd">            Returns new offset.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">splitCh</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                 <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
            <span class="n">aL</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cL</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">ddN</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">cL</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="n">aL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">dN</span><span class="o">+</span><span class="n">index</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">ddN</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">cL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="n">aL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">dN</span><span class="o">+</span><span class="n">ddN</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aL</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dN</span> <span class="o">+</span> <span class="n">ddN</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dI</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="n">dI</span> <span class="o">=</span> <span class="n">collapse_and_append</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dI</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mL</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="n">dI</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nIndL</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">dI</span><span class="p">])</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">dI</span> <span class="o">=</span> <span class="n">collapse_and_append</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dI</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">CountsFormatWriterError</span><span class="p">(</span><span class="s2">&quot;Merge list is not &quot;</span> <span class="o">+</span>
                                                  <span class="s2">&quot;a list of boolean values.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CountsFormatWriterError</span><span class="p">(</span><span class="s2">&quot;`mergeL` is not valid.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nPop</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dI</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Sometimes not all the information is used from the VCF</span>
        <span class="c1"># files.  E.g., if I only want to consider one individual per</span>
        <span class="c1"># populstion (cf. *self.oneIndiv*).</span>

        <span class="c1"># If individual j from VCF file i is not used, assM[i][j] is</span>
        <span class="c1"># set to -1.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">oneIndiv</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# One individual per population only.&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outFO</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# Picked individuals:&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outFO</span><span class="p">)</span>
            <span class="n">indivStr</span> <span class="o">=</span> <span class="s2">&quot;# &quot;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="n">dI</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">nI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">nI</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">pickN</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nI</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">indivStr</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">dI</span><span class="o">+</span><span class="n">pickN</span><span class="p">]</span>
                    <span class="n">indivStr</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dI</span><span class="p">,</span> <span class="n">dI</span><span class="o">+</span><span class="n">nI</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="n">dI</span> <span class="o">!=</span> <span class="n">pickN</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">dI</span> <span class="o">+=</span> <span class="n">nI</span>
                    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">indivStr</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outFO</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init_nL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill *self.nL*.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">append_to_nL</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">splitCh</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nL</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="n">append_to_nL</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPop</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CountsFormatWriterError</span><span class="p">(</span><span class="s2">&quot;`nameL` is not valid.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init_cD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the list with counts data.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cD</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nPop</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">__snp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate SNPs in region *rg* out of *self.vcfL*.</span>

<span class="sd">        Generator that returns the next SNP in region *rg*</span>
<span class="sd">        (cf. :class:`Region &lt;libPoMo.seqbase.Region&gt;`) as a :class:`NucBase`</span>
<span class="sd">        object.  To loop over all SNPs in region *rg*:</span>

<span class="sd">        &gt;&gt;&gt; rg = sb.Region(&quot;chr1&quot;, 500000, 1000000)</span>
<span class="sd">        &gt;&gt;&gt; for s in self.snp(rg):</span>
<span class="sd">        ....:   s.print_info()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">snpL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">snpIterL</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
            <span class="n">snpIterL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">reference</span><span class="o">=</span><span class="n">rg</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                                                 <span class="n">start</span><span class="o">=</span><span class="n">rg</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">rg</span><span class="o">.</span><span class="n">end</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">snpL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vcf</span><span class="o">.</span><span class="n">get_nuc_base_from_line</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">snpIterL</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                                       <span class="n">ploidy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">snpL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">snpL</span> <span class="o">==</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">snpL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">minPos</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
                    <span class="n">minI</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">break</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">snpL</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                   <span class="n">snpL</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">minPos</span><span class="p">:</span>
                    <span class="n">minPos</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
                    <span class="n">minI</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">minI</span><span class="p">,</span> <span class="n">snpL</span><span class="p">[</span><span class="n">minI</span><span class="p">])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">snpL</span><span class="p">[</span><span class="n">minI</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcf</span><span class="o">.</span><span class="n">get_nuc_base_from_line</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">snpIterL</span><span class="p">[</span><span class="n">minI</span><span class="p">]),</span>
                                                        <span class="n">ploidy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">snpL</span><span class="p">[</span><span class="n">minI</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">purge_cD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init_cD</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__fill_cD</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iL</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">snpL</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fill *self.cF*.</span>

<span class="sd">        Fill *self.cF* with data from reference at chromosome</span>
<span class="sd">        *self.chrom* and position *self.pos*. Possible SNPs in</span>
<span class="sd">        *self.vcfL* at this position are considered.</span>

<span class="sd">        :param [int] iL: List with vcf indices of the SNPs in *snpL*,</span>
<span class="sd">            must be sorted.</span>
<span class="sd">        :param [NucBase] snpL: List with :class:`NucBase</span>
<span class="sd">            &lt;libPoMo.vcf.NucBase&gt;` SNPs at this position. None, if</span>
<span class="sd">            there is no SNP.</span>
<span class="sd">        :raises: :class:`NotAValidRefBase</span>
<span class="sd">            &lt;libPoMo.seqbase.NotAValidRefBase&gt;`,</span>
<span class="sd">            :class:`SequenceDataError</span>
<span class="sd">            &lt;libPoMo.seqbase.SequenceDataError&gt;`</span>

<span class="sd">        :class:`NotAValidRefBae &lt;libPoMo.seqbase.NotAValidRefBase&gt;` is</span>
<span class="sd">        raised if the reference base is not valid (e.g. N).</span>

<span class="sd">        :class:`SequenceDataError &lt;libPoMo.seqbase.SequenceDataError&gt;`</span>
<span class="sd">        is raised if the chromosome names do not match.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">snpL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Next SNP(s):&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">snpL</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">get_info</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">get_refBase</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;Get reference base on *chrom* at *pos*.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">refSeq</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">update_cD</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">baseI</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Add counts to the countsDictionary cD.&quot;&quot;&quot;</span>
            <span class="c1"># FIXME: IUPAC code not handled here.  Is this even necessary?</span>
            <span class="k">if</span> <span class="n">baseI</span> <span class="o">==</span> <span class="n">dna</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Reference base is unknown.  Continue.&quot;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">pop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPop</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop</span><span class="p">][</span><span class="n">baseI</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Updating counts dictionary; population </span><span class="si">%s</span><span class="s2">, &quot;</span>
                              <span class="s2">&quot;base index </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">baseI</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Ignoring data because population index </span><span class="si">%s</span><span class="s2"> is &quot;</span>
                             <span class="s2">&quot;out of range.&quot;</span><span class="p">,</span> <span class="n">pop</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">purge_cD</span><span class="p">()</span>

        <span class="c1"># If we check for synonymous bases, do not do anything if base</span>
        <span class="c1"># is not 4-fold degenerate.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">onlySynonymous</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">refSeq</span><span class="o">.</span><span class="n">is_synonymous</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Rejection; </span><span class="si">%s</span><span class="s2"> at position </span><span class="si">%s</span><span class="s2"> &quot;</span>
                              <span class="s2">&quot;is not a synonymous base.&quot;</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">refSeq</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">],</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">NoSynBase</span><span class="p">()</span>

        <span class="n">refBase</span> <span class="o">=</span> <span class="n">get_refBase</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">dna</span><span class="p">[</span><span class="n">refBase</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">NotAValidRefBase</span><span class="p">()</span>
        <span class="c1"># If there are no SNPS, fill *self.cD* with data from reference.</span>
        <span class="k">if</span> <span class="n">iL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">update_cD</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">snpL</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iL</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">snpL</span><span class="p">)):</span>
            <span class="c1"># Else, only fill *self.cD* where the individual has no SNP.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nV</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">iL</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">update_cD</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="c1"># Now traverse the SNPs.</span>
            <span class="k">for</span> <span class="n">sI</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iL</span><span class="p">)):</span>
                <span class="c1"># Check if the reference bases match.</span>
                <span class="n">vcfRefBase</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">sI</span><span class="p">]</span><span class="o">.</span><span class="n">get_ref_base</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="c1"># Thu Jun 9 09:26:55 CEST 2016: Just use first base if</span>
                <span class="c1"># there are more.</span>
                <span class="n">indel</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vcfRefBase</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Indel at chrom </span><span class="si">%s</span><span class="s2"> pos </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
                    <span class="n">indel</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">vcfRefBase</span> <span class="o">=</span> <span class="n">vcfRefBase</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">dna</span><span class="p">[</span><span class="n">vcfRefBase</span><span class="p">]</span> <span class="o">!=</span> <span class="n">r</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error at NucBase:&quot;</span><span class="p">)</span>
                    <span class="n">snpL</span><span class="p">[</span><span class="n">sI</span><span class="p">]</span><span class="o">.</span><span class="n">print_info</span><span class="p">()</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The reference base at position&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span>
                          <span class="s2">&quot;on chromosome&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                          <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="n">refBase</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The reference base of the VCF file is&quot;</span><span class="p">,</span>
                          <span class="n">vcfRefBase</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s2">&quot;Reference bases do not match.&quot;</span><span class="p">)</span>
                <span class="n">altBases</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">sI</span><span class="p">]</span><span class="o">.</span><span class="n">get_alt_base_list</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">altBase</span> <span class="ow">in</span> <span class="n">altBases</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">altBase</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">indel</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Indel at chrom </span><span class="si">%s</span><span class="s2"> pos </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
                <span class="n">spData</span> <span class="o">=</span> <span class="n">snpL</span><span class="p">[</span><span class="n">sI</span><span class="p">]</span><span class="o">.</span><span class="n">get_speciesData</span><span class="p">()</span>
                <span class="n">vI</span> <span class="o">=</span> <span class="n">iL</span><span class="p">[</span><span class="n">sI</span><span class="p">]</span>
                <span class="c1"># Loop over individuals.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">spData</span><span class="p">)):</span>
                    <span class="c1"># Loop over chromatides (e.g. diploid).</span>
                    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">spData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="k">elif</span> <span class="n">indel</span> <span class="ow">or</span> <span class="n">spData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">bI</span> <span class="o">=</span> <span class="n">r</span>
                            <span class="n">update_cD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">vI</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">bI</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">bI</span> <span class="o">=</span> <span class="n">dna</span><span class="p">[</span><span class="n">altBases</span><span class="p">[</span><span class="n">spData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">d</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Use SNP of </span><span class="si">%s</span><span class="s2">, population </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">indM</span><span class="p">[</span><span class="n">vI</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">vI</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                            <span class="n">update_cD</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assM</span><span class="p">[</span><span class="n">vI</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">bI</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s2">&quot;SNP information is not correct.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_Ln</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return string with a line in counts format. Positional information</span>
<span class="sd">        is written 1-based.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stringL</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">chrom</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">:</span>
            <span class="n">stringL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">)))</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stringL</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_HLn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string containing the headerline in counts format.&quot;&quot;&quot;</span>
        <span class="n">strL</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;CHROM&quot;</span><span class="p">,</span> <span class="s2">&quot;POS&quot;</span><span class="p">]</span>
        <span class="n">strL</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nL</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strL</span><span class="p">)</span>

<div class="viewcode-block" id="CFWriter.set_force"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.set_force">[docs]</a>    <span class="k">def</span> <span class="nf">set_force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets *self.__force* to *val*.</span>

<span class="sd">        :param Boolean val:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__force</span> <span class="o">=</span> <span class="n">val</span></div>

<div class="viewcode-block" id="CFWriter.set_seq"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.set_seq">[docs]</a>    <span class="k">def</span> <span class="nf">set_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="s2">&quot;Set the reference sequence.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">sb</span><span class="o">.</span><span class="n">Seq</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">SequenceDataError</span><span class="p">(</span><span class="s2">&quot;`seq` is not a Seq object.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refSeq</span> <span class="o">=</span> <span class="n">seq</span></div>

<div class="viewcode-block" id="CFWriter.set_ploidy"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.set_ploidy">[docs]</a>    <span class="k">def</span> <span class="nf">set_ploidy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ploidy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the ploidy.</span>

<span class="sd">        In VCF files, usually the bases of all copies of the same</span>
<span class="sd">        chromosomes are given and separated by &#39;/&#39; or &#39;|&#39;.  If the</span>
<span class="sd">        species is not diploid, this ploidy has to be set manually</span>
<span class="sd">        with this function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">=</span> <span class="n">ploidy</span></div>

<div class="viewcode-block" id="CFWriter.set_offset"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.set_offset">[docs]</a>    <span class="k">def</span> <span class="nf">set_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the offset of the sequence.</span>

<span class="sd">        :param int offset: Value that can be set, if the reference</span>
<span class="sd">                           sequence does not start at the 1-based</span>
<span class="sd">                           position 1 but at the 1-based position</span>
<span class="sd">                           *offset*.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Offset in CFWriter: </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span></div>

<div class="viewcode-block" id="CFWriter.write_Ln"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.write_Ln">[docs]</a>    <span class="k">def</span> <span class="nf">write_Ln</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write a line in counts format to *self.outFN*.&quot;&quot;&quot;</span>
        <span class="c1"># Increment counter and write line.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseCounter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_Ln</span><span class="p">(),</span> <span class="n">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outFO</span><span class="p">)</span></div>

<div class="viewcode-block" id="CFWriter.write_HLn"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.write_HLn">[docs]</a>    <span class="k">def</span> <span class="nf">write_HLn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the counts format header line to *self.outFN*.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_HLn</span><span class="p">(),</span> <span class="n">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outFO</span><span class="p">)</span></div>

<div class="viewcode-block" id="CFWriter.write_Rn"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.write_Rn">[docs]</a>    <span class="k">def</span> <span class="nf">write_Rn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write lines in counts format to *self.outFN*.</span>

<span class="sd">        :param Region rg: :class:`Region &lt;libPoMo.seqbase.Region&gt;`</span>
<span class="sd">                          object that determines the region that is</span>
<span class="sd">                          covered.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_offset</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="n">snpsG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__snp</span><span class="p">(</span><span class="n">rg</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="p">(</span><span class="n">nI</span><span class="p">,</span> <span class="n">nSNP</span><span class="p">)</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">snpsG</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="n">nI</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">nSNP</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">rPos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rg</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">rg</span><span class="o">.</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">snpL</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">iL</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">nI</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">nSNP</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nSNP</span><span class="o">.</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">rPos</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">snpL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">iL</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                        <span class="n">snpL</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">iL</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">snpL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nSNP</span><span class="p">)</span>
                    <span class="n">iL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nI</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="p">(</span><span class="n">nI</span><span class="p">,</span> <span class="n">nSNP</span><span class="p">)</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">snpsG</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                        <span class="n">nI</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">nSNP</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chrom</span> <span class="o">=</span> <span class="n">rg</span><span class="o">.</span><span class="n">chrom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">rPos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__fill_cD</span><span class="p">(</span><span class="n">iL</span><span class="p">,</span> <span class="n">snpL</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">NoSynBase</span><span class="p">:</span>
                <span class="c1"># Do nothing if base is not 4-fold degenerate.</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Ignoring synonymous base.&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">sb</span><span class="o">.</span><span class="n">NotAValidRefBase</span><span class="p">:</span>
                <span class="c1"># Do nothing if reference base is not valid.</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Ignoring invalid reference base.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write_Ln</span><span class="p">()</span></div>

<div class="viewcode-block" id="CFWriter.add_base_to_sequence"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.add_base_to_sequence">[docs]</a>    <span class="k">def</span> <span class="nf">add_base_to_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pop_id</span><span class="p">,</span> <span class="n">base_char</span><span class="p">,</span>
                             <span class="n">double_fixed_sites</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds the base given in `base_char` to the counts of population with</span>
<span class="sd">        id `pop_id`.  If `double_fixed_sited` is true, fixed sites are</span>
<span class="sd">        counted twice.  This makes sense, when heterozygotes are</span>
<span class="sd">        encoded with IUPAC codes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">base_char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">base_id</span> <span class="o">=</span> <span class="n">dna</span><span class="p">[</span><span class="n">base</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sb</span><span class="o">.</span><span class="n">NotAValidRefBase</span><span class="p">()</span>
        <span class="c1"># Honor IUPAC code.</span>
        <span class="k">if</span> <span class="n">base_id</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="n">base_id</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">double_fixed_sites</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="n">base_id</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
            <span class="c1"># C or G.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="c1"># C or T.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="c1"># G or C.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
            <span class="c1"># A or T.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;k&#39;</span><span class="p">:</span>
            <span class="c1"># G or T.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="c1"># A or C.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
            <span class="c1"># C or G or T.</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Ambivalent base with 3 possibilities.&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;This base will be ignored upon running PoMo.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span>
            <span class="c1"># A or G or T.</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Ambivalent base with 3 possibilities.&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;This base will be ignored upon running PoMo.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="c1"># A or C or T.</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Ambivalent base with 3 possibilities.&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;This base will be ignored upon running PoMo.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
            <span class="c1"># A or C or G.</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Ambivalent base with 3 possibilities.&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;This base will be ignored upon running PoMo.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cD</span><span class="p">[</span><span class="n">pop_id</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="c1"># Any base.</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="ow">or</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
            <span class="c1"># Gap.</span>
            <span class="k">pass</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;IUPAC code handled.  This might bias the analysis.&quot;</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="CFWriter.close"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.CFWriter.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write file type specifier, number of populations and number of</span>
<span class="sd">           sites to the beginning of the output file.  Close</span>
<span class="sd">           fileobjects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcfTfL</span><span class="p">:</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outFO</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Insert the first line.  TODO: The whole file needs to be</span>
        <span class="c1"># copied, maybe there is a better method?</span>
        <span class="n">temp_fn</span> <span class="o">=</span> <span class="s2">&quot;temp_&quot;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outFN</span><span class="p">)</span>
        <span class="n">temp_fd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outFN</span><span class="p">)</span>
        <span class="n">temp_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">temp_fd</span><span class="p">,</span> <span class="n">temp_fn</span><span class="p">)</span>
        <span class="n">fo</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">gz_open</span><span class="p">(</span><span class="n">temp_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;COUNTSFILE</span><span class="se">\t</span><span class="s2">NPOP &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nPop</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">NSITES &quot;</span><span class="p">,</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">baseCounter</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">fo</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">sb</span><span class="o">.</span><span class="n">gz_open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outFN</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ln</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">fo</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">fo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">temp_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outFN</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="write_cf_from_MFaStream"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.write_cf_from_MFaStream">[docs]</a><span class="k">def</span> <span class="nf">write_cf_from_MFaStream</span><span class="p">(</span><span class="n">refMFaStr</span><span class="p">,</span> <span class="n">cfWr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write counts file using the given MFaStream and CFWriter.</span>

<span class="sd">    Write the counts format file using the first sequences of all</span>
<span class="sd">    alignments in the MFaStream.  The sequences are automatically</span>
<span class="sd">    reversed and complemented if this is needed (indicated in the</span>
<span class="sd">    header line).  This is very useful if you e.g. want to compare the</span>
<span class="sd">    VCF files to a CCDC alignment.</span>

<span class="sd">    :param FMaStream refMFaStr: The reference :class:`MFaStream</span>
<span class="sd">      &lt;libPoMo.fasta.MFaStream&gt;`.</span>
<span class="sd">    :param CFWriter cfWf: The :class:`CFWriter` object that contains</span>
<span class="sd">      the VCF files.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">refMFaStr</span><span class="o">.</span><span class="n">orient</span><span class="p">(</span><span class="n">firstOnly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">rg</span> <span class="o">=</span> <span class="n">refMFaStr</span><span class="o">.</span><span class="n">seqL</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_region</span><span class="p">()</span>
        <span class="n">cfWr</span><span class="o">.</span><span class="n">set_seq</span><span class="p">(</span><span class="n">refMFaStr</span><span class="o">.</span><span class="n">seqL</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cfWr</span><span class="o">.</span><span class="n">write_Rn</span><span class="p">(</span><span class="n">rg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">refMFaStr</span><span class="o">.</span><span class="n">read_next_align</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span></div>


<div class="viewcode-block" id="write_cf_from_gp_stream"><a class="viewcode-back" href="../../cf.html#libPoMo.cf.write_cf_from_gp_stream">[docs]</a><span class="k">def</span> <span class="nf">write_cf_from_gp_stream</span><span class="p">(</span><span class="n">gp_stream</span><span class="p">,</span> <span class="n">cfWr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write counts file using a given GP stream with reference and CFWriter.</span>

<span class="sd">    Write the counts format file using all genes in the GP stream.</span>
<span class="sd">    The sequences are automatically reversed and complemented if this</span>
<span class="sd">    is needed.</span>

<span class="sd">    :param GPStream gp_stream: The GP stream and reference :class:`GPStream</span>
<span class="sd">      &lt;libPoMo.gp.GPStream&gt;`.</span>
<span class="sd">    :param CFWriter cfWf: The :class:`CFWriter` object that contains</span>
<span class="sd">      the VCF files.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Tomas Vigor, the person who created the GP files wrote: The</span>
    <span class="c1"># first codon of the first exon does not need to be the start</span>
    <span class="c1"># codon, because ends may be cut off. BUT, the first exon</span>
    <span class="c1"># should always start on a boundary of a codon (i.e., all</span>
    <span class="c1"># should be in frame, or in other words, parts that were cut</span>
    <span class="c1"># off were always multiple-of-3 length). The gene names in</span>
    <span class="c1"># these genes would usually have &quot;inc&quot; in their names (as</span>
    <span class="c1"># &quot;incomplete&quot;),</span>
    <span class="n">nr_rc_genes_correct_start_codon</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nr_genes_correct_start_codon</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nr_genes_inc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nr_genes_total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">correct_frame_shift_flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Count sequences that have correct start codon or check if</span>
        <span class="c1"># they have &quot;inc&quot; in their name.</span>
        <span class="k">if</span> <span class="n">gp_stream</span><span class="o">.</span><span class="n">gene</span><span class="o">.</span><span class="n">is_rc</span> <span class="ow">and</span>\
           <span class="p">(</span><span class="n">gp_stream</span><span class="o">.</span><span class="n">seqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;cat&quot;</span><span class="p">):</span>
            <span class="n">nr_rc_genes_correct_start_codon</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">correct_frame_shift_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">gp_stream</span><span class="o">.</span><span class="n">gene</span><span class="o">.</span><span class="n">is_rc</span><span class="p">)</span> <span class="ow">and</span>\
             <span class="p">(</span><span class="n">gp_stream</span><span class="o">.</span><span class="n">seqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;atg&quot;</span><span class="p">):</span>
            <span class="n">nr_genes_correct_start_codon</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">correct_frame_shift_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">correct_frame_shift_flag</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span>\
           <span class="n">gp_stream</span><span class="o">.</span><span class="n">gene</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;inc&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">nr_genes_inc</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">correct_frame_shift_flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">nr_genes_total</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Orient sequences.</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">gp_stream</span><span class="o">.</span><span class="n">seqs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">get_rc</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">rev_comp</span><span class="p">()</span>
        <span class="c1"># Write to CF.</span>
        <span class="k">if</span> <span class="n">correct_frame_shift_flag</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gp_stream</span><span class="o">.</span><span class="n">gene</span><span class="o">.</span><span class="n">nr_exons</span><span class="p">):</span>
                <span class="n">rg</span> <span class="o">=</span> <span class="n">gp_stream</span><span class="o">.</span><span class="n">seqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_region</span><span class="p">()</span>
                <span class="n">cfWr</span><span class="o">.</span><span class="n">set_seq</span><span class="p">(</span><span class="n">gp_stream</span><span class="o">.</span><span class="n">seqs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">cfWr</span><span class="o">.</span><span class="n">write_Rn</span><span class="p">(</span><span class="n">rg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Gene has no start codon and is not flagged incomplete:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">gp_stream</span><span class="o">.</span><span class="n">gene</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">gp_stream</span><span class="o">.</span><span class="n">read_next_gene</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;+ genes with correct start codon ATG:&quot;</span><span class="p">,</span>
          <span class="n">nr_rc_genes_correct_start_codon</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;- genes with correct start codon ATG:&quot;</span><span class="p">,</span>
          <span class="n">nr_genes_correct_start_codon</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Incomplete genes without start codon:&quot;</span><span class="p">,</span>
          <span class="n">nr_genes_inc</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of processed genes:&quot;</span><span class="p">,</span> <span class="n">nr_genes_total</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">PoMo 1.1.0 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Dominik Schrempf.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.5.
    </div>
  </body>
</html>