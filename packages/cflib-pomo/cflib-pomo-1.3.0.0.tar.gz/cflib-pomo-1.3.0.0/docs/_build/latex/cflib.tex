% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{Counts File Library Documentation}
\date{Jul 26, 2016}
\release{1.1.0}
\author{Dominik Schrempf}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


This library provides functions and classes to handle file conversion
between standard formats (e.g., fasta or VCF files) to counts files
that are used by \href{http://www.cibiv.at/software/iqtree/}{IQ-TREE}
with \href{http://www.cibiv.at/software/iqtree/doc/Polymorphism-Aware-Models/}{PoMo},
and implementation of a polymorphism aware phylogenetic model.
\begin{description}
\item[{Created by:}] \leavevmode\begin{itemize}
\item {} 
Dominik Schrempf

\end{itemize}

\end{description}

For a reference, please see and cite: Schrempf, D., Minh, B. Q., De
Maio, N., von Haeseler, A., \& Kosiol, C. (2016). Reversible
Polmorphism-Aware Phylotenetic Models and their Application to Tree
Inference. Journal of Theoretical Biology, in press.

Feel free to post any suggestions, doubts and bugs.


\chapter{cflib}
\label{index:welcome-to-the-documentation-of-cflib}\label{index:cflib}
\sphinxtitleref{cflib} contains several modules that ease the handling and
preparation of data files in variant call format (vcf), fasta format
and counts format (cf).
\begin{description}
\item[{The \emph{libPoMo} package is split into the following modules:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[main::doc]{\sphinxcrossref{\DUrole{doc}{main}}}}: Contains functions that are used by PoMo.

\item {} 
{\hyperref[seqbase::doc]{\sphinxcrossref{\DUrole{doc}{seqbase}}}}: Provides basic functions and classes
needed to work with sequence data.

\item {} 
{\hyperref[fasta::doc]{\sphinxcrossref{\DUrole{doc}{fasta}}}}: Provides functions to read, write and access
fasta files.

\item {} 
{\hyperref[vcf::doc]{\sphinxcrossref{\DUrole{doc}{vcf}}}}: Provides functions to read, write and access vcf
files.

\item {} 
{\hyperref[cf::doc]{\sphinxcrossref{\DUrole{doc}{cf}}}}: Provides functions to read, write and access files
that are in counts format.

\end{itemize}

\end{description}


\chapter{Contents}
\label{index:contents}\phantomsection\label{main:module-libPoMo.main}\index{libPoMo.main (module)}

\section{libPoMo.main}
\label{main:libpomo-main}\label{main::doc}
This library contains functions that are used by PoMo.
\index{a() (in module libPoMo.main)}

\begin{fulllineitems}
\phantomsection\label{main:libPoMo.main.a}\pysiglinewithargsret{\sphinxcode{libPoMo.main.}\sphinxbfcode{a}}{\emph{n}}{}
Calculate the Watterson's Theta coefficient.

\end{fulllineitems}

\index{binom() (in module libPoMo.main)}

\begin{fulllineitems}
\phantomsection\label{main:libPoMo.main.binom}\pysiglinewithargsret{\sphinxcode{libPoMo.main.}\sphinxbfcode{binom}}{\emph{s}, \emph{p}, \emph{n}}{}
Binomial Distribution

Calculate the binomial sampling probability (not very efficient,
but not much effieciency is needed with small samples).

\end{fulllineitems}

\index{dsRatio() (in module libPoMo.main)}

\begin{fulllineitems}
\phantomsection\label{main:libPoMo.main.dsRatio}\pysiglinewithargsret{\sphinxcode{libPoMo.main.}\sphinxbfcode{dsRatio}}{\emph{dsR}}{}
Downsampling ratio \textbf{type} for argparse.

\end{fulllineitems}

\index{get\_data\_from\_cf\_line() (in module libPoMo.main)}

\begin{fulllineitems}
\phantomsection\label{main:libPoMo.main.get_data_from_cf_line}\pysiglinewithargsret{\sphinxcode{libPoMo.main.}\sphinxbfcode{get\_data\_from\_cf\_line}}{\emph{cfStr}}{}
Read in the data of a single counts format line.

The return type is a list with the number of samples and a two
dimensional array of the form data{[}species{]}{[}nucleotide{]}, where
species is the index of the species and nucleotide is the index of
the nucleotide (0,1,2 or 3 for a,c,g and t, respectively).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{CFStream}} (\emph{\texttt{cfStr}}) -- The CFStream pointing to the line to be
read in.

\item[{Return type}] \leavevmode
({[}int{]} n\_samples, {[}{[}int{]}{]} data)

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_species\_from\_cf\_headerline() (in module libPoMo.main)}

\begin{fulllineitems}
\phantomsection\label{main:libPoMo.main.get_species_from_cf_headerline}\pysiglinewithargsret{\sphinxcode{libPoMo.main.}\sphinxbfcode{get\_species\_from\_cf\_headerline}}{\emph{line}}{}
Get the number of species and the names fom a counts format header line.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{line}} (\emph{\texttt{str}}) -- The header line.

\item[{Return type}] \leavevmode
(int n\_species, {[}str{]} sp\_names)

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_number() (in module libPoMo.main)}

\begin{fulllineitems}
\phantomsection\label{main:libPoMo.main.is_number}\pysiglinewithargsret{\sphinxcode{libPoMo.main.}\sphinxbfcode{is\_number}}{\emph{s}}{}
Determine if value is an integer.

\end{fulllineitems}

\index{mutModel() (in module libPoMo.main)}

\begin{fulllineitems}
\phantomsection\label{main:libPoMo.main.mutModel}\pysiglinewithargsret{\sphinxcode{libPoMo.main.}\sphinxbfcode{mutModel}}{\emph{mm}}{}
Mutation model \textbf{type} for argparse.

\end{fulllineitems}

\index{probability\_matrix() (in module libPoMo.main)}

\begin{fulllineitems}
\phantomsection\label{main:libPoMo.main.probability_matrix}\pysiglinewithargsret{\sphinxcode{libPoMo.main.}\sphinxbfcode{probability\_matrix}}{\emph{n}}{}
Create probability matrices for the HyPhy batch file.

\end{fulllineitems}

\index{read\_data\_write\_HyPhy\_input() (in module libPoMo.main)}

\begin{fulllineitems}
\phantomsection\label{main:libPoMo.main.read_data_write_HyPhy_input}\pysiglinewithargsret{\sphinxcode{libPoMo.main.}\sphinxbfcode{read\_data\_write\_HyPhy\_input}}{\emph{fn}, \emph{N}, \emph{thresh}, \emph{path\_bf}, \emph{muts}, \emph{mutgamma}, \emph{sels}, \emph{selgamma}, \emph{PoModatafile}, \emph{PoModatafile\_cons}, \emph{theta=None}, \emph{vb=None}}{}
Read the count data and write the HyPhy input file.

The provided filename has to point to a data file in counts format
(cf. {\hyperref[cf::doc]{\sphinxcrossref{\DUrole{doc}{cf}}}}).  The data will be downsampled if necessary
and the HyPhy batch and input files will be written.  The number
of species, the species names, the number of species samples and
the theta value (usr\_def) will be returned in a tuple.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{fn}} (\emph{\texttt{str}}) -- Counts format file name.

\item {} 
\textbf{\texttt{N}} (\emph{\texttt{int}}) -- Virtual population size.

\item {} 
\textbf{\texttt{thresh}} (\emph{\texttt{float}}) -- Trheshold of data discard for downsampling.

\item {} 
\textbf{\texttt{path\_bf}} (\emph{\texttt{str}}) -- Path to the HyPhy batch files

\item {} 
\textbf{\texttt{muts}} (\emph{\texttt{str}}) -- Mutation model ({\hyperref[main:libPoMo.main.mutModel]{\sphinxcrossref{\sphinxcode{mutModel()}}}}).

\item {} 
\textbf{\texttt{mutgamma}} (\emph{\texttt{str}}) -- Gamma of the mutation model ({\hyperref[main:libPoMo.main.setGM]{\sphinxcrossref{\sphinxcode{setGM()}}}}).

\item {} 
\textbf{\texttt{sels}} (\emph{\texttt{str}}) -- Selection model ({\hyperref[main:libPoMo.main.selModel]{\sphinxcrossref{\sphinxcode{selModel()}}}}).

\item {} 
\textbf{\texttt{selgamma}} (\emph{\texttt{str}}) -- Gamma of selection model ({\hyperref[main:libPoMo.main.setGS]{\sphinxcrossref{\sphinxcode{setGS()}}}}).

\item {} 
\textbf{\texttt{PoModatafile}} (\emph{\texttt{str}}) -- Path to HyPhy input file.

\item {} 
\textbf{\texttt{PoModatafile\_cons}} (\emph{\texttt{str}}) -- Path to HyPhy input file.

\item {} 
\textbf{\texttt{vb}} (\emph{\texttt{Boolean}}) -- Verbosity.

\end{itemize}

\item[{Return type}] \leavevmode
(int n\_species, {[}str{]} sp\_names, {[}str{]} sp\_samples, Boolean all\_one,
float usr\_def)

\end{description}\end{quote}

\end{fulllineitems}

\index{selModel() (in module libPoMo.main)}

\begin{fulllineitems}
\phantomsection\label{main:libPoMo.main.selModel}\pysiglinewithargsret{\sphinxcode{libPoMo.main.}\sphinxbfcode{selModel}}{\emph{sm}}{}
Selection model \textbf{type} for argparse.

\end{fulllineitems}

\index{setGM() (in module libPoMo.main)}

\begin{fulllineitems}
\phantomsection\label{main:libPoMo.main.setGM}\pysiglinewithargsret{\sphinxcode{libPoMo.main.}\sphinxbfcode{setGM}}{\emph{gm}}{}
Set variable mutation rate, if \sphinxtitleref{gm} is given.

\end{fulllineitems}

\index{setGS() (in module libPoMo.main)}

\begin{fulllineitems}
\phantomsection\label{main:libPoMo.main.setGS}\pysiglinewithargsret{\sphinxcode{libPoMo.main.}\sphinxbfcode{setGS}}{\emph{gs}}{}
Set fixation bias, if \sphinxtitleref{gs} is given.

\end{fulllineitems}

\index{timeStr() (in module libPoMo.main)}

\begin{fulllineitems}
\phantomsection\label{main:libPoMo.main.timeStr}\pysiglinewithargsret{\sphinxcode{libPoMo.main.}\sphinxbfcode{timeStr}}{}{}
Time in human readable format.

\end{fulllineitems}

\phantomsection\label{seqbase:module-libPoMo.seqbase}\index{libPoMo.seqbase (module)}

\section{libPoMo.seqbase}
\label{seqbase::doc}\label{seqbase:libpomo-seqbase}
This module provides basic functions and classes needed to work with
sequence data.


\subsection{Objects}
\label{seqbase:objects}\begin{description}
\item[{Classes:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\sphinxcode{Seq}}}}, stores a single sequence

\item {} 
{\hyperref[seqbase:libPoMo.seqbase.Region]{\sphinxcrossref{\sphinxcode{Region}}}}, region in a genome

\end{itemize}

\item[{Exception Classes:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[seqbase:libPoMo.seqbase.SequenceDataError]{\sphinxcrossref{\sphinxcode{SequenceDataError}}}}

\item {} 
{\hyperref[seqbase:libPoMo.seqbase.NotAValidRefBase]{\sphinxcrossref{\sphinxcode{NotAValidRefBase}}}}

\end{itemize}

\item[{Functions:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[seqbase:libPoMo.seqbase.stripFName]{\sphinxcrossref{\sphinxcode{stripFName()}}}}, strip filename off its ending

\end{itemize}

\end{description}


\bigskip\hrule{}\bigskip

\index{NotAValidRefBase}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.NotAValidRefBase}\pysigline{\sphinxstrong{exception }\sphinxcode{libPoMo.seqbase.}\sphinxbfcode{NotAValidRefBase}}
Reference base is not valid.

\end{fulllineitems}

\index{Region (class in libPoMo.seqbase)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Region}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{libPoMo.seqbase.}\sphinxbfcode{Region}}{\emph{chrom}, \emph{start}, \emph{end}, \emph{name=None}, \emph{orientation='+'}}{}
Region in a genome.

The start and end points need to be given 1-based and are
converted to 0-based positions that are used internally to save
all positional data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{chrom}} (\emph{\texttt{str}}) -- Chromosome name.

\item {} 
\textbf{\texttt{start}} (\emph{\texttt{int}}) -- 1-based start position.

\item {} 
\textbf{\texttt{end}} (\emph{\texttt{int}}) -- 1-based end position.

\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Optional, region name.

\end{itemize}

\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{chrom}} (\emph{\texttt{str}}) -- Chromosome name.

\item {} 
\textbf{\texttt{start}} (\emph{\texttt{int}}) -- 0-based start position.

\item {} 
\textbf{\texttt{end}} (\emph{\texttt{int}}) -- 0-base end position.

\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Region name.

\end{itemize}

\end{description}\end{quote}
\index{print\_info() (libPoMo.seqbase.Region method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Region.print_info}\pysiglinewithargsret{\sphinxbfcode{print\_info}}{}{}
Print information about the region.

\end{fulllineitems}


\end{fulllineitems}

\index{Seq (class in libPoMo.seqbase)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq}\pysigline{\sphinxstrong{class }\sphinxcode{libPoMo.seqbase.}\sphinxbfcode{Seq}}
A class that stores sequence data.
.. \_seqbase-seq:
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Name of the sequence (e.g. species or individual
name).

\item {} 
\textbf{\texttt{descr}} (\emph{\texttt{str}}) -- Description of the sequence.

\item {} 
\textbf{\texttt{data}} (\emph{\texttt{str}}) -- String with sequence data.

\item {} 
\textbf{\texttt{dataLen}} (\emph{\texttt{int}}) -- Number of saved bases.

\item {} 
\textbf{\texttt{rc}} (\emph{\texttt{Boolean}}) -- True if \emph{self.data} stores the
reverse-complement of the real sequence.

\end{itemize}

\end{description}\end{quote}
\index{get\_base() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.get_base}\pysiglinewithargsret{\sphinxbfcode{get\_base}}{\emph{pos}}{}
Returns base at 1-based position \sphinxtitleref{pos}.

\end{fulllineitems}

\index{get\_exon\_nr() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.get_exon_nr}\pysiglinewithargsret{\sphinxbfcode{get\_exon\_nr}}{}{}
Try to find the current and the total exon number of the sequence.

Extract the exon number and the total number of exons, if the
name of the sequence is of the form (cf. \href{http://genome.ucsc.edu/goldenPath/help/hgTablesHelp.html\#FASTA}{UCSC Table Browser}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{n}{CCDS3}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{n}{\PYGZus{}hg18\PYGZus{}2\PYGZus{}19}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
(int nEx, int nExTot)

\item[{Raises}] \leavevmode
{\hyperref[seqbase:libPoMo.seqbase.SequenceDataError]{\sphinxcrossref{\sphinxcode{SequenceDataError}}}}, if the format of the
sequence name is invalid.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_in\_frame() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.get_in_frame}\pysiglinewithargsret{\sphinxbfcode{get\_in\_frame}}{}{}
Try to find the \sphinxtitleref{inFrame} of the gene.

\sphinxtitleref{inFrame}: the frame number of the first nucleotide in the
exon. Frame numbers can be 0, 1, or 2 depending on what
position that nucleotide takes in the codon which contains it.
This function gets the \sphinxtitleref{inFrame}, if the description of the
sequence is of the form (cf. \href{http://genome.ucsc.edu/goldenPath/help/hgTablesHelp.html\#FASTA}{UCSC Table Browser}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{918} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{n}{chr1}\PYG{p}{:}\PYG{l+m+mi}{58954}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{59871}\PYG{o}{+}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\item[{Raises}] \leavevmode
{\hyperref[seqbase:libPoMo.seqbase.SequenceDataError]{\sphinxcrossref{\sphinxcode{SequenceDataError}}}}, if format of description
is invalid.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_out\_frame() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.get_out_frame}\pysiglinewithargsret{\sphinxbfcode{get\_out\_frame}}{}{}
Try to find the \sphinxtitleref{outFrame} of the gene.

\sphinxtitleref{outFrame}: the frame number of the last nucleotide in the
exon. Frame numbers can be 0, 1, or 2 depending on what
position that nucleotide takes in the codon which contains it.
This function gets the \sphinxtitleref{outFrame}, if the description of the
sequence is of the form (cf. \href{http://genome.ucsc.edu/goldenPath/help/hgTablesHelp.html\#FASTA}{UCSC Table Browser}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{918} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{n}{chr1}\PYG{p}{:}\PYG{l+m+mi}{58954}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{59871}\PYG{o}{+}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\item[{Raises}] \leavevmode
{\hyperref[seqbase:libPoMo.seqbase.SequenceDataError]{\sphinxcrossref{\sphinxcode{SequenceDataError}}}}, if format of description
is invalid.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_rc() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.get_rc}\pysiglinewithargsret{\sphinxbfcode{get\_rc}}{}{}
Return True if the sequence is reversed and complemented.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
Boolean

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_region() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.get_region}\pysiglinewithargsret{\sphinxbfcode{get\_region}}{}{}
Try to find the {\hyperref[seqbase:libPoMo.seqbase.Region]{\sphinxcrossref{\sphinxcode{Region}}}} that the sequence spans.

The sequence might not physically start at position 1 but at
some arbitrary value that is indicated in the sequence
description.  This function gets this physical
{\hyperref[seqbase:libPoMo.seqbase.Region]{\sphinxcrossref{\sphinxcode{Region}}}}, if the description of the sequence is of the
form (cf. \href{http://genome.ucsc.edu/goldenPath/help/hgTablesHelp.html\#FASTA}{UCSC Table Browser}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{918} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{n}{chr1}\PYG{p}{:}\PYG{l+m+mi}{58954}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{59871}\PYG{o}{+}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
{\hyperref[seqbase:libPoMo.seqbase.SequenceDataError]{\sphinxcrossref{\sphinxcode{SequenceDataError}}}}, if format of description
is invalid.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_region\_no\_description() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.get_region_no_description}\pysiglinewithargsret{\sphinxbfcode{get\_region\_no\_description}}{\emph{offset=0}}{}
Get the region of the sequence.

If no regional information is available in the sequence
description (cf. {\hyperref[seqbase:libPoMo.seqbase.Seq.get_region]{\sphinxcrossref{\sphinxcode{get\_region()}}}}), the position of the
first base in the reference genome can be given
manually. E.g., if the first base of the sequence does not
correspond to the first but to the 11th base of the reference
sequence, the offset should be 10.

The name of the chromosome will be set to the name of the
sequence.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{offset}} (\emph{\texttt{int}}) -- Optional, offset of the sequence.

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_synonymous() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.is_synonymous}\pysiglinewithargsret{\sphinxbfcode{is\_synonymous}}{\emph{pos}}{}
Return True if the base at \sphinxtitleref{pos} is 4-fold degenerate.

This function checks if the base at \sphinxtitleref{pos} is a synonymous one.
The description of the sequence has to be of the form
(cf. \href{http://genome.ucsc.edu/goldenPath/help/hgTablesHelp.html\#FASTA}{UCSC Table Browser}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{918} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{n}{chr1}\PYG{p}{:}\PYG{l+m+mi}{58954}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{59871}\PYG{o}{+}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{pos}} (\emph{\texttt{int}}) -- Position of the base in the sequence (0 to
self.dataLen).

\item[{Rtype Boolean}] \leavevmode
True if base is 4-fold degenerate.

\item[{Raises}] \leavevmode
{\hyperref[seqbase:libPoMo.seqbase.SequenceDataError]{\sphinxcrossref{\sphinxcode{SequenceDataError}}}}, if format of description
is invalid.

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_data() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.print_data}\pysiglinewithargsret{\sphinxbfcode{print\_data}}{\emph{fo=\textless{}\_io.TextIOWrapper name='\textless{}stdout\textgreater{}' mode='w' encoding='UTF-8'\textgreater{}}}{}
Print the sequence data.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{fo}} (\emph{\texttt{fileObject}}) -- Print to file object fo. Defaults to
stdout.

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_fa\_entry() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.print_fa_entry}\pysiglinewithargsret{\sphinxbfcode{print\_fa\_entry}}{\emph{maxB=None}, \emph{fo=\textless{}\_io.TextIOWrapper name='\textless{}stdout\textgreater{}' mode='w' encoding='UTF-8'\textgreater{}}}{}
Print a fasta file entry with header and sequence data.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{maxB}} (\emph{\texttt{int}}) -- Print a maximum of maxB bases. Default: print
all bases.

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_fa\_header() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.print_fa_header}\pysiglinewithargsret{\sphinxbfcode{print\_fa\_header}}{\emph{fo=\textless{}\_io.TextIOWrapper name='\textless{}stdout\textgreater{}' mode='w' encoding='UTF-8'\textgreater{}}}{}
Print the sequence header line in fasta format.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{fo}} (\emph{\texttt{fileObject}}) -- Print to file object fo. Defaults to
stdout.

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_info() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.print_info}\pysiglinewithargsret{\sphinxbfcode{print\_info}}{\emph{maxB=50}}{}
Print sequence information.

Print sequence name, description, the length of the sequence
and a maximum of \sphinxtitleref{maxB} bases (defaults to 50).

\end{fulllineitems}

\index{purge() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.purge}\pysiglinewithargsret{\sphinxbfcode{purge}}{}{}
Purge data saved in this sequence.

\end{fulllineitems}

\index{rev\_comp() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.rev_comp}\pysiglinewithargsret{\sphinxbfcode{rev\_comp}}{\emph{change\_sequence\_only=False}}{}
Reverses and complements the sequence.

This is rather slow for long sequences.

\end{fulllineitems}

\index{set\_rc() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.set_rc}\pysiglinewithargsret{\sphinxbfcode{set\_rc}}{}{}
Set the \emph{self.rc}.

The instance variable \emph{self.rc} is a Boolean value that is
true if the saved sequence is reversed and complemented.  This
function sets this value according to the last character in
the sequence description.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\emph{ValueError()} if state could not be detected.

\end{description}\end{quote}

\end{fulllineitems}

\index{toggle\_rc() (libPoMo.seqbase.Seq method)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.Seq.toggle_rc}\pysiglinewithargsret{\sphinxbfcode{toggle\_rc}}{}{}
Toggle the state of \emph{self.rc}.

\end{fulllineitems}


\end{fulllineitems}

\index{SequenceDataError}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.SequenceDataError}\pysigline{\sphinxstrong{exception }\sphinxcode{libPoMo.seqbase.}\sphinxbfcode{SequenceDataError}}
General sequence data error exception.

\end{fulllineitems}

\index{gz\_open() (in module libPoMo.seqbase)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.gz_open}\pysiglinewithargsret{\sphinxcode{libPoMo.seqbase.}\sphinxbfcode{gz\_open}}{\emph{fn}, \emph{mode='r'}}{}
Open file with io.open() or gzip.open().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{fn}} (\emph{\texttt{str}}) -- Name of the file to open.

\item {} 
\textbf{\texttt{md}} (\emph{\texttt{char}}) -- Mode `\textbf{r}` \textbar{} `w'.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{stripFName() (in module libPoMo.seqbase)}

\begin{fulllineitems}
\phantomsection\label{seqbase:libPoMo.seqbase.stripFName}\pysiglinewithargsret{\sphinxcode{libPoMo.seqbase.}\sphinxbfcode{stripFName}}{\emph{fn}}{}
Convenience function to strip filename off the ''.xyz'' ending.

\end{fulllineitems}

\phantomsection\label{fasta:module-libPoMo.fasta}\index{libPoMo.fasta (module)}

\section{libPoMo.fasta}
\label{fasta::doc}\label{fasta:libpomo-fasta}
This module provides functions to read, write and access fasta files.


\subsection{Objects}
\label{fasta:objects}\begin{description}
\item[{Classes:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[fasta:libPoMo.fasta.FaStream]{\sphinxcrossref{\sphinxcode{FaStream}}}}, fasta file sequence stream object

\item {} 
{\hyperref[fasta:libPoMo.fasta.MFaStream]{\sphinxcrossref{\sphinxcode{MFaStream}}}}, multiple alignment fasta file sequence stream object

\item {} 
{\hyperref[fasta:libPoMo.fasta.FaSeq]{\sphinxcrossref{\sphinxcode{FaSeq}}}}, fasta file sequence object

\item {} 
{\hyperref[fasta:libPoMo.fasta.MFaStrFilterProps]{\sphinxcrossref{\sphinxcode{MFaStrFilterProps}}}}, define multiple fasta file filter preferences

\end{itemize}

\item[{Exception Classes:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[fasta:libPoMo.fasta.NotAFastaFileError]{\sphinxcrossref{\sphinxcode{NotAFastaFileError}}}}

\end{itemize}

\item[{Functions:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[fasta:libPoMo.fasta.filter_mfa_str]{\sphinxcrossref{\sphinxcode{filter\_mfa\_str()}}}}, filter a given {\hyperref[fasta:libPoMo.fasta.MFaStream]{\sphinxcrossref{\sphinxcode{MFaStream}}}}
according to the filters defined in {\hyperref[fasta:libPoMo.fasta.MFaStrFilterProps]{\sphinxcrossref{\sphinxcode{MFaStrFilterProps}}}}

\item {} 
{\hyperref[fasta:libPoMo.fasta.init_seq]{\sphinxcrossref{\sphinxcode{init\_seq()}}}}, initialize fasta sequence stream from file

\item {} 
{\hyperref[fasta:libPoMo.fasta.open_seq]{\sphinxcrossref{\sphinxcode{open\_seq()}}}}, open fasta file

\item {} 
{\hyperref[fasta:libPoMo.fasta.save_as_vcf]{\sphinxcrossref{\sphinxcode{save\_as\_vcf()}}}}, save a given {\hyperref[fasta:libPoMo.fasta.FaSeq]{\sphinxcrossref{\sphinxcode{FaSeq}}}} in variant call
format (VCF)

\item {} 
{\hyperref[fasta:libPoMo.fasta.read_seq_from_fo]{\sphinxcrossref{\sphinxcode{read\_seq\_from\_fo()}}}}, read a single sequence from file object

\item {} 
{\hyperref[fasta:libPoMo.fasta.read_align_from_fo]{\sphinxcrossref{\sphinxcode{read\_align\_from\_fo()}}}}, read an alignment from file object

\end{itemize}

\end{description}


\bigskip\hrule{}\bigskip

\index{FaSeq (class in libPoMo.fasta)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.FaSeq}\pysigline{\sphinxstrong{class }\sphinxcode{libPoMo.fasta.}\sphinxbfcode{FaSeq}}
Store sequence data retrieved from a fasta file.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Name of the \sphinxtitleref{FaSeq} object.

\item {} 
\textbf{\texttt{seqL}} (\emph{\texttt{{[}Seq{]}}}) -- List of {\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\sphinxcode{Seq}}}}
objects that store the actual sequence data.

\item {} 
\textbf{\texttt{nSepcies}} (\emph{\texttt{int}}) -- Number of saved species / individuals /
chromosomes.

\end{itemize}

\end{description}\end{quote}
\index{get\_distance() (libPoMo.fasta.FaSeq method)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.FaSeq.get_distance}\pysiglinewithargsret{\sphinxbfcode{get\_distance}}{}{}
Number of segregating bases.

\end{fulllineitems}

\index{get\_seq\_base() (libPoMo.fasta.FaSeq method)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.FaSeq.get_seq_base}\pysiglinewithargsret{\sphinxbfcode{get\_seq\_base}}{\emph{seq}, \emph{pos}}{}
Return base at 1-based position \sphinxtitleref{pos} in sequence with name
\sphinxtitleref{seq}.

\end{fulllineitems}

\index{get\_seq\_by\_id() (libPoMo.fasta.FaSeq method)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.FaSeq.get_seq_by_id}\pysiglinewithargsret{\sphinxbfcode{get\_seq\_by\_id}}{\emph{i}}{}
Return sequence number \sphinxtitleref{i} as \sphinxtitleref{Seq} object.

\end{fulllineitems}

\index{get\_seq\_names() (libPoMo.fasta.FaSeq method)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.FaSeq.get_seq_names}\pysiglinewithargsret{\sphinxbfcode{get\_seq\_names}}{}{}
Return a list with sequence names.

\end{fulllineitems}

\index{print\_info() (libPoMo.fasta.FaSeq method)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.FaSeq.print_info}\pysiglinewithargsret{\sphinxbfcode{print\_info}}{\emph{maxB=50}}{}
Print fasta sequence information.

Print fasta sequence identifier, species names, the length of
the sequence and a maximum of \sphinxtitleref{maxB} bases (defaults to 50).

\end{fulllineitems}


\end{fulllineitems}

\index{FaStream (class in libPoMo.fasta)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.FaStream}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{libPoMo.fasta.}\sphinxbfcode{FaStream}}{\emph{name}, \emph{firstSeq}, \emph{nextHL}, \emph{faFileObject}}{}
A class that stores a fasta file sequence stream.

The sequence of one species / individual / chromosome is saved and
functions are provided to read in the next sequence in the file,
if there is any. This saves memory if files are huge and doesn't
increase runtime.

This object is usually initialized with {\hyperref[fasta:libPoMo.fasta.init_seq]{\sphinxcrossref{\sphinxcode{init\_seq()}}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Name of the stream.

\item {} 
\textbf{\texttt{firstSeq}} ({\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\emph{\texttt{Seq}}}}}) -- First sequence ({\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\sphinxcode{Seq}}}} object) to be saved.

\item {} 
\textbf{\texttt{nextHL}} (\emph{\texttt{str}}) -- Next header line.

\item {} 
\textbf{\texttt{faFileObject}} (\emph{\texttt{fo}}) -- File object associated with the stream.

\end{itemize}

\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Stream name.

\item {} 
\textbf{\texttt{seq}} ({\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\emph{\texttt{Seq}}}}}) -- Saved sequence ({\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\sphinxcode{Seq}}}} object)

\item {} 
\textbf{\texttt{nextHeaderLine}} (\emph{\texttt{str}}) -- Next header line.

\item {} 
\textbf{\texttt{fo}} (\emph{\texttt{fo}}) -- File object that points to the start of the data of
the next sequence.

\end{itemize}

\end{description}\end{quote}
\index{close() (libPoMo.fasta.FaStream method)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.FaStream.close}\pysiglinewithargsret{\sphinxbfcode{close}}{}{}
Close the linked file.

\end{fulllineitems}

\index{print\_info() (libPoMo.fasta.FaStream method)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.FaStream.print_info}\pysiglinewithargsret{\sphinxbfcode{print\_info}}{\emph{maxB=50}}{}
Print sequence information.

Print information about this FaStream object, the fasta
sequence stored at the moment the length of the sequence and a
maximum of \sphinxtitleref{maxB} bases (defaults to 50).

\end{fulllineitems}

\index{read\_next\_seq() (libPoMo.fasta.FaStream method)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.FaStream.read_next_seq}\pysiglinewithargsret{\sphinxbfcode{read\_next\_seq}}{}{}
Read next fasta sequence in file.

The return value is the name of the next sequence or None if
no next sequence is found.

\end{fulllineitems}


\end{fulllineitems}

\index{MFaStrFilterProps (class in libPoMo.fasta)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.MFaStrFilterProps}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{libPoMo.fasta.}\sphinxbfcode{MFaStrFilterProps}}{\emph{nSpecies}}{}
Define filter preferences for multiple fasta alignments.

Define the properties of the filter to be applied to an
{\hyperref[fasta:libPoMo.fasta.MFaStream]{\sphinxcrossref{\sphinxcode{MFaStream}}}}.

By default, all filters are applied (all variables are set to
True).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{nSpecies}} (\emph{\texttt{int}}) -- Number of species that are aligned.

\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{check\_all\_aligned}} (\emph{\texttt{Boolean}}) -- Check if all treated species
are available in the alignment (\sphinxtitleref{nSpecies} gives the number
of species, given to the object upon initialization).

\item {} 
\textbf{\texttt{check\_divergence}} (\emph{\texttt{Boolean}}) -- Check if the divergence of the
reference genome (the first sequence in the alignment) is lower
than \sphinxtitleref{maxDiv} (defaults to 10 percent).

\item {} 
\textbf{\texttt{check\_start\_codons}} (\emph{\texttt{Boolean}}) -- Check if all start codons
are conserved.

\item {} 
\textbf{\texttt{check\_stop\_codons}} (\emph{\texttt{Boolean}}) -- Check if all stop codons are
conserved.

\item {} 
\textbf{\texttt{check\_frame\_shifting\_gaps}} (\emph{\texttt{Boolean}}) -- Check, that there
are no frame-shifting gaps.

\item {} 
\textbf{\texttt{check\_for\_long\_gaps}} (\emph{\texttt{Boolean}}) -- Check if no gap is longer
than \sphinxtitleref{maxGapLength} (defaults to 30) bases.

\item {} 
\textbf{\texttt{check\_nonsense\_codon}} (\emph{\texttt{Boolean}}) -- Check if there is no
premature stop codon).

\item {} 
\textbf{\texttt{check\_exon\_length}} (\emph{\texttt{Boolean}}) -- Check that the exon is
longer than \sphinxtitleref{minExonLen} (defaults to 21).

\item {} 
\textbf{\texttt{check\_exon\_numbers}} (\emph{\texttt{Boolean}}) -- Check if exon number match
for all sequences in the alignment.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{MFaStream (class in libPoMo.fasta)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.MFaStream}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{libPoMo.fasta.}\sphinxbfcode{MFaStream}}{\emph{faFileName}, \emph{maxskip=50}, \emph{name=None}}{}
Store a multiple alignment fasta file sequence stream.

The sequences of one gene / alignment are saved for all species /
individuals / chromosomes.  Functions are provided to read in the
next gene / alignment in the file that fulfills the given
criteria, if there is any.  This saves memory if files are huge and
doesn't increase runtime.

Initialization of an {\hyperref[fasta:libPoMo.fasta.MFaStream]{\sphinxcrossref{\sphinxcode{MFaStream}}}} opens the given fasta
file, checks if it is in fasta format and reads the first
alignment.  The end of an alignment is reached when a line only
contains the newline character.  This object can later be used to
parse the whole multiple alignment fasta file.

Alignments can be filtered with {\hyperref[fasta:libPoMo.fasta.filter_mfa_str]{\sphinxcrossref{\sphinxcode{filter\_mfa\_str()}}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{faFileName}} (\emph{\texttt{str}}) -- File name of the multiple alignment fasta file.

\item {} 
\textbf{\texttt{maxskip}} (\emph{\texttt{int}}) -- Only look \emph{maxskip} lines for the start of a
sequence (defaults to 50).

\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Set the name of the stream to \emph{name}, otherwise
set it to the stripped filename.

\end{itemize}

\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Stream name.

\item {} 
\textbf{\texttt{seqL}} (\emph{\texttt{{[}Seq{]}}}) -- Saved sequences ({\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\sphinxcode{Seq}}}} objects) in a list.

\item {} 
\textbf{\texttt{nSpecies}} (\emph{\texttt{int}}) -- Number of saved sequences / species in the alignment.

\item {} 
\textbf{\texttt{nextHeaderLine}} (\emph{\texttt{str}}) -- Next header line.

\item {} 
\textbf{\texttt{fo}} (\emph{\texttt{fo}}) -- File object that points to the start of the data of
the next sequence.

\end{itemize}

\end{description}\end{quote}

Please close the associated file object with
{\hyperref[fasta:libPoMo.fasta.FaStream.close]{\sphinxcrossref{\sphinxcode{FaStream.close()}}}} when you don't need it anymore.
\index{close() (libPoMo.fasta.MFaStream method)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.MFaStream.close}\pysiglinewithargsret{\sphinxbfcode{close}}{}{}
Close the linked file object.

\end{fulllineitems}

\index{orient() (libPoMo.fasta.MFaStream method)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.MFaStream.orient}\pysiglinewithargsret{\sphinxbfcode{orient}}{\emph{firstOnly=False}}{}
Orient all sequences of the alignment to be in forward direction.

This is rather slow for long sequences.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{firstOnly}} (\emph{\texttt{Boolean}}) -- If true, orient the first sequence only.

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_info() (libPoMo.fasta.MFaStream method)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.MFaStream.print_info}\pysiglinewithargsret{\sphinxbfcode{print\_info}}{\emph{maxB=50}}{}
Print sequence information.

Print information about this MFaStream object, the fasta
sequence stored at the moment the length of the sequence and a
maximum of \sphinxtitleref{maxB} bases (defaults to 50).

\end{fulllineitems}

\index{print\_msa() (libPoMo.fasta.MFaStream method)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.MFaStream.print_msa}\pysiglinewithargsret{\sphinxbfcode{print\_msa}}{\emph{fo=\textless{}\_io.TextIOWrapper name='\textless{}stdout\textgreater{}' mode='w' encoding='UTF-8'\textgreater{}}}{}
Print multiple sequence alignment at point.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{fo}} (\emph{\texttt{fileObject}}) -- Print to file object fo. Defaults to
stdout.

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_next\_align() (libPoMo.fasta.MFaStream method)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.MFaStream.read_next_align}\pysiglinewithargsret{\sphinxbfcode{read\_next\_align}}{}{}
Read next alignment in fasta file.

The return value is the name of the newly saved alignment or
None if no next alignment is found.

\end{fulllineitems}


\end{fulllineitems}

\index{NotAFastaFileError}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.NotAFastaFileError}\pysigline{\sphinxstrong{exception }\sphinxcode{libPoMo.fasta.}\sphinxbfcode{NotAFastaFileError}}
Exception raised if given fasta file is not valid.

\end{fulllineitems}

\index{filter\_mfa\_str() (in module libPoMo.fasta)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.filter_mfa_str}\pysiglinewithargsret{\sphinxcode{libPoMo.fasta.}\sphinxbfcode{filter\_mfa\_str}}{\emph{mfaStr}, \emph{fp}, \emph{verb=None}}{}
Check multiple sequence alignment of an MFaStream.

Multiple sequence alignments usually include alignments that are
not apt for analysis.  These low quality alignments need to be
filtered out of the original multiple sequence alignment fasta
file.  If \sphinxtitleref{verb} is unset from None, information about any
possible rejection is printed to the standard output.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{mfaStr}} ({\hyperref[fasta:libPoMo.fasta.MFaStream]{\sphinxcrossref{\emph{\texttt{MFaStream}}}}}) -- {\hyperref[fasta:libPoMo.fasta.MFaStream]{\sphinxcrossref{\sphinxcode{MFaStream}}}} object to check.

\item {} 
\textbf{\texttt{fp}} ({\hyperref[fasta:libPoMo.fasta.MFaStrFilterProps]{\sphinxcrossref{\emph{\texttt{MFaStrFilterProps}}}}}) -- {\hyperref[fasta:libPoMo.fasta.MFaStrFilterProps]{\sphinxcrossref{\sphinxcode{MFaStrFilterProps}}}}; Properties
of the filter to be applied.

\item {} 
\textbf{\texttt{verb}} (\emph{\texttt{Boolean}}) -- Verbosity.

\end{itemize}

\item[{Return type}] \leavevmode
Boolean, True if all filters have been passed.

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_seq() (in module libPoMo.fasta)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.init_seq}\pysiglinewithargsret{\sphinxcode{libPoMo.fasta.}\sphinxbfcode{init\_seq}}{\emph{faFileName}, \emph{maxskip=50}, \emph{name=None}}{}
Open a fasta file and initialize an {\hyperref[fasta:libPoMo.fasta.FaStream]{\sphinxcrossref{\sphinxcode{FaStream}}}}.

This function tries to open the given fasta file, checks if it is
in fasta format and reads the first sequence.  It returns an
{\hyperref[fasta:libPoMo.fasta.FaStream]{\sphinxcrossref{\sphinxcode{FaStream}}}} object. This object can later be used to parse
the whole fasta file.

Please close the associated file object with
{\hyperref[fasta:libPoMo.fasta.FaStream.close]{\sphinxcrossref{\sphinxcode{FaStream.close()}}}} when you don't need it anymore.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{faFileName}} (\emph{\texttt{str}}) -- File name of the fasta file.

\item {} 
\textbf{\texttt{maxskip}} (\emph{\texttt{int}}) -- Only look \emph{maxskip} lines for the start of a
sequence (defaults to 50).

\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Set the name of the sequence to \emph{name}, otherwise
set it to the stripped filename.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{open\_seq() (in module libPoMo.fasta)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.open_seq}\pysiglinewithargsret{\sphinxcode{libPoMo.fasta.}\sphinxbfcode{open\_seq}}{\emph{faFileName}, \emph{maxskip=50}, \emph{name=None}}{}
Open and read a fasta file.

This function tries to open the given fasta file, checks if it is
in fasta format and reads the sequence(s).  It returns an
{\hyperref[fasta:libPoMo.fasta.FaSeq]{\sphinxcrossref{\sphinxcode{FaSeq}}}} object that contains a list of species names, a
list of the respective desriptions and a list with the sequences.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{faFileName}} (\emph{\texttt{str}}) -- Name of the fasta file.

\item {} 
\textbf{\texttt{maxskip}} (\emph{\texttt{int}}) -- Only look \emph{maxskip} lines for the start of a sequence
(defaults to 50).

\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Set the name of the sequence to \emph{name} otherwise
set it to the stripped filename.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_align\_from\_fo() (in module libPoMo.fasta)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.read_align_from_fo}\pysiglinewithargsret{\sphinxcode{libPoMo.fasta.}\sphinxbfcode{read\_align\_from\_fo}}{\emph{line}, \emph{fo}}{}
Read a single fasta alignment.

Read a single fasta alignment from file object \emph{fo} and save it to
new {\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\sphinxcode{Seq}}}} sequence objects.  Return
the header line of the next fasta alignment and the newly created
sequences in a list.  If no new alignment is found, the next header
line will be set to None.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{line}} (\emph{\texttt{str}}) -- Header line of the sequence.

\item {} 
\textbf{\texttt{fo}} (\emph{\texttt{fo}}) -- File object of the fasta file.

\end{itemize}

\item[{Return type}] \leavevmode
(str, {[}Seq{]})

\end{description}\end{quote}

\end{fulllineitems}

\index{read\_seq\_from\_fo() (in module libPoMo.fasta)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.read_seq_from_fo}\pysiglinewithargsret{\sphinxcode{libPoMo.fasta.}\sphinxbfcode{read\_seq\_from\_fo}}{\emph{line}, \emph{fo}, \emph{getAlignEndFlag=False}}{}
Read a single fasta sequence.

Read a single fasta sequence from file object \emph{fo} and save it to
a new {\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\sphinxcode{Seq}}}} sequence object. Return
the header line of the next fasta sequence and the newly created
sequence. If no new sequence is found, the next header line will
be set to None.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{line}} (\emph{\texttt{str}}) -- Header line of the sequence.

\item {} 
\textbf{\texttt{fo}} (\emph{\texttt{fo}}) -- File object of the fasta file.

\item {} 
\textbf{\texttt{getAlignFlag}} (\emph{\texttt{Boolean}}) -- If set to true, an additional Boolean
value that specifies if a multiple sequence alignment ends, is
returned.

\end{itemize}

\item[{Return type}] \leavevmode
(str, Seq) \textbar{} (str, Seq, Boolean)

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_as\_vcf() (in module libPoMo.fasta)}

\begin{fulllineitems}
\phantomsection\label{fasta:libPoMo.fasta.save_as_vcf}\pysiglinewithargsret{\sphinxcode{libPoMo.fasta.}\sphinxbfcode{save\_as\_vcf}}{\emph{faSeq}, \emph{ref}, \emph{VCFFileName}}{}
Save the given :classL{}`FaSeq{}` in VCF format.

In general, we want to convert a fasta file with various
individuals with the help of a reference that contains one
sequence to a VCF file that contains all the SNPs.  This can be
done with this function.  Until now it is not possible to do this
conversion for several chromosomes for each individual in one run.
Still, the conversion can be done chromosome by chromosome.

This function saves the SNPs of \emph{faSeq}, a given {\hyperref[fasta:libPoMo.fasta.FaSeq]{\sphinxcrossref{\sphinxcode{FaSeq}}}}
(fasta sequence) object in VCF format to the file \emph{VCFFileName}.
The reference genome \emph{ref}, to which \emph{faSeq} is compared to, needs
to be passed as a {\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\sphinxcode{Seq}}}} object.

The function compares all sequences in \emph{faSeq} to the sequence
given in \emph{ref}.  The names of the individuals in the saved VCF
file will be the sequence names of the \emph{faSeq} object.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}CHROM = sequence name of the reference}
\PYG{n}{POS}    \PYG{o}{=} \PYG{n}{position} \PYG{n}{relative} \PYG{n}{to} \PYG{n}{reference}
\PYG{n}{ID}     \PYG{o}{=} \PYG{o}{.}
\PYG{n}{REF}    \PYG{o}{=} \PYG{n}{base} \PYG{n}{of} \PYG{n}{reference}
\PYG{n}{ALT}    \PYG{o}{=} \PYG{n}{SNP} \PYG{p}{(}\PYG{n}{e}\PYG{o}{.}\PYG{n}{g}\PYG{o}{.} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{or} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{G,T}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{l+m+mi}{2} \PYG{n}{different} \PYG{n}{SNPs} \PYG{n}{are} \PYG{n}{present}\PYG{p}{)}
\PYG{n}{QUAL}   \PYG{o}{=} \PYG{o}{.}
\PYG{n}{FILTER} \PYG{o}{=} \PYG{o}{.}
\PYG{n}{INFO}   \PYG{o}{=} \PYG{o}{.}
\PYG{n}{FORMAT} \PYG{o}{=} \PYG{n}{GT}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{faSeq}} ({\hyperref[fasta:libPoMo.fasta.FaSeq]{\sphinxcrossref{\emph{\texttt{FaSeq}}}}}) -- {\hyperref[fasta:libPoMo.fasta.FaSeq]{\sphinxcrossref{\sphinxcode{FaSeq}}}} object to be converted.

\item {} 
\textbf{\texttt{ref}} ({\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\emph{\texttt{Seq}}}}}) -- {\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\sphinxcode{Seq}}}} object of the
reference sequence.

\item {} 
\textbf{\texttt{VCFFileName}} (\emph{\texttt{str}}) -- Name of the VCF output file.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\phantomsection\label{vcf:module-libPoMo.vcf}\index{libPoMo.vcf (module)}

\section{libPoMo.vcf}
\label{vcf::doc}\label{vcf:libpomo-vcf}
This module provides functions to read, write and access vcf files.


\subsection{Objects}
\label{vcf:objects}\begin{description}
\item[{Classes:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[vcf:libPoMo.vcf.NucBase]{\sphinxcrossref{\sphinxcode{NucBase}}}}, store a nucleotide base

\item {} 
{\hyperref[vcf:libPoMo.vcf.VCFStream]{\sphinxcrossref{\sphinxcode{VCFStream}}}}, a variant call format (VCF) stream object

\item {} 
{\hyperref[vcf:libPoMo.vcf.VCFSeq]{\sphinxcrossref{\sphinxcode{VCFSeq}}}}, a VCF file sequence object

\end{itemize}

\item[{Exception Classes:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[vcf:libPoMo.vcf.NotAVariantCallFormatFileError]{\sphinxcrossref{\sphinxcode{NotAVariantCallFormatFileError}}}}

\item {} 
{\hyperref[vcf:libPoMo.vcf.NotANucBaseError]{\sphinxcrossref{\sphinxcode{NotANucBaseError}}}}

\end{itemize}

\item[{Functions:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[vcf:libPoMo.vcf.update_base]{\sphinxcrossref{\sphinxcode{update\_base()}}}}, read a line into a base

\item {} 
{\hyperref[vcf:libPoMo.vcf.get_nuc_base_from_line]{\sphinxcrossref{\sphinxcode{get\_nuc\_base\_from\_line()}}}}, create a new \sphinxtitleref{NucBase} from a line

\item {} 
{\hyperref[vcf:libPoMo.vcf.check_fixed_field_header]{\sphinxcrossref{\sphinxcode{check\_fixed\_field\_header()}}}}, check a VCF fixed field header
string

\item {} 
{\hyperref[vcf:libPoMo.vcf.get_indiv_from_field_header]{\sphinxcrossref{\sphinxcode{get\_indiv\_from\_field\_header()}}}}, extract list of individuals
from header

\item {} 
{\hyperref[vcf:libPoMo.vcf.init_seq]{\sphinxcrossref{\sphinxcode{init\_seq()}}}}, open VCF file and initialize \sphinxtitleref{VCFStream}

\item {} 
{\hyperref[vcf:libPoMo.vcf.open_seq]{\sphinxcrossref{\sphinxcode{open\_seq()}}}}, open VCF file and save it to a \sphinxtitleref{VCFSeq}

\item {} 
{\hyperref[vcf:libPoMo.vcf.get_header_line_string]{\sphinxcrossref{\sphinxcode{get\_header\_line\_string()}}}}, print vcf header line

\end{itemize}

\end{description}


\bigskip\hrule{}\bigskip

\index{NotANucBaseError}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.NotANucBaseError}\pysigline{\sphinxstrong{exception }\sphinxcode{libPoMo.vcf.}\sphinxbfcode{NotANucBaseError}}
Exception raised if given nucleotide base is not valid.

\end{fulllineitems}

\index{NotAVariantCallFormatFileError}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.NotAVariantCallFormatFileError}\pysigline{\sphinxstrong{exception }\sphinxcode{libPoMo.vcf.}\sphinxbfcode{NotAVariantCallFormatFileError}}
Exception raised if given VCF file is not valid.

\end{fulllineitems}

\index{NucBase (class in libPoMo.vcf)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.NucBase}\pysigline{\sphinxstrong{class }\sphinxcode{libPoMo.vcf.}\sphinxbfcode{NucBase}}
Stores a nucleotide base.

FIXME: Bases are split by `/'.  They should also be split by `\textbar{}'.

A class that stores a single nucleotide base and related
information retrieved from a VCF file.  Please see
\url{http://www.1000genomes.org/} for a detailed description of the vcf
format.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{chrom}} (\emph{\texttt{str}}) -- Chromosome name.

\item {} 
\textbf{\texttt{pos}} (\emph{\texttt{int}}) -- 1-based position on the chromosome.

\item {} 
\textbf{\texttt{id}} (\emph{\texttt{str}}) -- ID.

\item {} 
\textbf{\texttt{ref}} (\emph{\texttt{str}}) -- Reference base.

\item {} 
\textbf{\texttt{alt}} (\emph{\texttt{str}}) -- Alternative base(s).

\item {} 
\textbf{\texttt{qual}} (\emph{\texttt{str}}) -- Quality.

\item {} 
\textbf{\texttt{filter}} (\emph{\texttt{str}}) -- Filter.

\item {} 
\textbf{\texttt{info}} (\emph{\texttt{str}}) -- Additional information.

\item {} 
\textbf{\texttt{format}} (\emph{\texttt{str}}) -- String with format specification.

\item {} 
\textbf{\texttt{speciesData}} (\emph{\texttt{{[}str{]}}}) -- List with strings of the species data
(e.g. 0/1:...).

\item {} 
\textbf{\texttt{ploidy}} (\emph{\texttt{int}}) -- Ploidy (number of sets of chromosomes) of the
sequenced individuals. Can be set with
{\hyperref[vcf:libPoMo.vcf.NucBase.set_ploidy]{\sphinxcrossref{\sphinxcode{set\_ploidy()}}}}.

\end{itemize}

\end{description}\end{quote}
\index{get\_alt\_base\_list() (libPoMo.vcf.NucBase method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.NucBase.get_alt_base_list}\pysiglinewithargsret{\sphinxbfcode{get\_alt\_base\_list}}{}{}
Return alternative bases as a list.

\end{fulllineitems}

\index{get\_base\_ind() (libPoMo.vcf.NucBase method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.NucBase.get_base_ind}\pysiglinewithargsret{\sphinxbfcode{get\_base\_ind}}{\emph{iI}, \emph{iC}}{}
Return the base of a specific individual.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{indiv}} (\emph{\texttt{int}}) -- 0-based index of individual.

\item {} 
\textbf{\texttt{chrom}} (\emph{\texttt{int}}) -- 0-based index of chromosome (for n-ploid
individuals).

\end{itemize}

\item[{Return type}] \leavevmode
character with nucleotide base.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_info() (libPoMo.vcf.NucBase method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.NucBase.get_info}\pysiglinewithargsret{\sphinxbfcode{get\_info}}{}{}
Return nucleotide base information string.

\end{fulllineitems}

\index{get\_ref\_base() (libPoMo.vcf.NucBase method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.NucBase.get_ref_base}\pysiglinewithargsret{\sphinxbfcode{get\_ref\_base}}{}{}
Return reference base.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
char

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_speciesData() (libPoMo.vcf.NucBase method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.NucBase.get_speciesData}\pysiglinewithargsret{\sphinxbfcode{get\_speciesData}}{}{}
Return species data as a list.
\begin{itemize}
\item {} 
data{[}0{]}{[}0{]} = data of first species/individual on chromatide A

\item {} \begin{description}
\item[{data{[}0{]}{[}1{]} = only set for non-haploids; data of first}] \leavevmode
species/individual on chromatide B

\end{description}

\end{itemize}

Sets data{[}i{]}{[}j{]} to None if the base of individual \emph{i} on
chromosome \emph{j} could not be read (e.g. it is not valid).
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
matrix of integers

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_info() (libPoMo.vcf.NucBase method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.NucBase.print_info}\pysiglinewithargsret{\sphinxbfcode{print\_info}}{}{}
Print nucleotide base information.

Print the stored single nucleotide base and related
information from the VCF file.

\end{fulllineitems}

\index{purge() (libPoMo.vcf.NucBase method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.NucBase.purge}\pysiglinewithargsret{\sphinxbfcode{purge}}{}{}
Purge the data associated with this {\hyperref[vcf:libPoMo.vcf.NucBase]{\sphinxcrossref{\sphinxcode{NucBase}}}}.

\end{fulllineitems}

\index{set\_ploidy() (libPoMo.vcf.NucBase method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.NucBase.set_ploidy}\pysiglinewithargsret{\sphinxbfcode{set\_ploidy}}{}{}
Set self.ploidy.

\end{fulllineitems}


\end{fulllineitems}

\index{VCFSeq (class in libPoMo.vcf)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.VCFSeq}\pysigline{\sphinxstrong{class }\sphinxcode{libPoMo.vcf.}\sphinxbfcode{VCFSeq}}
Store data retrieved from a VCF file.

Initialized with {\hyperref[vcf:libPoMo.vcf.open_seq]{\sphinxcrossref{\sphinxcode{open\_seq()}}}}.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Sequence name.

\item {} 
\textbf{\texttt{header}} (\emph{\texttt{str}}) -- Sequence header.

\item {} 
\textbf{\texttt{speciesL}} (\emph{\texttt{{[}str{]}}}) -- List with species / individuals.

\item {} 
\textbf{\texttt{nSpecies}} (\emph{\texttt{int}}) -- Number of species / individuals.

\item {} 
\textbf{\texttt{baseL}} (\emph{\texttt{{[}NucBase{]}}}) -- List with stored {\hyperref[vcf:libPoMo.vcf.NucBase]{\sphinxcrossref{\sphinxcode{NucBase}}}} objects.

\item {} 
\textbf{\texttt{nBases}} (\emph{\texttt{int}}) -- Number of {\hyperref[vcf:libPoMo.vcf.NucBase]{\sphinxcrossref{\sphinxcode{NucBase}}}} objects stored.

\end{itemize}

\end{description}\end{quote}
\index{append\_nuc\_base() (libPoMo.vcf.VCFSeq method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.VCFSeq.append_nuc_base}\pysiglinewithargsret{\sphinxbfcode{append\_nuc\_base}}{\emph{base}}{}
Append \emph{base}, a given {\hyperref[vcf:libPoMo.vcf.NucBase]{\sphinxcrossref{\sphinxcode{NucBase}}}}, to the VCFSeq object.

\end{fulllineitems}

\index{get\_header\_line\_string() (libPoMo.vcf.VCFSeq method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.VCFSeq.get_header_line_string}\pysiglinewithargsret{\sphinxbfcode{get\_header\_line\_string}}{\emph{indiv}}{}
Return a standard VCF File header string with individuals \emph{indiv}.

\end{fulllineitems}

\index{get\_nuc\_base() (libPoMo.vcf.VCFSeq method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.VCFSeq.get_nuc_base}\pysiglinewithargsret{\sphinxbfcode{get\_nuc\_base}}{\emph{chrom}, \emph{pos}}{}
Return base at position \emph{pos} of chromosome \emph{chrom}.

\end{fulllineitems}

\index{has\_base() (libPoMo.vcf.VCFSeq method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.VCFSeq.has_base}\pysiglinewithargsret{\sphinxbfcode{has\_base}}{\emph{chrom}, \emph{pos}}{}
Return True (False) if base is (not) found.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{chrom}} (\emph{\texttt{str}}) -- Chromosome name.

\item {} 
\textbf{\texttt{pos}} (\emph{\texttt{int}}) -- 1-based position on \emph{chrom}.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{print\_header\_line() (libPoMo.vcf.VCFSeq method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.VCFSeq.print_header_line}\pysiglinewithargsret{\sphinxbfcode{print\_header\_line}}{\emph{indiv}}{}
Print a standard VCF File header with individuals \emph{indiv}.

\end{fulllineitems}

\index{print\_info() (libPoMo.vcf.VCFSeq method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.VCFSeq.print_info}\pysiglinewithargsret{\sphinxbfcode{print\_info}}{\emph{maxB=50}, \emph{printHeader=False}}{}
Print VCF sequence information.

Print vcf header, the total number of nucleotides and a
maximum of \emph{maxB} bases (defaults to 50). Only prints header
if \emph{printHeader} = True is given.

\end{fulllineitems}


\end{fulllineitems}

\index{VCFStream (class in libPoMo.vcf)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.VCFStream}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{libPoMo.vcf.}\sphinxbfcode{VCFStream}}{\emph{seqName}, \emph{vcfFileObject}, \emph{speciesList}, \emph{firstBase}}{}
Store base data from a VCF file line per line.

It can be initialized with {\hyperref[vcf:libPoMo.vcf.init_seq]{\sphinxcrossref{\sphinxcode{init\_seq()}}}}.  This class stores a
single base retrieved from a VCF file and the file itself.  It is
used to parse through a VCF file line by line processing the bases
without having to read the whole file at one.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{seqName}} (\emph{\texttt{str}}) -- Name of the stream.

\item {} 
\textbf{\texttt{vcfFileObject}} (\emph{\texttt{fo}}) -- File object associated with the stream.

\item {} 
\textbf{\texttt{speciesList}} (\emph{\texttt{{[}str{]}}}) -- List with species / individuals.

\item {} 
\textbf{\texttt{firstBase}} ({\hyperref[vcf:libPoMo.vcf.NucBase]{\sphinxcrossref{\emph{\texttt{NucBase}}}}}) -- First {\hyperref[vcf:libPoMo.vcf.NucBase]{\sphinxcrossref{\sphinxcode{NucBase}}}} to be saved.

\end{itemize}

\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Name of the stream.

\item {} 
\textbf{\texttt{fo}} (\emph{\texttt{fo}}) -- Stored VCF file object.

\item {} 
\textbf{\texttt{speciesL}} (\emph{\texttt{{[}str{]}}}) -- List with species / individuals.

\item {} 
\textbf{\texttt{nSpecies}} (\emph{\texttt{int}}) -- Number of species / individuals.

\item {} 
\textbf{\texttt{base}} (\emph{\texttt{NusBase}}) -- Stored {\hyperref[vcf:libPoMo.vcf.NucBase]{\sphinxcrossref{\sphinxcode{NucBase}}}}.

\end{itemize}

\end{description}\end{quote}
\index{close() (libPoMo.vcf.VCFStream method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.VCFStream.close}\pysiglinewithargsret{\sphinxbfcode{close}}{}{}
Closes the linked file.

\end{fulllineitems}

\index{print\_info() (libPoMo.vcf.VCFStream method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.VCFStream.print_info}\pysiglinewithargsret{\sphinxbfcode{print\_info}}{}{}
Prints VCFStream information.

\end{fulllineitems}

\index{read\_next\_base() (libPoMo.vcf.VCFStream method)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.VCFStream.read_next_base}\pysiglinewithargsret{\sphinxbfcode{read\_next\_base}}{}{}
Read the next base.

Return position of next base.

Raise a \emph{ValueError} if no next base is found.

\end{fulllineitems}


\end{fulllineitems}

\index{check\_fixed\_field\_header() (in module libPoMo.vcf)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.check_fixed_field_header}\pysiglinewithargsret{\sphinxcode{libPoMo.vcf.}\sphinxbfcode{check\_fixed\_field\_header}}{\emph{ln}}{}
Check if the given line \emph{ln} is the header of the fixed fields.

Sample header line:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}CHROM     POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  SpeciesL}
\end{Verbatim}

\end{fulllineitems}

\index{get\_header\_line\_string() (in module libPoMo.vcf)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.get_header_line_string}\pysiglinewithargsret{\sphinxcode{libPoMo.vcf.}\sphinxbfcode{get\_header\_line\_string}}{\emph{indiv}}{}
Return a standard VCF File header string with individuals \emph{indiv}.

\end{fulllineitems}

\index{get\_indiv\_from\_field\_header() (in module libPoMo.vcf)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.get_indiv_from_field_header}\pysiglinewithargsret{\sphinxcode{libPoMo.vcf.}\sphinxbfcode{get\_indiv\_from\_field\_header}}{\emph{ln}}{}
Return species from a fixed field header line \emph{ln}.

Sample header line:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}CHROM     POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  SpeciesL}
\end{Verbatim}

\end{fulllineitems}

\index{get\_nuc\_base\_from\_line() (in module libPoMo.vcf)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.get_nuc_base_from_line}\pysiglinewithargsret{\sphinxcode{libPoMo.vcf.}\sphinxbfcode{get\_nuc\_base\_from\_line}}{\emph{ln}, \emph{info=False}, \emph{ploidy=None}}{}
Retrieve base data from a VCF file line \emph{ln}.

Split a given VCF file line and returns a NucBase object. If
\emph{info} is set to False, only \#CHROM, POS, REF, ALT and speciesData will
be read.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{info}} (\emph{\texttt{Bool}}) -- Determines if info is retrieved from \emph{ln}.

\item {} 
\textbf{\texttt{ploidy}} (\emph{\texttt{int}}) -- If ploidy is known and given, it is set.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_seq() (in module libPoMo.vcf)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.init_seq}\pysiglinewithargsret{\sphinxcode{libPoMo.vcf.}\sphinxbfcode{init\_seq}}{\emph{VCFFileName}, \emph{maxskip=100}, \emph{name=None}}{}
Open a (gzipped) VCF4.1 file.

Try to open the given VCF file, checks if it is in VCF format.
Initialize a {\hyperref[vcf:libPoMo.vcf.VCFStream]{\sphinxcrossref{\sphinxcode{VCFStream}}}} object that contains the first
base.

Please close the associated file object with
{\hyperref[vcf:libPoMo.vcf.VCFStream.close]{\sphinxcrossref{\sphinxcode{VCFStream.close()}}}} when you don't need it anymore.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{VCFFileName}} (\emph{\texttt{str}}) -- Name of the VCF file.

\item {} 
\textbf{\texttt{maxskip}} (\emph{\texttt{int}}) -- Only look \emph{maxskip} lines for the start of the
bases (defaults to 80).

\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Set the name of the sequence to \emph{name}, otherwise
set it to the filename.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{open\_seq() (in module libPoMo.vcf)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.open_seq}\pysiglinewithargsret{\sphinxcode{libPoMo.vcf.}\sphinxbfcode{open\_seq}}{\emph{VCFFileName}, \emph{maxskip=100}, \emph{name=None}}{}
Open a VCF4.1 file.

Try to open the given VCF file, checks if it is in VCF format and
reads the bases(s).  It returns an {\hyperref[vcf:libPoMo.vcf.VCFSeq]{\sphinxcrossref{\sphinxcode{VCFSeq}}}} object that
contains all the information.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{VCFFileName}} (\emph{\texttt{str}}) -- Name of the VCF file.

\item {} 
\textbf{\texttt{maxskip}} (\emph{\texttt{int}}) -- Only look \emph{maxskip} lines for the start of the
bases (defaults to 80).

\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Set the name of the sequence to \emph{name}, otherwise
set it to the filename.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_base() (in module libPoMo.vcf)}

\begin{fulllineitems}
\phantomsection\label{vcf:libPoMo.vcf.update_base}\pysiglinewithargsret{\sphinxcode{libPoMo.vcf.}\sphinxbfcode{update\_base}}{\emph{ln}, \emph{base}, \emph{info=True}}{}
Read line \emph{ln} into base \emph{base}.

Split a given VCF file line and returns a {\hyperref[vcf:libPoMo.vcf.NucBase]{\sphinxcrossref{\sphinxcode{NucBase}}}}
object. If \emph{info} is set to False, only \#CHROM, REF, ALT and
speciesData will be read.

\end{fulllineitems}

\phantomsection\label{cf:module-libPoMo.cf}\index{libPoMo.cf (module)}

\section{libPoMo.cf}
\label{cf::doc}\label{cf:libpomo-cf}
This model provides functions to read, write and access files that are
in counts format.


\subsection{The Counts Format}
\label{cf:the-counts-format}
This file format is used by PoMo and lists the base
counts for every position.
\begin{description}
\item[{It contains:}] \leavevmode\begin{itemize}
\item {} 
1 line that specifies the file as counts file and states the
number of populations as well as the number of sites

\item {} 
1 headerline with tab separated sequence names

\item {} 
N lines with counts of A, C, G and T bases at position n

\end{itemize}

\item[{It can contain:}] \leavevmode\begin{itemize}
\item {} 
any number of lines that start with a \#, these are treated as
comments; There are no more comments allowed after the headerline.

\end{itemize}

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{COUNTSFILE}     \PYG{n}{NPOP} \PYG{l+m+mi}{5}          \PYG{n}{NSITES} \PYG{n}{N}
\PYG{n}{CHROM}          \PYG{n}{POS}     \PYG{n}{Sheep}           \PYG{n}{BlackSheep}      \PYG{n}{RedSheep}        \PYG{n}{Wolf}            \PYG{n}{RedWolf}
\PYG{l+m+mi}{1}      \PYG{n}{s}       \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{1}      \PYG{n}{s} \PYG{o}{+} \PYG{l+m+mi}{1}   \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}
\PYG{o}{.}
\PYG{o}{.}
\PYG{o}{.}
\PYG{l+m+mi}{9}      \PYG{l+m+mi}{8373}    \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}         \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{0}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}
\PYG{o}{.}
\PYG{o}{.}
\PYG{o}{.}
\PYG{n}{Y}      \PYG{n}{end}     \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}         \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}
\end{Verbatim}


\subsection{Convert to Counts Format}
\label{cf:convert-to-counts-format}
To convert a fasta reference file with SNP information from a variant
call format (VCF) to counts format use the {\hyperref[cf:libPoMo.cf.CFWriter]{\sphinxcrossref{\sphinxcode{CFWriter}}}}. If you
want to convert a multiple alignment fasta file, use the
{\hyperref[cf:libPoMo.cf.CFWriter]{\sphinxcrossref{\sphinxcode{CFWriter}}}} together with the convenience function
{\hyperref[cf:libPoMo.cf.write_cf_from_MFaStream]{\sphinxcrossref{\sphinxcode{write\_cf\_from\_MFaStream()}}}}.

Tabix index files need to be provided for all VCF files. They can be
created from the terminal with \$(tabix -p vcf ``vcf-file.vcf.gz'') if
tabix is installed.

A code example is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{import\PYGZus{}libPoMo}
\PYG{k+kn}{import} \PYG{n+nn}{libPoMo}\PYG{n+nn}{.}\PYG{n+nn}{fasta} \PYG{k}{as} \PYG{n+nn}{fa}
\PYG{k+kn}{import} \PYG{n+nn}{libPoMo}\PYG{n+nn}{.}\PYG{n+nn}{cf} \PYG{k}{as} \PYG{n+nn}{cf}

\PYG{n}{vcfFL} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/path/to/vcf/file1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/path/to/vcf/file2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{...}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}

\PYG{n}{cfw} \PYG{o}{=} \PYG{n}{cf}\PYG{o}{.}\PYG{n}{CFWriter}\PYG{p}{(}\PYG{n}{vcfFL}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name\PYGZhy{}of\PYGZhy{}outfile}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{mFaStr} \PYG{o}{=} \PYG{n}{fa}\PYG{o}{.}\PYG{n}{MFaStream}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/path/to/fasta/reference}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{cfw}\PYG{o}{.}\PYG{n}{write\PYGZus{}HLn}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{cf}\PYG{o}{.}\PYG{n}{write\PYGZus{}cf\PYGZus{}from\PYGZus{}MFaStream}\PYG{p}{(}\PYG{n}{mFaStr}\PYG{p}{,} \PYG{n}{cfw}\PYG{p}{)}

\PYG{n}{cfw}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\subsection{Objects}
\label{cf:objects}\begin{description}
\item[{Classes:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[cf:libPoMo.cf.CFStream]{\sphinxcrossref{\sphinxcode{CFStream}}}}

\item {} 
{\hyperref[cf:libPoMo.cf.CFWriter]{\sphinxcrossref{\sphinxcode{CFWriter}}}}, write a counts format file

\end{itemize}

\item[{Exception Classes:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[cf:libPoMo.cf.NotACountsFormatFileError]{\sphinxcrossref{\sphinxcode{NotACountsFormatFileError}}}}

\item {} 
{\hyperref[cf:libPoMo.cf.CountsFormatWriterError]{\sphinxcrossref{\sphinxcode{CountsFormatWriterError}}}}

\item {} 
{\hyperref[cf:libPoMo.cf.NoSynBase]{\sphinxcrossref{\sphinxcode{NoSynBase}}}}

\end{itemize}

\item[{Functions:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[cf:libPoMo.cf.interpret_cf_line]{\sphinxcrossref{\sphinxcode{interpret\_cf\_line()}}}}, get data of a line in counts format

\item {} 
{\hyperref[cf:libPoMo.cf.faseq_append_base_of_cfS]{\sphinxcrossref{\sphinxcode{faseq\_append\_base\_of\_cfS()}}}}, append CFStream line to FaSeq

\item {} 
{\hyperref[cf:libPoMo.cf.cf_to_fasta]{\sphinxcrossref{\sphinxcode{cf\_to\_fasta()}}}}, convert counts file to fasta file

\item {} 
{\hyperref[cf:libPoMo.cf.write_cf_from_MFaStream]{\sphinxcrossref{\sphinxcode{write\_cf\_from\_MFaStream()}}}}, write counts file using the
given MFaStream and CFWriter

\item {} 
{\hyperref[cf:libPoMo.cf.fasta_to_cf]{\sphinxcrossref{\sphinxcode{fasta\_to\_cf()}}}}, convert fasta to counts format

\end{itemize}

\end{description}


\bigskip\hrule{}\bigskip

\index{CFStream (class in libPoMo.cf)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.CFStream}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{libPoMo.cf.}\sphinxbfcode{CFStream}}{\emph{CFFileName}, \emph{name=None}}{}
Store data of a CF file line per line.

Open a (gzipped) CF file. The file can be read line per line with
{\hyperref[cf:libPoMo.cf.CFStream.read_next_pos]{\sphinxcrossref{\sphinxcode{read\_next\_pos()}}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{CFFileName}} (\emph{\texttt{str}}) -- Counts format file name to be read.

\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Optional; stream name, defaults to stripped
filename.

\end{itemize}

\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{name}} (\emph{\texttt{str}}) -- Stream name.

\item {} 
\textbf{\texttt{chrom}} (\emph{\texttt{str}}) -- Chromosome name.

\item {} 
\textbf{\texttt{pos}} (\emph{\texttt{str}}) -- Positional string.

\item {} 
\textbf{\texttt{fo}} (\emph{\texttt{fo}}) -- Fileobject.

\item {} 
\textbf{\texttt{indivL}} (\emph{\texttt{{[}str{]}}}) -- List of names of individuals (populations).

\item {} 
\textbf{\texttt{countsL}} (\emph{\texttt{{[}{[}int{]}{]}}}) -- Numpy array of nucleotide counts.

\item {} 
\textbf{\texttt{nIndiv}} (\emph{\texttt{int}}) -- Number of individuals (populations).

\end{itemize}

\end{description}\end{quote}
\index{read\_next\_pos() (libPoMo.cf.CFStream method)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.CFStream.read_next_pos}\pysiglinewithargsret{\sphinxbfcode{read\_next\_pos}}{}{}
Get next base.

Return position of next base.  Raises \sphinxtitleref{ValueError} if there is
no next base.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CFWriter (class in libPoMo.cf)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.CFWriter}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{libPoMo.cf.}\sphinxbfcode{CFWriter}}{\emph{vcfFileNameL}, \emph{outFileName}, \emph{splitChar='-`}, \emph{mergeL=None}, \emph{nameL=None}, \emph{oneIndividual=False}}{}
Write a counts format file.

Save information that is needed to write a CF file and use this
information to write a CF file.  Initialize with a list of vcf
file names and an output file name:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{CFWriter}\PYG{p}{(}\PYG{p}{[}\PYG{n}{vcfFileNames}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

Tabix index files need to be provided for all VCF files. They can
be created from the terminal with \$(tabix -p vcf
``vcf-file.vcf.gz'') if tabix is installed.

Before the count file can be written, a reference sequence has to
be specified.  A single reference sequence can be set with
{\hyperref[cf:libPoMo.cf.CFWriter.set_seq]{\sphinxcrossref{\sphinxcode{set\_seq()}}}}.

Write a header line to output:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{write\PYGZus{}HLn}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Write lines in counts format from 1-based positions \emph{start} to
\emph{end} on chromosome \emph{chrom} to output:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rg} \PYG{o}{=} \PYG{n}{sb}\PYG{o}{.}\PYG{n}{Region}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{chrom}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{end}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{write\PYGZus{}Rn}\PYG{p}{(}\PYG{n}{rg}\PYG{p}{)}
\end{Verbatim}

If you want to compare the SNPs of the VCF files to a multiple
alingment fasta stream ({\hyperref[fasta:libPoMo.fasta.MFaStream]{\sphinxcrossref{\sphinxcode{MFaStream}}}}) consider the very convenient function
{\hyperref[cf:libPoMo.cf.write_cf_from_MFaStream]{\sphinxcrossref{\sphinxcode{write\_cf\_from\_MFaStream()}}}}.

To determine the different populations present in the VCF files,
the names of the individuals will be cropped at a specific char
that can be set at initialization (standard value = `-`). It is
also possible to collapse all individuals of determined VCF files
to a single population (cf. mergeL and nameL).

The ploidity has to be set manually if it differs from 2.

Additional filters can be set before the counts file is written
(e.g. only write synonymous sites).

Important: Remember to close the attached file objectsL with
{\hyperref[cf:libPoMo.cf.CFWriter.close]{\sphinxcrossref{\sphinxcode{close()}}}}.  If the CFWriter is not closed, the counts file
is not usable because the first line is missing!
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{vcfFileNameL}} (\emph{\texttt{{[}str{]}}}) -- List with names of vcf files.

\item {} 
\textbf{\texttt{outFileName}} (\emph{\texttt{str}}) -- Output file name.

\item {} 
\textbf{\texttt{verb}} (\emph{\texttt{int}}) -- Optional; verbosity level.

\item {} 
\textbf{\texttt{splitChar}} (\emph{\texttt{char}}) -- Optional; set the split character so that
the individuals get sorted into the correct populations.

\item {} 
\textbf{\texttt{mergeL}} (\emph{\texttt{{[}Boolean{]}}}) -- Optional; a list of truth values.  If
\emph{mL{[}i{]}} is True, all individuals of \emph{self.vcfL{[}i{]}} are treated as
one population orspecies independent of their name.  The
respective counts are summed up.  If \emph{self.nL{[}i{]}} is given, the
name of the summed sequence will be \emph{self.nL{[}i{]}}.  If not, the
name of the first individual in \emph{vcfL{[}i{]}} will be used.

\item {} 
\textbf{\texttt{nameL}} (\emph{\texttt{{[}str{]}}}) -- Optional; a list of names. Cf. \emph{self.mL}.

\item {} 
\textbf{\texttt{oneIndividual}} (\emph{\texttt{Boolean}}) -- Optional; pick one individual out
of each population.

\end{itemize}

\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{refFN}} (\emph{\texttt{str}}) -- Name of reference fasta file.

\item {} 
\textbf{\texttt{vcfL}} (\emph{\texttt{{[}str{]}}}) -- List with names of vcf files.

\item {} 
\textbf{\texttt{outFN}} (\emph{\texttt{str}}) -- Output file name.

\item {} 
\textbf{\texttt{v}} (\emph{\texttt{int}}) -- Verbosity.

\item {} 
\textbf{\texttt{mL}} (\emph{\texttt{{[}Boolean{]}}}) -- A list of truth values.  If \emph{mL{[}i{]}} is True,
all individuals of \emph{self.vcfL{[}i{]}} are treated as one
population orspecies independent of their name.  The
respective counts are summed up.  If \emph{self.nL{[}i{]}} is given,
the name of the summed sequence will be \emph{self.nL{[}i{]}}.  If not,
the name of the first individual in \emph{vcfL{[}i{]}} will be used.

\item {} 
\textbf{\texttt{nL}} (\emph{\texttt{{[}str{]}}}) -- A list of names. Cf. \emph{self.mL}.

\item {} 
\textbf{\texttt{nV}} (\emph{\texttt{int}}) -- Number of vcf files.

\item {} 
\textbf{\texttt{vcfTfL}} (\emph{\texttt{{[}fo{]}}}) -- List with \emph{pysam.Tabixfile} objects. Filled by
\emph{self.\_\_init\_vcfTfL()} during initialization.

\item {} 
\textbf{\texttt{outFO}} (\emph{\texttt{fo}}) -- File object of the outfile. Filled by
\emph{self.\_\_init\_outFO()} during initialization.

\item {} 
\textbf{\texttt{cD}} -- List with allele or base counts. The alleles of
individuals from the same population are summed up.  Hence,
\emph{self.cD{[}p{]}} gives the base counts of population \emph{p} in the
form: {[}0, 0, 0, 0{]}.  Population \emph{p} does not need to be the
one from \emph{self.vcfL{[}p{]}} because several populations might be
present in one vcf file.  \emph{self.assM} connects the individual
j from \emph{self.vcfL{[}i{]}} such that \emph{self.assM{[}i{]}{[}j{]}} is \emph{p}.

\item {} 
\textbf{\texttt{chrom}} (\emph{\texttt{str}}) -- Name of the current chromosome. Set and updated
by {\hyperref[cf:libPoMo.cf.CFWriter.write_Rn]{\sphinxcrossref{\sphinxcode{write\_Rn()}}}}.

\item {} 
\textbf{\texttt{pos}} (\emph{\texttt{int}}) -- Current position on chromosome. Set and updated by
{\hyperref[cf:libPoMo.cf.CFWriter.write_Rn]{\sphinxcrossref{\sphinxcode{write\_Rn()}}}}.

\item {} 
\textbf{\texttt{offset}} (\emph{\texttt{int}}) -- Value that can be set with {\hyperref[cf:libPoMo.cf.CFWriter.set_offset]{\sphinxcrossref{\sphinxcode{set\_offset()}}}},
if the reference sequence does not start at the
1-based position 1 but at the 1-based position
\emph{offset}.

\item {} 
\textbf{\texttt{indM}} -- Matrix with individuals from vcf files. \emph{self.indM{[}i{]}}
is the list of individuals found in \emph{self.vcfL{[}i{]}}.

\item {} 
\textbf{\texttt{nIndL}} (\emph{\texttt{{[}int{]}}}) -- List with number of individuals in
\emph{self.vcfL{[}i{]}}.

\item {} 
\textbf{\texttt{assM}} -- Assignment matrix that connects the individuals from
the vcf files to the correct \emph{self.cD} index.  Cf. \emph{self.cD}

\item {} 
\textbf{\texttt{nPop}} (\emph{\texttt{int}}) -- Number of different populations in count format
output file (e.g. number of populations).  Filled by
\emph{self.\_\_init\_assM()} during initialization.

\item {} 
\textbf{\texttt{refSeq}} ({\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\emph{\texttt{Seq}}}}}) -- {\hyperref[seqbase:libPoMo.seqbase.Seq]{\sphinxcrossref{\sphinxcode{Seq}}}} object of the
reference Sequence. This has to be set with {\hyperref[cf:libPoMo.cf.CFWriter.set_seq]{\sphinxcrossref{\sphinxcode{set\_seq}}}}.

\item {} 
\textbf{\texttt{ploidy}} (\emph{\texttt{int}}) -- Ploidy of individuals in vcf files.  This has to
be set manually to the correct value for non-diploids!

\item {} 
\textbf{\texttt{splitCh}} (\emph{\texttt{char}}) -- Character that is used to split the
individual names.

\item {} 
\textbf{\texttt{onlySynonymous}} (\emph{\texttt{Boolean}}) -- Only write 4-fold degenerate sites.

\item {} 
\textbf{\texttt{baseCounter}} (\emph{\texttt{int}}) -- Counts the total number of bases.

\item {} 
\textbf{\texttt{\_\_force}} (\emph{\texttt{Boolean}}) -- If set to true, skip name checks.

\end{itemize}

\end{description}\end{quote}
\index{add\_base\_to\_sequence() (libPoMo.cf.CFWriter method)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.CFWriter.add_base_to_sequence}\pysiglinewithargsret{\sphinxbfcode{add\_base\_to\_sequence}}{\emph{pop\_id}, \emph{base\_char}, \emph{double\_fixed\_sites=False}}{}
Adds the base given in \sphinxtitleref{base\_char} to the counts of population with
id \sphinxtitleref{pop\_id}.  If \sphinxtitleref{double\_fixed\_sited} is true, fixed sites are
counted twice.  This makes sense, when heterozygotes are
encoded with IUPAC codes.

\end{fulllineitems}

\index{close() (libPoMo.cf.CFWriter method)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.CFWriter.close}\pysiglinewithargsret{\sphinxbfcode{close}}{}{}
Write file type specifier, number of populations and number of
sites to the beginning of the output file.  Close
fileobjects.

\end{fulllineitems}

\index{set\_force() (libPoMo.cf.CFWriter method)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.CFWriter.set_force}\pysiglinewithargsret{\sphinxbfcode{set\_force}}{\emph{val}}{}
Sets \emph{self.\_\_force} to \emph{val}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{val}} (\emph{\texttt{Boolean}}) -- 

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_offset() (libPoMo.cf.CFWriter method)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.CFWriter.set_offset}\pysiglinewithargsret{\sphinxbfcode{set\_offset}}{\emph{offset}}{}
Set the offset of the sequence.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{offset}} (\emph{\texttt{int}}) -- Value that can be set, if the reference
sequence does not start at the 1-based
position 1 but at the 1-based position
\emph{offset}.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_ploidy() (libPoMo.cf.CFWriter method)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.CFWriter.set_ploidy}\pysiglinewithargsret{\sphinxbfcode{set\_ploidy}}{\emph{ploidy}}{}
Set the ploidy.

In VCF files, usually the bases of all copies of the same
chromosomes are given and separated by `/' or `\textbar{}'.  If the
species is not diploid, this ploidy has to be set manually
with this function.

\end{fulllineitems}

\index{set\_seq() (libPoMo.cf.CFWriter method)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.CFWriter.set_seq}\pysiglinewithargsret{\sphinxbfcode{set\_seq}}{\emph{seq}}{}
Set the reference sequence.

\end{fulllineitems}

\index{write\_HLn() (libPoMo.cf.CFWriter method)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.CFWriter.write_HLn}\pysiglinewithargsret{\sphinxbfcode{write\_HLn}}{}{}
Write the counts format header line to \emph{self.outFN}.

\end{fulllineitems}

\index{write\_Ln() (libPoMo.cf.CFWriter method)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.CFWriter.write_Ln}\pysiglinewithargsret{\sphinxbfcode{write\_Ln}}{}{}
Write a line in counts format to \emph{self.outFN}.

\end{fulllineitems}

\index{write\_Rn() (libPoMo.cf.CFWriter method)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.CFWriter.write_Rn}\pysiglinewithargsret{\sphinxbfcode{write\_Rn}}{\emph{rg}}{}
Write lines in counts format to \emph{self.outFN}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{rg}} ({\hyperref[seqbase:libPoMo.seqbase.Region]{\sphinxcrossref{\emph{\texttt{Region}}}}}) -- {\hyperref[seqbase:libPoMo.seqbase.Region]{\sphinxcrossref{\sphinxcode{Region}}}}
object that determines the region that is
covered.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CountsFormatWriterError}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.CountsFormatWriterError}\pysigline{\sphinxstrong{exception }\sphinxcode{libPoMo.cf.}\sphinxbfcode{CountsFormatWriterError}}
General \sphinxtitleref{CFWriter} object error.

\end{fulllineitems}

\index{NoSynBase}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.NoSynBase}\pysigline{\sphinxstrong{exception }\sphinxcode{libPoMo.cf.}\sphinxbfcode{NoSynBase}}
Not a 4-fold degenerate site.

\end{fulllineitems}

\index{NotACountsFormatFileError}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.NotACountsFormatFileError}\pysigline{\sphinxstrong{exception }\sphinxcode{libPoMo.cf.}\sphinxbfcode{NotACountsFormatFileError}}
CF file not valid.

\end{fulllineitems}

\index{cf\_to\_fasta() (in module libPoMo.cf)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.cf_to_fasta}\pysiglinewithargsret{\sphinxcode{libPoMo.cf.}\sphinxbfcode{cf\_to\_fasta}}{\emph{cfS}, \emph{outname}, \emph{consensus=False}}{}
Convert a {\hyperref[cf:libPoMo.cf.CFStream]{\sphinxcrossref{\sphinxcode{CFStream}}}} to a fasta file.

Extracts the sequences of a counts file that has been initialized
with an {\hyperref[cf:libPoMo.cf.CFStream]{\sphinxcrossref{\sphinxcode{CFStream}}}}.  The conversion starts at the line
pointed to by the {\hyperref[cf:libPoMo.cf.CFStream]{\sphinxcrossref{\sphinxcode{CFStream}}}}.

If more than one base is present at a single site, one base is
sampled out of all present ones according to its abundance.

If consensus is set to True, the consensus sequence is extracted
(e.g., no sampling but the bases with highest counts for each
individual or population are chosen).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{cfS}} ({\hyperref[cf:libPoMo.cf.CFStream]{\sphinxcrossref{\emph{\texttt{CFStream}}}}}) -- Counts format file stream.

\item {} 
\textbf{\texttt{outname}} (\emph{\texttt{str}}) -- Fasta output file name.

\item {} 
\textbf{\texttt{consensus}} (\emph{\texttt{Boolean}}) -- Optional; Extract consensus sequence?
Defaults to False.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{faseq\_append\_base\_of\_cfS() (in module libPoMo.cf)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.faseq_append_base_of_cfS}\pysiglinewithargsret{\sphinxcode{libPoMo.cf.}\sphinxbfcode{faseq\_append\_base\_of\_cfS}}{\emph{faS}, \emph{cfS}, \emph{consensus=False}}{}
Append a {\hyperref[cf:libPoMo.cf.CFStream]{\sphinxcrossref{\sphinxcode{CFStream}}}} line to an {\hyperref[fasta:libPoMo.fasta.FaSeq]{\sphinxcrossref{\sphinxcode{libPoMo.fasta.FaSeq}}}}.

Randomly chooses bases for each position according to their
abundance.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{faS}} ({\hyperref[fasta:libPoMo.fasta.FaSeq]{\sphinxcrossref{\emph{\texttt{FaSeq}}}}}) -- Fasta sequence to append base to.

\item {} 
\textbf{\texttt{cfS}} ({\hyperref[cf:libPoMo.cf.CFStream]{\sphinxcrossref{\emph{\texttt{CFStream}}}}}) -- CFStream containing the base.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{fasta\_to\_cf() (in module libPoMo.cf)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.fasta_to_cf}\pysiglinewithargsret{\sphinxcode{libPoMo.cf.}\sphinxbfcode{fasta\_to\_cf}}{\emph{fastaFN}, \emph{countsFN}, \emph{splitChar='-`}, \emph{chromName='NA'}, \emph{double\_fixed\_sites=False}}{}
Convert fasta to counts format.

The (aligned) sequences in the fasta file are read in and the data
is written to a counts format file.

Sequence names are stripped at the first dash.  If the strupped
sequence name coincide, individuals are put into the same
population.

E.g., homo\_sapiens-XXX and homo\_sapiens-YYY will be in the same
population homo\_sapiens.

Take care with large files, this uses a lot of memory.

The input as well as the output files can additionally be gzipped
(indicated by a .gz file ending).
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{double\_fixed\_sites}} (\emph{\texttt{bool}}) -- Set to true if heterozygotes are

\end{description}\end{quote}

encoded with IUPAC codes.  Then, fixed sites will be counted twice
so that the level of polymorphism stays correct.

\end{fulllineitems}

\index{interpret\_cf\_line() (in module libPoMo.cf)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.interpret_cf_line}\pysiglinewithargsret{\sphinxcode{libPoMo.cf.}\sphinxbfcode{interpret\_cf\_line}}{\emph{ln}}{}
Interpret a counts file line.

Return type is a tuple containing the chromosome name, the
position and a list with nucleotide counts (cf. counts file).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{ln}} (\emph{\texttt{str}}) -- Line in counts format.

\item[{Return type}] \leavevmode
(str, int, {[}{[}int{]}{]})

\end{description}\end{quote}

\end{fulllineitems}

\index{weighted\_choice() (in module libPoMo.cf)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.weighted_choice}\pysiglinewithargsret{\sphinxcode{libPoMo.cf.}\sphinxbfcode{weighted\_choice}}{\emph{lst}}{}
Choose element in integer list according to its value.

E.g., in {[}1,10{]}, the second element will be chosen 10 times as
often as the first one.  Returns the index of the chosen element.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\textbf{\texttt{lst}} (\emph{\texttt{{[}int{]}}}) -- List of integers.

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_cf\_from\_MFaStream() (in module libPoMo.cf)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.write_cf_from_MFaStream}\pysiglinewithargsret{\sphinxcode{libPoMo.cf.}\sphinxbfcode{write\_cf\_from\_MFaStream}}{\emph{refMFaStr}, \emph{cfWr}}{}
Write counts file using the given MFaStream and CFWriter.

Write the counts format file using the first sequences of all
alignments in the MFaStream.  The sequences are automatically
reversed and complemented if this is needed (indicated in the
header line).  This is very useful if you e.g. want to compare the
VCF files to a CCDC alignment.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{refMFaStr}} (\emph{\texttt{FMaStream}}) -- The reference {\hyperref[fasta:libPoMo.fasta.MFaStream]{\sphinxcrossref{\sphinxcode{MFaStream}}}}.

\item {} 
\textbf{\texttt{cfWf}} ({\hyperref[cf:libPoMo.cf.CFWriter]{\sphinxcrossref{\emph{\texttt{CFWriter}}}}}) -- The {\hyperref[cf:libPoMo.cf.CFWriter]{\sphinxcrossref{\sphinxcode{CFWriter}}}} object that contains
the VCF files.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{write\_cf\_from\_gp\_stream() (in module libPoMo.cf)}

\begin{fulllineitems}
\phantomsection\label{cf:libPoMo.cf.write_cf_from_gp_stream}\pysiglinewithargsret{\sphinxcode{libPoMo.cf.}\sphinxbfcode{write\_cf\_from\_gp\_stream}}{\emph{gp\_stream}, \emph{cfWr}}{}
Write counts file using a given GP stream with reference and CFWriter.

Write the counts format file using all genes in the GP stream.
The sequences are automatically reversed and complemented if this
is needed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{gp\_stream}} (\emph{\texttt{GPStream}}) -- The GP stream and reference \sphinxcode{GPStream}.

\item {} 
\textbf{\texttt{cfWf}} ({\hyperref[cf:libPoMo.cf.CFWriter]{\sphinxcrossref{\emph{\texttt{CFWriter}}}}}) -- The {\hyperref[cf:libPoMo.cf.CFWriter]{\sphinxcrossref{\sphinxcode{CFWriter}}}} object that contains
the VCF files.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{l}
\item {\texttt{libPoMo.cf}}, \pageref{cf:module-libPoMo.cf}
\item {\texttt{libPoMo.fasta}}, \pageref{fasta:module-libPoMo.fasta}
\item {\texttt{libPoMo.main}}, \pageref{main:module-libPoMo.main}
\item {\texttt{libPoMo.seqbase}}, \pageref{seqbase:module-libPoMo.seqbase}
\item {\texttt{libPoMo.vcf}}, \pageref{vcf:module-libPoMo.vcf}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
